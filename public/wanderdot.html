<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>WanderDot's World</title>
    <style>
        /* --- 1. CSS VARIABLES & SETUP --- */
        :root {
            --color-field-bg: #013220;
            --color-ui-bg: rgba(0, 0, 0, 0.4);
            --color-ui-border: #ccc;
            --color-text: white;
            --color-eureka-glow: gold;
            --color-thought-bg: rgba(25, 25, 112, 0.5);
            --font-main: monospace;
        }

        /* Strict overflow hidden to prevent mobile scrolling/OOB viewing */
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            width: 100%;
            height: 100%;
        }

        body {
            background-color: var(--color-field-bg);
            font-family: var(--font-main);
            cursor: default;
            user-select: none; 
            /* Ensure pixel art scales cleanly */
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        /* --- 2. WORLD CONTAINERS & LAYERS --- */
        #world-container {
            position: relative;
            /* Dimensions are set explicitly by JS (Game.resizeCanvases) for mobile compatibility */
            overflow: hidden;
        }

        canvas {
            display: block;
            position: absolute;
            top: 0; left: 0;
        }

        /* Z-Index layering UPDATED: Consolidated rendering for depth sorting */
        #pathCanvas { z-index: 0; } /* Dirt paths at the bottom */
        #mainCanvas { z-index: 1; } /* Everything else (WanderDot, Grass, Entities, Particles) */


        /* --- 3. UI ELEMENTS --- */

        /* Thought Bubble */
        #thought-bubble {
            position: absolute;
            display: none;
            font-size: 2.5rem; /* Default font size, can be changed dynamically by UIManager */
            padding: 0.6rem;
            background-color: var(--color-thought-bg);
            border: 2px solid var(--color-ui-border);
            border-radius: 50%;
            backdrop-filter: blur(3px);
            transition: opacity 0.3s ease-in-out, left 0.1s linear, top 0.1s linear; 
            z-index: 4;
            cursor: pointer;
            transform: translate(-50%, -50%); 
            white-space: nowrap;
        }

        .is-rising {
            animation: rise-up 0.4s cubic-bezier(0.18, 0.89, 0.32, 1.28);
        }

        #thought-bubble > span {
            pointer-events: none;
        }

        /* Buff Container */
        #buff-container {
            position: absolute;
            top: 20px; right: 20px;
            display: flex;
            flex-direction: row-reverse;
            gap: 15px;
            z-index: 5;
        }

        .buff-indicator {
            display: none;
            flex-direction: column;
            align-items: center;
            text-shadow: 0 0 5px black;
        }
        
        .buff-icon {
            font-size: 1.5rem;
            transition: box-shadow 0.3s ease-in-out;
        }

        .eureka-state .buff-icon {
            border-radius: 5px;
            box-shadow: 0 0 8px 3px var(--color-eureka-glow);
        }

        .buff-timer {
            font-size: 0.8rem;
            color: var(--color-text);
            margin-top: 2px;
        }
        
        /* Item Bar */
        #item-bar {
            position: absolute;
            bottom: -100px;
            left: 50%;
            transform: translateX(-50%);
            background-color: var(--color-ui-bg);
            border: 2px solid var(--color-ui-border);
            border-bottom: none;
            border-radius: 10px 10px 0 0;
            padding: 5px;
            display: flex;
            gap: 5px;
            z-index: 5;
            transition: bottom 0.4s ease-in-out;
        }

        #item-bar.visible {
            bottom: 0;
        }

        .item-button {
            background-color: #333;
            border: 2px solid #888;
            border-radius: 5px;
            color: var(--color-text);
            font-size: 1rem;
            width: 60px; height: 60px;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .item-button.visible {
            display: flex;
        }

        .item-button.clicked {
            animation: use-item-anim 0.2s ease-out;
        }
        
        /* World Timer (Top Left) */
        #timer-container {
            position: absolute;
            top: 10px; left: 10px;
            z-index: 5;
            display: flex;
            align-items: flex-start;
        }

        #timer-icon {
            font-size: 1.2rem;
            background-color: var(--color-ui-bg);
            border: 2px solid rgba(204, 204, 204, 0.5);
            padding: 5px;
            border-radius: 4px;
            cursor: pointer; 
            display: flex;
            align-items: center;
            justify-content: center;
            width: 1.8rem; height: 1.8rem;
        }

        #world-timer {
            margin-left: 10px;
            font-size: 0.9rem;
            color: var(--color-text);
            text-shadow: 0 0 5px black;
            background-color: rgba(128, 128, 128, 0.3);
            border-radius: 5px;
            white-space: nowrap; /* Default for desktop rollout */
            pointer-events: none;
            
            /* Rollout transition setup */
            opacity: 0;
            max-width: 0;
            padding: 8px 0px; /* Vertical padding only */
            overflow: hidden;
            transition: opacity 0.3s ease-in-out, max-width 0.5s ease-in-out, padding 0.5s ease-in-out;
        }

        /* Active states for rollout (Hover or Clicked) */
        #timer-container:hover #world-timer,
        #timer-container.active #world-timer {
            opacity: 1;
            max-width: 600px; /* Ample space for the text */
            padding: 8px 12px; /* Restore horizontal padding */
        }

        /* --- 3.5. MOBILE RESPONSIVENESS --- */
        @media (max-width: 768px) {
            #world-timer {
                white-space: normal; /* Allow wrapping on mobile */
            }

            /* Active states on mobile */
            #timer-container:hover #world-timer,
            #timer-container.active #world-timer {
                /* Constrain width to prevent overflow. */
                max-width: calc(100vw - 70px);
            }
        }


        /* --- 4. KEYFRAME ANIMATIONS (Unchanged) --- */
        @keyframes rise-up {
            from { opacity: 0; transform: translate(-50%, -50%) scale(0.4); }
            to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }

        @keyframes blink {
            50% { opacity: 0.2; }
        }
        .blinking {
            animation: blink 0.5s infinite;
        }

        @keyframes blip-out {
            to { transform: scale(0); opacity: 0; }
        }
        .blip-out {
            animation: blip-out 0.3s forwards;
        }

        @keyframes use-item-anim {
            50% { transform: scale(0.85); }
        }
        
        @keyframes wiggle {
            0%, 100% { transform: rotate(0deg); }
            25% { transform: rotate(15deg); }
            75% { transform: rotate(-15deg); }
        }
    </style>
</head>
<body>
    <div id="world-container">
        <canvas id="pathCanvas"></canvas>
        <canvas id="mainCanvas"></canvas>
        
        <div id="thought-bubble"></div>
        <div id="timer-container">
            <div id="timer-icon">üï∞Ô∏è</div>
            <div id="world-timer"></div>
        </div>
        <div id="buff-container"></div>
        <div id="item-bar"></div>
    </div>

    <script>
        // ====================================================================
        // 0. CONFIGURATION & UTILITIES
        // ====================================================================

        const Config = {
            // (Configuration remains unchanged from the previous version)
            // Mood Thresholds
            WARNING_ANNOYANCE_THRESHOLD: 25,
            ANNOYANCE_THRESHOLD: 40,
            MAD_THRESHOLD: 75,
            
            // Colors
            COLOR_NORMAL: { r: 255, g: 255, b: 224 },
            COLOR_ANNOYED: { r: 255, g: 165, b: 0 },
            COLOR_MAD: { r: 152, g: 14, b: 11 },
            COLOR_HANGRY_GLOW: 'rgba(255, 100, 100, 0.7)',
            
            // Terrain Colors
            COLOR_FIELD: { r: 1, g: 50, b: 32 },
            COLOR_DIRT: { r: 101, g: 67, b: 33 },
            COLOR_ALIEN_BLUE: { r: 100, g: 149, b: 237 }, 
            COLOR_ALIEN_CLAY: { r: 205, g: 133, b: 63 },
            COLOR_ALIEN_TINT: 'rgba(100, 149, 237, 0.5)', 

            // World Grid
            GRID_CELL_SIZE: 10,
            MAX_WEAR: 100,
            WEAR_PER_PIXEL: 0.05, // Wear applied to the dirt path
            
            // Grass Configuration
            GRASS_CLUMP_COUNT: 800, 
            GRASS_CLUMP_MIN_SIZE: 3,
            GRASS_CLUMP_MAX_SIZE: 6,
            GRASS_CLUMP_RADIUS: 12,

            GRASS_INTERACTION_RADIUS: 25, // How far away grass reacts to movement (from the south edge)
            GRASS_LANDING_RADIUS: 60, // How far away grass reacts to landing
            
            GRASS_BASE_OPACITY: 0.5,
            GRASS_WEAR_FADE_THRESHOLD: 30, 

            GRASS_SLIDE_DISTANCE: 10, // Max distance grass slides aside
            GRASS_BEND_ANGLE: 45 * (Math.PI / 180), // Max bend angle (in radians)

            // Legacy thresholds (used for entity spawning/maturation on dirt)
            GRASS_REMOVAL_THRESHOLD: 50, 
            PEBBLE_SPAWN_THRESHOLD: 70,
            
            UFO_MUSHROOM_CHANCE: 0.015,

            // WanderDot Base Stats
            BASE_SPEED: 120,
            BASE_RADIUS: 20,
            EAT_MUSHROOM_CHANCE: 0.02,
            EAT_DETECTION_RADIUS: 100,
            EAT_DURATION: 4000,

            // Kangaroo Mechanics
            BOUNCE_DISTANCE: 120,
            BOUNCE_HEIGHT: 60,
            BASE_IMPACT_WEAR: 15,

            // Buffs & Items Configuration
            WATCH_TIME_EXTENSION: 20000,
            MUSHROOM_BUFF_DURATION: 20000,
            SEED_MATURATION_TIME: 60000,

            Items: {
                watch: { emoji: '‚åö', type: 'utility' },
                coffee: { emoji: '‚òï', type: 'buff', duration: 20000 },
                pizza: { emoji: 'üçï', type: 'buff', duration: 30000 },
                kangaroo: { emoji: 'ü¶ò', type: 'buff', duration: 30000 },
                lightbulb: { emoji: 'üí°', type: 'utility' },
                mushroom: { emoji: 'üçÑ', type: 'buff', hideTimer: true } 
            },

            // Emojis
            Emojis: {
                idle: ['üí°', 'üò¥', 'üéÆ', 'üé∂', '‚òï', '‚åö', 'üçï', 'üëΩ', 'ü¶ò','üé•'],
                commandReceived: ['ü§î','üëÄ'],
                annoyed: ['üòí', 'üôÑ', 'üòë', 'ü§®'],
                mad: ['üò´', 'ü§°', 'üë∫', 'üò°', 'ü§¨'],
                madZone: ['üëø', '‚ò†Ô∏è', 'üëé', 'ü§¨'],
                cooldownToAnnoyed: ['üò§'],
                cooldownToNormal: ['ü•∞'],
                directClick: ['üòò', 'ü§≠', 'üòõ', 'üò≥', 'ü•µ', 'üçÜ', 'üí¶'],
                EATING_SEEKING: 'üëÖ',
                EATING_CONSUMING: 'ü§§',
                EATING_SATISFIED: 'üòã',
                // Entities
                SEED: 'ü•î',
                FLOWER: 'üåº',
                BROWN_MUSHROOM: 'üçÑ‚Äçüü´',
                DIAMOND: 'üî∏',
            },

            // Asset Paths
            Assets: {
                grass: [
                    '../images/grass/grass_blade_01.png',
                    '../images/grass/grass_blade_02.png',
                    '../images/grass/grass_blade_03.png',
                    '../images/grass/grass_blade_04.png',
                    '../images/grass/grass_blade_05.png',
                    '../images/grass/grass_blade_06.png',
                ]
            }
        };

        // Terrain Types Enum
        const TerrainType = {
            NORMAL: 'normal',
            ALIEN_BLUE: 'alienBlue',
            ALIEN_CLAY: 'alienClay'
        };

        const Utils = {
            // (Utils implementation remains unchanged)
            lerp(start, end, amount) {
                return start * (1 - amount) + end * amount;
            },
            lerpColor(colorA, colorB, amount) {
                const r = Math.round(Utils.lerp(colorA.r, colorB.r, amount));
                const g = Math.round(Utils.lerp(colorA.g, colorB.g, amount));
                const b = Math.round(Utils.lerp(colorA.b, colorB.b, amount));
                return `rgb(${r}, ${g}, ${b})`;
            },
            randomChoice(arr) {
                return arr[Math.floor(Math.random() * arr.length)];
            },
            distance(x1, y1, x2, y2) {
                return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
            },
            clamp(num, min, max) {
                return Math.max(min, Math.min(max, num));
            },
            randomRange(min, max) {
                return Math.random() * (max - min) + min;
            },
            checkEmojiSupport(emoji) {
                try {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    if (!ctx) return true; 

                    ctx.font = '20px sans-serif';
                    const metrics = ctx.measureText(emoji);
                    const baselineMetrics = ctx.measureText('üçÑ'); 

                    return metrics.width <= baselineMetrics.width * 1.5;
                } catch (e) {
                    console.warn("Emoji support check failed, assuming support:", e);
                    return true;
                }
            }
        };

        // ====================================================================
        // 0.5. ASSET MANAGER
        // ====================================================================
        
        // (AssetManager implementation remains unchanged)
        class AssetManager {
            constructor() {
                this.images = {
                    grass: []
                };
                this.loadedCount = 0;
                this.totalCount = 0;
                // Buffer canvas for tinting effects
                this.tintBuffer = document.createElement('canvas');
                this.tintBufferCtx = this.tintBuffer.getContext('2d');
            }

            loadAll(onComplete) {
                this.totalCount = Config.Assets.grass.length;

                if (this.totalCount === 0) {
                    onComplete();
                    return;
                }

                Config.Assets.grass.forEach((path, index) => {
                    const img = new Image();
                    img.src = path;
                    img.onload = () => {
                        this.images.grass[index] = img;
                        this.loadedCount++;
                        if (this.loadedCount === this.totalCount) {
                            onComplete();
                        }
                    };
                    img.onerror = () => {
                        console.error(`Failed to load asset: ${path}. Ensure the path is correct.`);
                        // Treat as loaded even if failed, to allow game to proceed (might look weird)
                        this.loadedCount++;
                        if (this.loadedCount === this.totalCount) {
                            onComplete();
                        }
                    }
                });
            }

            // Helper function to draw a tinted version of an image using the buffer
            drawTinted(ctx, image, x, y, width, height, tintColor) {
                if (!this.tintBufferCtx) {
                    // Fallback if buffer context fails
                    ctx.drawImage(image, x, y, width, height);
                    return;
                }

                // Setup buffer dimensions
                this.tintBuffer.width = width;
                this.tintBuffer.height = height;

                // 1. Draw the original image onto the buffer
                this.tintBufferCtx.drawImage(image, 0, 0, width, height);

                // 2. Apply the tint color using 'source-atop' composite operation
                // This colors the opaque pixels of the image with the tint color.
                this.tintBufferCtx.globalCompositeOperation = 'source-atop';
                this.tintBufferCtx.fillStyle = tintColor;
                this.tintBufferCtx.fillRect(0, 0, width, height);
                
                // Reset composite operation
                this.tintBufferCtx.globalCompositeOperation = 'source-over';

                // 3. Draw the tinted buffer onto the main context
                ctx.drawImage(this.tintBuffer, x, y, width, height);
            }
        }

        // ====================================================================
        // 1. ENTITY MANAGER (Seeds, Diamonds, Pebbles, Mushrooms)
        // ====================================================================
        
        // UPDATED: Adapted for single-canvas rendering and depth sorting.
        class EntityManager {
            // ctx is now the main canvas context
            constructor(ctx) {
                this.ctx = ctx;
                this.pebbles = [];
                this.mushrooms = [];
                this.dynamicEntities = [];
                // needsRedraw is deprecated as we redraw every frame now.
            }

            // NEW: Combines all entities for the main game loop sorting
            getAllEntities() {
                // Assign types for the drawEntity function if not already present
                const typedPebbles = this.pebbles.map(p => ({...p, entityType: 'pebble'}));
                const typedMushrooms = this.mushrooms.map(m => ({...m, entityType: 'mushroom'}));
                // Dynamic entities already have a 'type' property, rename it to entityType for consistency
                const typedDynamic = this.dynamicEntities.map(e => ({...e, entityType: e.type}));

                return [...typedPebbles, ...typedMushrooms, ...typedDynamic];
            }

            // --- Dynamic Entities ---
            // (Methods updated to remove needsRedraw=true)
            addEntity(type, x, y, data = {}) {
                const entity = {
                    type: type,
                    x: x, y: y,
                    createdAt: Date.now(),
                    ...data
                };
                this.dynamicEntities.push(entity);
            }

            removeDynamicEntitiesInArea(x, y, radius) {
                let removed = false;
                const radiusSq = radius * radius;
                const destructibleTypes = ['flower', 'brownMushroom'];

                for (let i = this.dynamicEntities.length - 1; i >= 0; i--) {
                    const entity = this.dynamicEntities[i];

                    if (destructibleTypes.includes(entity.type)) {
                        const distSq = (entity.x - x)**2 + (entity.y - y)**2;
                        // Check if the entity center is within the radius
                        if (distSq < radiusSq) {
                            this.dynamicEntities.splice(i, 1);
                            removed = true;
                        }
                    }
                }
                return removed;
            }


            update(worldManager) {
                const now = Date.now();
                for (let i = this.dynamicEntities.length - 1; i >= 0; i--) {
                    const entity = this.dynamicEntities[i];
                    
                    if (entity.type === 'seed') {
                        if (now - entity.createdAt > Config.SEED_MATURATION_TIME) {
                            this.matureSeed(entity, i, worldManager);
                        }
                    }
                }
            }

            matureSeed(seed, index, worldManager) {
                const terrainInfo = worldManager.getTerrainInfoAtPoint(seed.x, seed.y);
                let newType = null;

                // Maturation still relies on the underlying dirt path wear level
                if (terrainInfo.wear < Config.GRASS_REMOVAL_THRESHOLD) {
                    if (terrainInfo.type === TerrainType.NORMAL) {
                        newType = 'flower';
                    } else if (terrainInfo.type === TerrainType.ALIEN_BLUE) {
                        newType = 'brownMushroom';
                    }
                }
                
                if (newType) {
                    seed.type = newType;
                } else {
                    this.dynamicEntities.splice(index, 1);
                }
            }

            // --- Static Entities (Pebbles, Mushrooms) ---
            // (Methods updated to remove needsRedraw=true)
            addPebble(pebble) {
                this.pebbles.push(pebble);
            }

            addMushroom(mushroom) {
                if(!this.mushrooms.some(m => m.gridX === mushroom.gridX && m.gridY === mushroom.gridY)) {
                    this.mushrooms.push(mushroom);
                    return true;
                }
                return false;
            }

            removeMushroomByObject(mushroomObject) {
                const index = this.mushrooms.indexOf(mushroomObject);
                if (index > -1) {
                    this.mushrooms.splice(index, 1);
                    return true;
                }
                return false;
            }

            removeMushroomInArea(x, y, radius) {
                let removed = false;
                for(let i = this.mushrooms.length - 1; i >= 0; i--) {
                    const m = this.mushrooms[i];
                    if (Utils.distance(m.x, m.y, x, y) < radius) {
                        this.mushrooms.splice(i, 1);
                        removed = true;
                    }
                }
                return removed;
            }

            getNearbyMushroom(x, y, radius) {
                let closest = null;
                let minDistSq = radius * radius;

                for (const m of this.mushrooms) {
                    const distSq = (m.x - x)**2 + (m.y - y)**2;
                    if (distSq < minDistSq) {
                        minDistSq = distSq;
                        closest = m;
                    }
                }
                return closest;
            }

            // --- Rendering ---
            // UPDATED: The main Game loop now calls drawEntity for each item after sorting.
            // This function is now deprecated/empty as we no longer use a separate entity canvas.
            draw(bounds) {
                // No longer needed.
            }

            // NEW: Draws a single entity (called by the sorted Game loop)
            drawEntity(ctx, e) {
                // Use the provided context (the main canvas ctx)
                
                if (e.entityType === 'pebble') {
                    ctx.font = 'bold 0.7rem monospace';
                    ctx.fillStyle = e.color;
                    ctx.globalAlpha = e.type === 'spaceRock' ? 1.0 : 0.8;
                    ctx.fillText(e.char, e.x, e.y);
                    ctx.globalAlpha = 1.0; // Reset alpha
                } 
                else if (e.entityType === 'mushroom') {
                    ctx.font = '1rem monospace';
                    ctx.globalAlpha = 1.0;
                    ctx.fillText('üçÑ', e.x, e.y);
                }
                else {
                    // Dynamic Entities (Seed, Flower, etc.)
                    ctx.globalAlpha = 1.0;
                    let emoji = '';
                    let fontSize = '1rem';
                    let textShadow = 'none';

                    if (e.entityType === 'seed') {
                        emoji = Config.Emojis.SEED;
                        fontSize = '0.5rem'; // Tiny
                        textShadow = '0 0 2px black, 0 0 2px black, 0 0 2px black'; 
                    }
                    else if (e.entityType === 'brownMushroom') emoji = Config.Emojis.BROWN_MUSHROOM;
                    else if (e.entityType === 'flower') emoji = Config.Emojis.FLOWER;
                    else if (e.entityType === 'diamond') emoji = Config.Emojis.DIAMOND;
                    
                    if (emoji) {
                        ctx.font = `${fontSize} monospace`;
                        ctx.shadowColor = textShadow === 'none' ? 'transparent' : 'black';
                        ctx.shadowBlur = textShadow === 'none' ? 0 : 2;
                        ctx.fillText(emoji, e.x, e.y);
                        ctx.shadowBlur = 0; // Reset shadow
                    }
                }
            }
        }

        // ====================================================================
        // 2. WORLD MANAGER (Environment, Paths, Grass)
        // ====================================================================

        // UPDATED: Adapted for single-canvas rendering and depth sorting.
        class WorldManager {
            // grassCtx is removed, mainCtx is added.
            constructor(width, height, pathCtx, mainCtx, entityManager, assetManager) {
                this.width = width;
                this.height = height;
                this.pathCtx = pathCtx;
                this.mainCtx = mainCtx; // NEW: Reference to the main canvas context
                this.entityManager = entityManager;
                this.assetManager = assetManager;

                this.pathGrid = [];
                
                // Grass structures
                this.grassBlades = [];
                
                this.initializeGrid();
            }

            // (initializeGrid remains unchanged)
            initializeGrid() {
                const gridWidth = Math.ceil(this.width / Config.GRID_CELL_SIZE);
                const gridHeight = Math.ceil(this.height / Config.GRID_CELL_SIZE);

                const newPathGrid = [];

                // Initialize fresh grid or handle resize (preserving existing data if resizing)
                for (let i = 0; i < gridWidth; i++) {
                    newPathGrid[i] = [];
                    for (let j = 0; j < gridHeight; j++) {
                        // Check if cell already exists (from previous size during a resize event)
                        if (this.pathGrid[i] && this.pathGrid[i][j]) {
                             newPathGrid[i][j] = this.pathGrid[i][j];
                        } else {
                            // Initialize new cell
                            newPathGrid[i][j] = { wear: 0, hasPebble: false, terrainType: TerrainType.NORMAL, mistOpacity: 0 };
                        }
                    }
                }
                this.pathGrid = newPathGrid;
            }

            handleResize(width, height) {
                this.width = width;
                this.height = height;
                this.initializeGrid();
                // Regenerate grass field on resize to fill the new area correctly.
                this.grassBlades = []; 
                this.generateGrassField(); 
                this.redrawWorld();
            }

            redrawWorld() {
                // Redraw Paths (on the path canvas)
                this.pathCtx.clearRect(0, 0, this.width, this.height);
                for (let i = 0; i < this.pathGrid.length; i++) {
                    for (let j = 0; j < this.pathGrid[i].length; j++) {
                        const cell = this.pathGrid[i][j];
                        if (cell.wear > 0 || cell.terrainType !== TerrainType.NORMAL) {
                            this.drawPathCell(i, j);
                        }
                    }
                }
                // Grass is redrawn in the main loop.
            }

            // --- Utility Functions ---
            isValidCell(gridX, gridY) {
                return gridX >= 0 && gridX < this.pathGrid.length && gridY >= 0 && gridY < this.pathGrid[0].length;
            }

            getTerrainInfoAtPoint(x, y) {
                const gridX = Math.floor(x / Config.GRID_CELL_SIZE);
                const gridY = Math.floor(y / Config.GRID_CELL_SIZE);
                if (this.isValidCell(gridX, gridY)) {
                    const cell = this.pathGrid[gridX][gridY];
                    return { type: cell.terrainType, wear: cell.wear };
                }
                return { type: TerrainType.NORMAL, wear: 0 };
            }

            // --- GRASS MANAGEMENT ---
            
            // (generateGrassField remains unchanged)
            generateGrassField() {
                // If blades already exist, don't regenerate yet.
                if (this.grassBlades.length > 0) {
                    return;
                }

                this.grassBlades = [];
                const grassImageCount = this.assetManager.images.grass.length;

                if (grassImageCount === 0) {
                    console.warn("No grass assets loaded. Skipping grass generation.");
                    return;
                }

                // Iterate to create the desired number of clumps
                for (let i = 0; i < Config.GRASS_CLUMP_COUNT; i++) {
                    // Find a center point for the clump
                    const centerX = Math.random() * this.width;
                    const centerY = Math.random() * this.height;
                    
                    // Determine the number of blades in this clump
                    const clumpSize = Math.floor(Utils.randomRange(Config.GRASS_CLUMP_MIN_SIZE, Config.GRASS_CLUMP_MAX_SIZE + 1));

                    for (let j = 0; j < clumpSize; j++) {
                        // Calculate blade position within the clump radius using polar coordinates
                        const angle = Math.random() * Math.PI * 2;
                        const radius = Math.random() * Config.GRASS_CLUMP_RADIUS;
                        const xPx = centerX + Math.cos(angle) * radius;
                        const yPx = centerY + Math.sin(angle) * radius;

                        // Ensure the blade is within world bounds
                        if (xPx < 0 || xPx >= this.width || yPx < 0 || yPx >= this.height) continue;

                        // Determine the grid cell (needed for terrain/wear lookup later)
                        const gridX = Math.floor(xPx / Config.GRID_CELL_SIZE);
                        const gridY = Math.floor(yPx / Config.GRID_CELL_SIZE);

                        // Safety check for valid grid cell
                        if (!this.isValidCell(gridX, gridY)) continue;

                        const blade = {
                            x: xPx,
                            y: yPx,
                            gridX: gridX, // Store grid coordinates for efficient lookup
                            gridY: gridY,
                            imageIndex: Math.floor(Math.random() * grassImageCount),
                            scale: Utils.randomRange(0.4, 0.8), 
                            offsetX: 0, 
                            offsetY: 0, 
                            angle: 0    
                        };
                        
                        this.grassBlades.push(blade);
                    }
                }
            }

            // (interactWithGrass remains unchanged, only affects animation state)
            interactWithGrass(impactX, impactY, radius) {
                const radiusSq = radius * radius;

                for (let i = this.grassBlades.length - 1; i >= 0; i--) {
                    const blade = this.grassBlades[i];
                    const distSq = (blade.x - impactX)**2 + (blade.y - impactY)**2;

                    if (distSq < radiusSq) {
                        
                        // Apply Slide and Bend Animation
                        const distance = Math.sqrt(distSq);
                        if (distance > 0.1) {

                            // Calculate vector from impact point to the blade
                            const dx = blade.x - impactX;
                            const dy = blade.y - impactY;
                            
                            // Normalize the vector
                            const nx = dx / distance;
                            const ny = dy / distance;

                            // Calculate intensity (stronger when closer)
                            const intensity = (1 - (distance / radius));
                            
                            // Slide
                            const slideAmount = intensity * Config.GRASS_SLIDE_DISTANCE;
                            blade.offsetX = nx * slideAmount;
                            blade.offsetY = ny * slideAmount;

                            // Bend
                            blade.angle = nx * intensity * Config.GRASS_BEND_ANGLE;
                        }
                    }
                }
            }

            // UPDATED: Simplified as we no longer need to track if a redraw is needed (always redraw).
            updateGrass(deltaTime) {
                const decayRate = 5; // How quickly the grass springs back (higher is faster)

                for (const blade of this.grassBlades) {
                    const needsUpdate = Math.abs(blade.offsetX) > 0.1 || Math.abs(blade.offsetY) > 0.1 || Math.abs(blade.angle) > 0.01;
                    
                    if (needsUpdate) {
                        // Lerp offsets and angle back towards 0
                        blade.offsetX = Utils.lerp(blade.offsetX, 0, decayRate * deltaTime);
                        blade.offsetY = Utils.lerp(blade.offsetY, 0, decayRate * deltaTime);
                        blade.angle = Utils.lerp(blade.angle, 0, decayRate * deltaTime);
                    } else if (blade.offsetX !== 0 || blade.offsetY !== 0 || blade.angle !== 0) {
                        // Snap to 0 when very close
                        blade.offsetX = 0;
                        blade.offsetY = 0;
                        blade.angle = 0;
                    }
                }
            }

            // UPDATED: The main Game loop now calls drawBlade for each item after sorting.
            drawGrass() {
               // Deprecated/Empty. Drawing is handled via drawBlade in the main loop.
            }

            // NEW: Draws a single blade of grass (called by the sorted Game loop)
            drawBlade(ctx, blade) {
                // Use the provided context (the main canvas ctx)

                const grassImages = this.assetManager.images.grass;
                const img = grassImages[blade.imageIndex];
                if (!img || !img.complete) return;

                // 1. Determine Terrain and Wear
                // Check bounds before accessing pathGrid
                if (!this.isValidCell(blade.gridX, blade.gridY)) return;

                const cell = this.pathGrid[blade.gridX][blade.gridY];
                const wear = cell.wear;
                const terrainType = cell.terrainType;

                // 2. Calculate Opacity based on Wear
                let opacity = Config.GRASS_BASE_OPACITY;
                if (wear > Config.GRASS_WEAR_FADE_THRESHOLD) {
                    const fadeProgress = (wear - Config.GRASS_WEAR_FADE_THRESHOLD) / (Config.MAX_WEAR - Config.GRASS_WEAR_FADE_THRESHOLD);
                    opacity = Utils.lerp(Config.GRASS_BASE_OPACITY, 0, fadeProgress);
                }

                if (opacity < 0.05) return; // Skip drawing if nearly invisible

                // 3. Setup drawing parameters
                const width = img.width * blade.scale;
                const height = img.height * blade.scale;
                
                const baseX = blade.x + blade.offsetX;
                const baseY = blade.y + blade.offsetY;

                // 4. Draw (handling rotation and tinting)
                const isTinted = terrainType === TerrainType.ALIEN_BLUE;

                // Set alpha just for this draw call
                ctx.globalAlpha = opacity;

                if (blade.angle !== 0) {
                    ctx.save();
                    ctx.translate(baseX, baseY);
                    ctx.rotate(blade.angle);
                    
                    if (isTinted) {
                        this.assetManager.drawTinted(ctx, img, -width / 2, -height, width, height, Config.COLOR_ALIEN_TINT);
                    } else {
                        ctx.drawImage(img, -width / 2, -height, width, height);
                    }
                    ctx.restore();
                } else {
                    // Optimized drawing for non-rotated blades
                    const drawX = baseX - width / 2;
                    const drawY = baseY - height;

                    if (isTinted) {
                        this.assetManager.drawTinted(ctx, img, drawX, drawY, width, height, Config.COLOR_ALIEN_TINT);
                    } else {
                        ctx.drawImage(img, drawX, drawY, width, height);
                    }
                }
                
                // Reset alpha immediately after drawing the blade
                ctx.globalAlpha = 1.0;
            }


            // --- WEAR AND TEAR (Dirt Paths) ---

            // (applyMovementWear, applyLandingImpact remain unchanged)
            applyMovementWear(startX, startY, endX, endY, buffManager, interactionPointX, interactionPointY) {
                const distance = Utils.distance(startX, startY, endX, endY);
                // Use smaller steps for smoother interaction detection
                const steps = Math.ceil(distance / 5); 
                if (steps === 0) return;

                const buffs = buffManager.getActiveBuffs();
                let dirtWearMultiplier = Config.WEAR_PER_PIXEL;
                
                // Buff multipliers (Grass wear is no longer calculated here)
                if (buffs.coffee) {
                    dirtWearMultiplier *= (1 + 1.0 * buffs.coffee.potency);
                }
                if (buffs.mushroom) {
                    dirtWearMultiplier *= (1 + 1.0 * buffs.mushroom.potency);
                }

                // Determine wear radius based on size buffs
                let dirtWearRadius = 1;
                if (buffs.pizza || buffs.mushroom) {
                    dirtWearRadius = 2;
                }
                if (buffs.pizza && buffs.mushroom) {
                    dirtWearRadius = 3;
                }

                const isHeavy = buffs.pizza || buffs.mushroom;
                const currentDotRadius = Game.instance.wanderDot.radius;

                for (let i = 0; i <= steps; i++) {
                    const t = i / steps;
                    const currentX = Utils.lerp(startX, endX, t);
                    const currentY = Utils.lerp(startY, endY, t);
                    
                    // 1. Apply Wear to Dirt Path
                    this.applyWearToArea(currentX, currentY, dirtWearRadius, (distance/steps) * dirtWearMultiplier);

                    // 3. Entity Destruction while rolling
                    if (isHeavy) {
                        this.entityManager.removeDynamicEntitiesInArea(currentX, currentY, currentDotRadius);
                    }
                }

                // 2. Interact with Grass (Visual movement only, using the specific interaction point)
                // This is done once per frame using the designated interaction point (south edge), rather than interpolated steps.
                this.interactWithGrass(interactionPointX, interactionPointY, Config.GRASS_INTERACTION_RADIUS);
            }

            applyLandingImpact(x, y, moodState, buffManager) {
                let impactWear = Config.BASE_IMPACT_WEAR;

                const buffs = buffManager.getActiveBuffs();
                const isHeavy = buffs.pizza || buffs.mushroom;

                // Buff multipliers
                if (buffs.coffee) {
                    impactWear *= (1 + 1.0 * buffs.coffee.potency);
                }
                if (buffs.kangaroo) {
                    impactWear *= (1 + 0.3 * buffs.kangaroo.potency);
                }
                if (buffs.mushroom) {
                    impactWear *= (1 + 1.0 * buffs.mushroom.potency);
                }

                if (moodState === 'mad') {
                    impactWear *= 1.7;
                    Game.instance.particleManager.spawnLandingParticles(x, y);
                }

                const impactRadius = 2.5;
                
                // 1. Apply Wear to Dirt Path
                this.applyWearToArea(x, y, impactRadius, impactWear, true);
                
                // 2. Interact with Grass (Visual movement only)
                this.interactWithGrass(x, y, Config.GRASS_LANDING_RADIUS);

                // 3. Entity Destruction on impact
                this.entityManager.removeMushroomInArea(x, y, Config.BASE_RADIUS * 2);

                if (isHeavy) {
                    const currentDotRadius = Game.instance.wanderDot.radius;
                    this.entityManager.removeDynamicEntitiesInArea(x, y, currentDotRadius);
                }
            }

            // UPDATED: No longer need to explicitly trigger grass redraw, as it happens every frame.
            applyWearToArea(x, y, radius, wearAmount, useFalloff = false) {
                const centerX = Math.floor(x / Config.GRID_CELL_SIZE);
                const centerY = Math.floor(y / Config.GRID_CELL_SIZE);
                const radiusSq = radius * radius;

                for (let i = -Math.ceil(radius); i <= Math.ceil(radius); i++) {
                    for (let j = -Math.ceil(radius); j <= Math.ceil(radius); j++) {
                        const distSq = i * i + j * j;
                        
                        if (!useFalloff && distSq > radiusSq) continue; 
                        
                        const distance = Math.sqrt(distSq);
                        if (useFalloff && distance > radius) continue;

                        const gridX = centerX + i;
                        const gridY = centerY + j;

                        if (this.isValidCell(gridX, gridY)) {
                            const cell = this.pathGrid[gridX][gridY];
                            const oldWear = cell.wear;
                            
                            let effectiveWear = wearAmount;
                            if (useFalloff) {
                                const falloff = 1 - (distance / radius);
                                effectiveWear *= falloff;
                            }

                            cell.wear = Math.min(Config.MAX_WEAR, cell.wear + effectiveWear);

                            if (Math.floor(cell.wear) > Math.floor(oldWear)) {
                                this.drawPathCell(gridX, gridY);
                                this.trySpawnEntity(gridX, gridY, cell);
                            }
                        }
                    }
                }
            }

            // --- RENDERING & SPAWNING (Unchanged) ---
            // (drawPathCell, trySpawnEntity, spawnPebble, spawnMushroom remain unchanged)
            drawPathCell(gridX, gridY) {
                const cell = this.pathGrid[gridX][gridY];
                const wearRatio = cell.wear / Config.MAX_WEAR;
                let baseColor, targetColor;
                let baseOpacity = 0;

                switch (cell.terrainType) {
                    case TerrainType.ALIEN_BLUE:
                        baseColor = Config.COLOR_ALIEN_BLUE;
                        targetColor = Config.COLOR_DIRT; 
                        baseOpacity = cell.mistOpacity ?? 0; 
                        break;
                    case TerrainType.ALIEN_CLAY:
                        baseColor = Config.COLOR_DIRT; 
                        targetColor = Config.COLOR_ALIEN_CLAY;
                        baseOpacity = 0.2;
                        break;
                    case TerrainType.NORMAL:
                    default:
                        baseColor = Config.COLOR_FIELD;
                        targetColor = Config.COLOR_DIRT;
                        break;
                }

                const pathColor = Utils.lerpColor(baseColor, targetColor, wearRatio);
                const pathOpacity = Math.max(wearRatio * 0.8, baseOpacity);

                this.pathCtx.fillStyle = pathColor;
                this.pathCtx.globalAlpha = pathOpacity;
                this.pathCtx.clearRect(gridX * Config.GRID_CELL_SIZE, gridY * Config.GRID_CELL_SIZE, Config.GRID_CELL_SIZE, Config.GRID_CELL_SIZE);
                this.pathCtx.fillRect(gridX * Config.GRID_CELL_SIZE, gridY * Config.GRID_CELL_SIZE, Config.GRID_CELL_SIZE, Config.GRID_CELL_SIZE);
                this.pathCtx.globalAlpha = 1.0;
            }

            trySpawnEntity(gridX, gridY, cell) {
                if (cell.hasPebble) return;

                if (cell.terrainType === TerrainType.ALIEN_CLAY && Math.random() < 0.005) {
                    const x = gridX * Config.GRID_CELL_SIZE + Utils.randomRange(2, Config.GRID_CELL_SIZE - 2);
                    const y = gridY * Config.GRID_CELL_SIZE + Utils.randomRange(2, Config.GRID_CELL_SIZE - 2);
                    this.entityManager.addEntity('diamond', x, y);
                }

                if (cell.wear > Config.PEBBLE_SPAWN_THRESHOLD) {
                    let spawnChance = 0.01;
                    let pebbleType = 'normal';
                    
                    if (cell.terrainType === TerrainType.ALIEN_BLUE) {
                        spawnChance = 0.03;
                        pebbleType = 'spaceRock';
                    } else if (cell.terrainType === TerrainType.ALIEN_CLAY) {
                        spawnChance = 0.008; 
                    }

                    if (Math.random() < spawnChance) {
                        this.spawnPebble(gridX, gridY, pebbleType);
                        cell.hasPebble = true;
                    }
                }
            }

            spawnPebble(gridX, gridY, type) {
                let colors, chars;

                if (type === 'spaceRock') {
                    colors = ['#4B0082', '#6A0DAD', '#551A8B'];
                    chars = ['*', 'o', 'O', '.:', '.:.'];
                } else {
                    colors = ['#000000', '#1C1C1C', '#2A1A10', '#3D2B1F'];
                    chars = ['..', '.-.', ".;'", '-_,`', ':'];
                }

                const pebble = {
                    x: gridX * Config.GRID_CELL_SIZE + Math.random() * Config.GRID_CELL_SIZE,
                    y: gridY * Config.GRID_CELL_SIZE + Math.random() * Config.GRID_CELL_SIZE,
                    char: Utils.randomChoice(chars),
                    color: Utils.randomChoice(colors),
                    type: type
                };
                this.entityManager.addPebble(pebble);
            }

            spawnMushroom(gridX, gridY) {
                const mushroom = {
                    x: gridX * Config.GRID_CELL_SIZE + (Config.GRID_CELL_SIZE / 2),
                    y: gridY * Config.GRID_CELL_SIZE + (Config.GRID_CELL_SIZE / 2),
                    gridX, gridY
                };
                return this.entityManager.addMushroom(mushroom);
            }

            // --- UFO/ALIEN TERRAFORMING ---
            // (alterGround remains unchanged)
            alterGround(x, y) {
                const centerX = Math.floor(x / Config.GRID_CELL_SIZE);
                const centerY = Math.floor(y / Config.GRID_CELL_SIZE);
                const alterRadius = 3;

                for(let i = -alterRadius; i <= alterRadius; i++) {
                    for (let j = -alterRadius; j <= alterRadius; j++) {
                        const distSq = i*i + j*j;
                        if (distSq > alterRadius * alterRadius) continue;
                        
                        const gridX = centerX + i;
                        const gridY = centerY + j;

                        if (this.isValidCell(gridX, gridY)) {
                            const cell = this.pathGrid[gridX][gridY];
                            
                            // Terrain type determination relies on the underlying dirt path wear
                            const isGrass = cell.wear < Config.GRASS_REMOVAL_THRESHOLD;
                            const targetType = isGrass ? TerrainType.ALIEN_BLUE : TerrainType.ALIEN_CLAY;

                            
                            if (targetType === TerrainType.ALIEN_BLUE) {
                                const distance = Math.sqrt(distSq);
                                const falloff = 1 - (distance / alterRadius);
                                const newOpacity = Utils.clamp(falloff * Utils.randomRange(0.2, 0.5), 0.1, 0.5);
                                cell.mistOpacity = Math.max(cell.mistOpacity, newOpacity);
                            }

                            if (cell.terrainType !== targetType) {
                                cell.terrainType = targetType;
                            }
                            
                            this.drawPathCell(gridX, gridY);

                            // Spawn Mushrooms (using configured reduced chance)
                            if(targetType === TerrainType.ALIEN_BLUE && Math.random() < Config.UFO_MUSHROOM_CHANCE) {
                                this.spawnMushroom(gridX, gridY);
                            }
                        }
                    }
                }
            }
        }

        // ====================================================================
        // 3. WANDERDOT (The Circle, Mood, and Behavior)
        // ====================================================================

        class WanderDot {
            // (Constructor and Mood Logic remain unchanged)
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.previousX = x;
                this.previousY = y;
                
                this.radius = Config.BASE_RADIUS;
                this.color = Utils.lerpColor(Config.COLOR_NORMAL, Config.COLOR_NORMAL, 0);

                this.speed = Config.BASE_SPEED;
                this.currentSpeedMultiplier = 1.0;

                this.dx = (Math.random() - 0.5) * 2;
                this.dy = (Math.random() - 0.5) * 2;
                this.targetX = null;
                this.targetY = null;

                // Mood state
                this.annoyance = 0;
                this.currentMoodState = 'normal';
                this.isCalm = false;
                this.isHangry = false;
                
                // Behavior state
                this.isEating = false;
                this.eatingStartTime = 0;
                this.eatingTarget = null;

                // Bounce state
                this.distanceTraveledOnCurrentBounce = 0;
                this.jiggleEndTime = 0;
                this.verticalOffset = 0;
            }

            setTarget(x, y) {
                if (this.isHangry) {
                    return false;
                }

                // If the dot is currently chewing (eatingStartTime > 0), interrupting it triggers Hangry
                if (this.isEating && this.eatingStartTime > 0) {
                    this.triggerHangry();
                    return false;
                }

                this.targetX = x;
                this.targetY = y;
                return true;
            }

            triggerHangry() {
                this.isHangry = true;
                this.annoyance = Math.max(this.annoyance, Config.MAD_THRESHOLD + 1);
                // Reset eating state
                this.isEating = false;
                this.eatingTarget = null;
                this.eatingStartTime = 0;
                this.clearTarget();
                // Show angry thought bubble immediately
                Game.instance.uiManager.showThought(Utils.randomChoice(Config.Emojis.mad));
            }


            clearTarget() {
                this.targetX = null;
                this.targetY = null;
                this.distanceTraveledOnCurrentBounce = 0;
            }

            update(deltaTime, bounds, buffManager, worldManager, entityManager) {
                this.updateMood(deltaTime, buffManager);
                this.updatePosition(deltaTime, bounds, buffManager, worldManager, entityManager);
            }

            // --- MOOD LOGIC (Unchanged) ---
            getMoodState(annoyanceValue) {
                if (annoyanceValue > Config.MAD_THRESHOLD) return 'mad';
                if (annoyanceValue > Config.ANNOYANCE_THRESHOLD) return 'annoyed';
                return 'normal';
            }

            addAnnoyance(amount, isDirectClick) {
                let annoyanceToAdd = amount;

                if (this.isCalm) {
                    annoyanceToAdd = 5;
                    this.isCalm = false;
                }

                if (isDirectClick) {
                    annoyanceToAdd *= 1.5;
                }

                this.annoyance = Math.min(100, this.annoyance + annoyanceToAdd);
                return this.getReactionEmoji(isDirectClick);
            }

            getReactionEmoji(isDirectClick) {
                 if (isDirectClick) {
                    const levels = [20, 30, 45, 60, 75, 90];
                    let level = Config.Emojis.directClick.length - 1;
                    for (let i = 0; i < levels.length; i++) {
                        if (this.annoyance < levels[i]) {
                            level = i;
                            break;
                        }
                    }
                    return Config.Emojis.directClick[level];
                } else {
                    if (this.annoyance > Config.MAD_THRESHOLD) {
                        return Utils.randomChoice(Config.Emojis.mad);
                    } else if (this.annoyance > Config.ANNOYANCE_THRESHOLD) {
                        return Utils.randomChoice(Config.Emojis.annoyed);
                    } else {
                        return Utils.randomChoice(Config.Emojis.commandReceived);
                    }
                }
            }

            updateMood(deltaTime, buffManager) {
                // 1. Cooldown
                if (this.annoyance > 0) {
                    const cooldownPerSecond = (this.annoyance > Config.MAD_THRESHOLD) ? 1.8 : 3.0;
                    this.annoyance = Math.max(0, this.annoyance - (cooldownPerSecond * deltaTime));
                }

                // 2. State Change Detection
                const previousState = this.currentMoodState;
                this.currentMoodState = this.getMoodState(this.annoyance);

                let transitionEmoji = null;
                if (this.currentMoodState !== previousState) {
                    if (previousState === 'mad' && this.currentMoodState === 'annoyed') {
                        transitionEmoji = Config.Emojis.cooldownToAnnoyed[0];
                        // Exit Hangry state when cooling down to annoyed
                        if (this.isHangry) {
                            this.isHangry = false;
                        }
                    } else if (previousState === 'annoyed' && this.currentMoodState === 'normal') {
                         this.isCalm = true;
                         transitionEmoji = Config.Emojis.cooldownToNormal[0];
                    }
                }

                // 3. Appearance and Speed Update
                this.updateAppearance(buffManager);

                return transitionEmoji;
            }

            updateAppearance(buffManager) {
                const buffs = buffManager.getActiveBuffs();
                
                let speed = Config.BASE_SPEED;
                let radius = Config.BASE_RADIUS;

                if (buffs.coffee) {
                    speed *= (1 + 0.3 * buffs.coffee.potency);
                }
                
                // Pizza and Mushroom both increase size (0.3 factor each)
                if (buffs.pizza) {
                    radius *= (1 + 0.3 * buffs.pizza.potency);
                }
                if (buffs.mushroom) {
                    radius *= (1 + 0.3 * buffs.mushroom.potency);
                }

                this.speed = speed;
                this.radius = radius;

                 if (this.annoyance > Config.MAD_THRESHOLD) {
                    this.color = Utils.lerpColor(Config.COLOR_MAD, Config.COLOR_MAD, 0);
                    this.currentSpeedMultiplier = 0.3;
                } else if (this.annoyance > Config.ANNOYANCE_THRESHOLD) {
                    const t = (this.annoyance - Config.ANNOYANCE_THRESHOLD) / (Config.MAD_THRESHOLD - Config.ANNOYANCE_THRESHOLD);
                    this.color = Utils.lerpColor(Config.COLOR_ANNOYED, Config.COLOR_MAD, t);
                    this.currentSpeedMultiplier = Utils.lerp(0.5, 0.3, t);
                } else {
                    const t = this.annoyance / Config.ANNOYANCE_THRESHOLD;
                    this.color = Utils.lerpColor(Config.COLOR_NORMAL, Config.COLOR_ANNOYED, t);
                    this.currentSpeedMultiplier = Utils.lerp(1.0, 0.5, t);
                }
            }

            // --- MOVEMENT & BEHAVIOR LOGIC ---
            // UPDATED: Calculates the interaction point for grass movement.
            updatePosition(deltaTime, bounds, buffManager, worldManager, entityManager) {
                this.previousX = this.x;
                this.previousY = this.y;

                // 1. Determine behavior and direction (Unchanged)
                let movementAllowed = true;
                
                // Check if eating target still exists
                if (this.isEating && this.eatingStartTime === 0 && this.eatingTarget && !entityManager.mushrooms.includes(this.eatingTarget)) {
                    this.eatingTarget = null;
                    this.isEating = false;
                    this.clearTarget();
                    if (Game.instance.uiManager.getCurrentThought() === Config.Emojis.EATING_SEEKING) {
                        Game.instance.uiManager.hideThought();
                    }
                }

                if (this.isEating) {
                    movementAllowed = this.handleEatingBehavior(entityManager, buffManager);
                } 
                
                if (movementAllowed) {
                    if (this.targetX !== null) {
                        this.moveToTarget();
                    } else {
                        this.wander(entityManager, buffManager);
                    }
                } else {
                    // Force stop when chewing
                    this.dx = 0;
                    this.dy = 0;
                }


                // 2. Calculate movement distance (Unchanged)
                const buffs = buffManager.getActiveBuffs();
                let effectiveSpeed = this.speed * this.currentSpeedMultiplier;
                
                if (buffs.kangaroo) {
                    effectiveSpeed = Config.BASE_SPEED * (buffs.kangaroo.isEureka ? 1.3 : 1.0);
                }
                
                const distanceMoved = effectiveSpeed * deltaTime;

                // 3. Apply movement (Unchanged)
                this.x += this.dx * distanceMoved;
                this.y += this.dy * distanceMoved;

                // 4. Handle World Interaction
                if (buffs.kangaroo) {
                    this.handleBounce(distanceMoved, buffManager, worldManager);
                } else {
                    this.verticalOffset = 0; 
                    if (movementAllowed) {
                        // NEW: Calculate the interaction point (South edge of the WanderDot)
                        // This is the point where the grass should react to the movement.
                        const interactionX = this.x;
                        const interactionY = this.y + this.radius;

                         // Pass the interaction point to the world manager
                         worldManager.applyMovementWear(this.previousX, this.previousY, this.x, this.y, buffManager, interactionX, interactionY);
                    }
                }

                // 5. Boundary Collision (Unchanged)
                if (movementAllowed) {
                    this.handleBoundaries(bounds);
                }
            }

            // (handleEatingBehavior, moveToTarget, wander remain unchanged)
            handleEatingBehavior(entityManager, buffManager) {
                const uiManager = Game.instance.uiManager;

                // Stage 1: Moving towards the mushroom (Seeking)
                if (this.targetX !== null) {
                    if (uiManager.getCurrentThought() !== Config.Emojis.EATING_SEEKING) {
                        // Show for a long duration, ensuring it stays up until consumption or interruption
                        uiManager.showThought(Config.Emojis.EATING_SEEKING, 60000); 
                    }
                    return true; // Allow movement
                }

                // Stage 2: Reached the mushroom, start chewing animation
                if (this.eatingStartTime === 0) {
                    this.eatingStartTime = Date.now();
                    // Consume the mushroom from the world
                    if (this.eatingTarget) {
                        entityManager.removeMushroomByObject(this.eatingTarget);
                        this.eatingTarget = null; // Target is now consumed/held
                    }
                    // Show initial thought, will be updated dynamically. 
                    // Set a slightly longer duration as a fallback.
                    uiManager.showThought(Config.Emojis.EATING_CONSUMING, Config.EAT_DURATION + 500);
                }

                const elapsed = Date.now() - this.eatingStartTime;
                const remaining = Config.EAT_DURATION - elapsed;

                // Stage 3: Check if chewing is done
                if (remaining <= 0) {
                    this.isEating = false;
                    this.eatingStartTime = 0;
                    
                    // Apply the buff (using the flat duration)
                    buffManager.addBuffTime('mushroom', Config.MUSHROOM_BUFF_DURATION);

                    // Show satisfied thought bubble (This overrides the eating timer thought)
                    uiManager.showThought(Config.Emojis.EATING_SATISFIED, 2000);

                    return true; // Allow movement again
                }

                // Update thought bubble with timer during chewing
                // Use Math.ceil to show integer countdown (4, 3, 2, 1)
                const remainingSeconds = Math.ceil(remaining / 1000);
                // Use updateThoughtContent to change the content without resetting animation/timers, and use compact font size
                uiManager.updateThoughtContent(`${Config.Emojis.EATING_CONSUMING} ${remainingSeconds}s`, true);

                return false; // Prevent movement while chewing
            }

            moveToTarget() {
                const targetX = this.targetX;
                const targetY = this.targetY;
                
                const vecX = targetX - this.x;
                const vecY = targetY - this.y;
                const distanceToTarget = Math.sqrt(vecX * vecX + vecY * vecY);

                // Stop slightly before the target if eating, otherwise stop at the usual radius
                const stopDistance = this.isEating ? 5 : this.radius;

                if (distanceToTarget < stopDistance) {
                    this.clearTarget();
                    // If not starting the eating process (or if eating is already finished), randomize direction
                    if (!this.isEating || this.eatingStartTime > 0) {
                        this.dx = (Math.random() - 0.5) * 2;
                        this.dy = (Math.random() - 0.5) * 2;
                    }
                } else {
                    this.dx = vecX / distanceToTarget;
                    this.dy = vecY / distanceToTarget;
                }
            }

            wander(entityManager, buffManager) {
                if (this.isEating || this.isHangry) {
                    return;
                }
                
                // Don't seek new mushrooms if the mushroom buff is already active
                if (!buffManager.getActiveBuffs().mushroom) {
                    const nearbyMushroom = entityManager.getNearbyMushroom(this.x, this.y, Config.EAT_DETECTION_RADIUS);
                    if (nearbyMushroom && Math.random() < Config.EAT_MUSHROOM_CHANCE) {
                        this.isEating = true;
                        this.eatingTarget = nearbyMushroom;
                        this.targetX = nearbyMushroom.x;
                        this.targetY = nearbyMushroom.y;
                        return; 
                    }
                }

                // Standard wander behavior
                if (Math.random() < 0.015) {
                    this.dx = (Math.random() - 0.5) * 2;
                    this.dy = (Math.random() - 0.5) * 2;
                }
            }

            handleBounce(distanceMoved, buffManager, worldManager) {
                this.distanceTraveledOnCurrentBounce += distanceMoved;

                let currentBounceHeight = Config.BOUNCE_HEIGHT;
                if (this.currentMoodState === 'mad') {
                    currentBounceHeight /= 2;
                }
                const bounceProgress = Math.min(Math.PI, (this.distanceTraveledOnCurrentBounce / Config.BOUNCE_DISTANCE) * Math.PI);
                this.verticalOffset = Math.sin(bounceProgress) * currentBounceHeight;

                if (this.distanceTraveledOnCurrentBounce >= Config.BOUNCE_DISTANCE) {
                    this.land(buffManager, worldManager);
                }
            }

            land(buffManager, worldManager) {
                // Landing impact uses the center point (x, y) as it's a stomp, not a rolling movement.
                worldManager.applyLandingImpact(this.x, this.y, this.currentMoodState, buffManager);
                
                this.jiggleEndTime = Date.now();
                this.verticalOffset = 0;
                this.distanceTraveledOnCurrentBounce = 0;

                if (buffManager.isKangarooEnding()) {
                    buffManager.deactivateBuff('kangaroo', true);
                }
            }

            handleBoundaries(bounds) {
                let hitBoundary = false;
                if (this.x + this.radius > bounds.width || this.x - this.radius < 0) {
                    this.dx *= -1;
                    this.x = Utils.clamp(this.x, this.radius, bounds.width - this.radius);
                    hitBoundary = true;
                }
                if (this.y + this.radius > bounds.height || this.y - this.radius < 0) {
                    this.dy *= -1;
                    this.y = Utils.clamp(this.y, this.radius, bounds.height - this.radius);
                    hitBoundary = true;
                }

                if (hitBoundary && this.targetX !== null) {
                    this.clearTarget();
                     // If boundary collision interrupted eating seeking, cancel it without penalty
                    if (this.isEating && this.eatingStartTime === 0) {
                        this.isEating = false;
                        this.eatingTarget = null;
                        const uiManager = Game.instance.uiManager;
                        if (uiManager.getCurrentThought() === Config.Emojis.EATING_SEEKING) {
                            uiManager.hideThought();
                        }
                    }
                }
            }

            // --- RENDERING ---
            // (Draw implementation remains unchanged)
            draw(ctx) {
                let scaleFactor = 1;
                const buffs = Game.instance.buffManager.getActiveBuffs();

                if (buffs.kangaroo) {
                    const bounceProgress = Math.min(Math.PI, (this.distanceTraveledOnCurrentBounce / Config.BOUNCE_DISTANCE) * Math.PI);
                    scaleFactor = 1 - Math.sin(bounceProgress) * 0.2;
                }

                const currentRadius = this.radius * scaleFactor;

                // Draw Shadow
                // Show shadow if moving or bouncing, hide only if stationary chewing (eatingStartTime > 0)
                if (!(this.isEating && this.eatingStartTime > 0)) {
                    ctx.beginPath();
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.35)';
                    const shadowY = this.y + this.radius; 
                    const shadowScale = 1 - (this.verticalOffset / (Config.BOUNCE_HEIGHT * 3));
                    const shadowRadiusX = currentRadius * shadowScale;
                    const shadowRadiusY = (currentRadius / 3) * shadowScale;
                    ctx.ellipse(this.x, shadowY, shadowRadiusX, shadowRadiusY, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.closePath();
                }

                // Draw Circle
                ctx.save();
                
                let drawY = this.y - this.verticalOffset;
                
                ctx.translate(this.x, drawY);

                // Landing Jiggle Effect
                const jiggleDuration = 300;
                const timeSinceJiggle = Date.now() - this.jiggleEndTime;
                if (timeSinceJiggle < jiggleDuration) {
                    const jiggleProgress = timeSinceJiggle / jiggleDuration;
                    let jiggleAmountMultiplier = (this.currentMoodState === 'mad') ? 0.4 : 0.2;
                    const jiggleAmount = Math.sin(jiggleProgress * Math.PI * 2) * (1 - jiggleProgress) * jiggleAmountMultiplier;
                    ctx.scale(1 + jiggleAmount, 1 - jiggleAmount);
                }

                // Draw Hangry Glow
                if (this.isHangry) {
                    ctx.shadowBlur = 25;
                    ctx.shadowColor = Config.COLOR_HANGRY_GLOW;
                }

                ctx.beginPath();
                ctx.arc(0, 0, currentRadius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.closePath();
                
                // Draw held item (Mushroom) during chewing phase
                if (this.isEating && this.eatingStartTime > 0) {
                    const elapsed = Date.now() - this.eatingStartTime;
                    // Calculate wiggle for the mushroom (up and down motion)
                    const mushroomWiggleY = Math.sin(elapsed / 100) * 5;

                    ctx.shadowBlur = 0; // Don't glow the mushroom itself
                    ctx.font = `${this.radius * 0.8}px monospace`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';

                    // Draw offset to the side (e.g., right side, 70% of radius) and near the "mouth" level (20% down)
                    const mushroomX = this.radius * 0.7; 
                    const mushroomY = this.radius * 0.2 + mushroomWiggleY;

                    ctx.fillText('üçÑ', mushroomX, mushroomY); 
                }

                ctx.restore();
            }
        }

        // ====================================================================
        // 4. BUFF AND ITEM MANAGERS
        // ====================================================================

        // (BuffManager and ItemManager implementations remain unchanged)
        class BuffManager {
            constructor(entityManager) {
                this.entityManager = entityManager;
                this.buffs = {};
                this.initializeDefinitions();
            }

            initializeDefinitions() {
                Object.entries(Config.Items).forEach(([name, data]) => {
                    if (data.type === 'buff') {
                        this.buffs[name] = {
                            endTime: 0,
                            blinkTimer: null,
                            duration: data.duration || 0,
                            isEureka: false,
                            isEnding: false,
                            emoji: data.emoji,
                            indicator: null,
                            hideTimer: data.hideTimer || false
                        };
                    }
                });
            }

            initializeUI() {
                const container = document.getElementById('buff-container');
                const sortedKeys = Object.keys(this.buffs).sort((a, b) => a.localeCompare(b));

                sortedKeys.forEach(name => {
                    const buff = this.buffs[name];
                    const indicator = document.createElement('div');
                    indicator.className = 'buff-indicator';
                    indicator.id = `buff-indicator-${name}`;
                    
                    const timerHTML = buff.hideTimer ? '' : '<div class="buff-timer"></div>';

                    indicator.innerHTML = `
                        <span class="buff-icon">${buff.emoji}</span>
                        ${timerHTML}
                    `;
                    container.appendChild(indicator);
                    buff.indicator = indicator;
                });
            }

            update() {
                const currentTime = Date.now();
                Object.entries(this.buffs).forEach(([name, buff]) => {
                    if (buff.endTime > currentTime) {
                        this.updateTimerDisplay(buff, currentTime);
                    } else if (buff.indicator && buff.indicator.style.display === 'flex' && !buff.isEnding) {
                        this.deactivateBuff(name);
                    }
                });
            }

            updateTimerDisplay(buff, currentTime) {
                if (buff.hideTimer || !buff.indicator) return;

                const remainingSeconds = Math.ceil((buff.endTime - currentTime) / 1000);
                const minutes = Math.floor(remainingSeconds / 60);
                const seconds = remainingSeconds % 60;
                const timerText = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                
                const timerEl = buff.indicator.querySelector('.buff-timer');
                if (timerEl) {
                    timerEl.textContent = timerText;
                }
            }

            addBuffTime(name, duration) {
                const buff = this.buffs[name];
                if (!buff) return;

                const baseTime = Math.max(Date.now(), buff.endTime);
                buff.endTime = baseTime + duration;
                buff.isEnding = false;

                this.setupBuffIndicator(buff);
                this.setupBlinkTimer(buff);
            }

            setupBuffIndicator(buff) {
                if (!buff.indicator) return;
                buff.indicator.style.display = 'flex';
                buff.indicator.classList.remove('blinking', 'blip-out');
                if (buff.isEureka) {
                    buff.indicator.classList.add('eureka-state');
                }
            }

            setupBlinkTimer(buff) {
                clearTimeout(buff.blinkTimer);
                const remainingTime = buff.endTime - Date.now();
                const BLINK_THRESHOLD = 3000;

                if (remainingTime > BLINK_THRESHOLD) {
                    buff.blinkTimer = setTimeout(() => {
                        if (buff.endTime > Date.now() && buff.indicator) {
                            buff.indicator.classList.add('blinking');
                        }
                    }, remainingTime - BLINK_THRESHOLD);
                } else if (remainingTime > 0 && buff.indicator) {
                    buff.indicator.classList.add('blinking');
                }
            }

            deactivateBuff(name, force = false) {
                const buff = this.buffs[name];
                
                if ((buff.endTime === 0 && !buff.isEnding)) return;

                if (name === 'kangaroo' && !force) {
                    if (Game.instance.wanderDot.verticalOffset > 0.1) {
                        buff.isEnding = true;
                        buff.endTime = 0;
                        return;
                    }
                }

                if (name === 'mushroom') {
                    const dot = Game.instance.wanderDot;
                    this.entityManager.addEntity('seed', dot.x, dot.y);
                }

                buff.endTime = 0;
                buff.isEureka = false;
                buff.isEnding = false;
                clearTimeout(buff.blinkTimer);

                if (buff.indicator) {
                    buff.indicator.classList.add('blip-out');
                    buff.indicator.addEventListener('animationend', () => {
                        if (buff.indicator) {
                            buff.indicator.style.display = 'none';
                            buff.indicator.className = 'buff-indicator';
                        }
                    }, { once: true });
                }
            }

            getActiveBuffs() {
                const currentTime = Date.now();
                const active = {};
                Object.entries(this.buffs).forEach(([name, buff]) => {
                    if (buff.endTime > currentTime || buff.isEnding) {
                        active[name] = {
                            isEureka: buff.isEureka,
                            potency: buff.isEureka ? 2.0 : 1.0
                        };
                    }
                });
                return active;
            }

            isKangarooEnding() {
                return this.buffs.kangaroo?.isEnding;
            }

            applyWatchExtension() {
                Object.keys(this.buffs).forEach(name => {
                    if (name !== 'mushroom' && this.buffs[name].endTime > Date.now()) {
                        this.addBuffTime(name, Config.WATCH_TIME_EXTENSION);
                    }
                });
            }

            applyEureka() {
                Object.entries(this.buffs).forEach(([name, buff]) => {
                    if (name !== 'mushroom' && buff.endTime > Date.now()) {
                        buff.isEureka = true;
                        if (buff.indicator) {
                            buff.indicator.classList.add('eureka-state');
                        }
                    }
                });
            }
        }

        class ItemManager {
            constructor(buffManager) {
                this.buffManager = buffManager;
                this.items = {};
                this.initializeDefinitions();
            }

            initializeDefinitions() {
                Object.entries(Config.Items).forEach(([name, data]) => {
                    if (name !== 'mushroom') {
                        this.items[name] = {
                            count: 0,
                            button: null,
                            emoji: data.emoji,
                            type: data.type
                        };
                    }
                });
            }

            initializeUI() {
                const itemBar = document.getElementById('item-bar');
                itemBar.addEventListener('click', (event) => {
                    const button = event.target.closest('.item-button');
                    if (button && button.dataset.itemName) {
                        this.useItem(button.dataset.itemName);
                    }
                });

                Object.entries(this.items).forEach(([name, item]) => {
                    const button = document.createElement('button');
                    button.className = 'item-button';
                    button.dataset.itemName = name;
                    itemBar.appendChild(button);
                    item.button = button;
                });
                this.updateItemBar();
            }

            addItem(emoji) {
                const itemName = Object.keys(this.items).find(name => this.items[name].emoji === emoji);
                if (itemName) {
                    this.items[itemName].count++;
                    this.updateItemBar();
                    return true;
                }
                return false;
            }

            useItem(name) {
                const item = this.items[name];
                if (item.count > 0) {
                    item.count--;
                    this.updateItemBar();
                    this.animateButton(item.button);

                    if (item.type === 'buff') {
                        this.buffManager.addBuffTime(name, this.buffManager.buffs[name].duration);
                    } else if (name === 'watch') {
                        this.buffManager.applyWatchExtension();
                    } else if (name === 'lightbulb') {
                        this.buffManager.applyEureka();
                    }
                }
            }

            animateButton(button) {
                if (!button) return;
                button.classList.add('clicked');
                button.addEventListener('animationend', () => button.classList.remove('clicked'), { once: true });
            }

            updateItemBar() {
                const itemBar = document.getElementById('item-bar');
                let totalItems = 0;
                Object.values(this.items).forEach(item => {
                    // Ensure item.button exists before trying to access it.
                    if (item.button) {
                        if (item.count > 0) {
                            item.button.classList.add('visible');
                            item.button.textContent = `${item.emoji}x${item.count}`;
                            totalItems++;
                        } else {
                            item.button.classList.remove('visible');
                        }
                    }
                });

                if (itemBar) {
                   itemBar.classList.toggle('visible', totalItems > 0);
                }
            }
        }
        
        // ====================================================================
        // 5. PARTICLE SYSTEM & UFO
        // ====================================================================

        // (ParticleSystem and UFO implementations remain unchanged)
        class ParticleSystem {
            constructor(ctx) {
                this.ctx = ctx;
                this.particles = [];
            }

            spawnLandingParticles(x, y) {
                const count = 10;
                for(let i=0; i < count; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.random() * 50 + 20;
                    this.particles.push({
                        type: 'pebble', x: x, y: y,
                        dx: Math.cos(angle) * speed, dy: Math.sin(angle) * speed,
                        life: 1, maxLife: 1
                    });
                }
            }

            spawnUFOMist(x, y) {
                if (Math.random() < 0.5) return; 

                this.particles.push({
                    type: 'mist',
                    x: x + (Math.random() - 0.5) * 80,
                    y: y + (Math.random() - 0.5) * 40,
                    dx: (Math.random() - 0.5) * 20,
                    dy: (Math.random() - 0.5) * 10,
                    life: 2, maxLife: 2
                });
            }

            updateAndDraw(deltaTime) {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const p = this.particles[i];
                    p.x += p.dx * deltaTime;
                    p.y += p.dy * deltaTime;
                    p.life -= deltaTime;

                    if(p.life <= 0) {
                        this.particles.splice(i, 1);
                    } else {
                        this.drawParticle(p);
                    }
                }
            }

            drawParticle(p) {
                const opacity = p.life / p.maxLife;
                this.ctx.beginPath();
                if(p.type === 'pebble') {
                    this.ctx.fillStyle = `rgba(30, 30, 30, ${0.5 * opacity})`;
                    this.ctx.arc(p.x, p.y, 2, 0, Math.PI * 2);
                } else if (p.type === 'mist') {
                    this.ctx.fillStyle = `rgba(200, 220, 255, ${0.2 * opacity})`;
                    this.ctx.arc(p.x, p.y, 10, 0, Math.PI * 2);
                }
                this.ctx.fill();
            }
        }

        class UFO {
            constructor(ctx, bounds) {
                this.ctx = ctx;
                this.bounds = bounds;
                this.active = false;
                this.x = 0;
                this.y = 0;
                this.speed = 300;
                this.direction = 1;
            }

            activate() {
                if (this.active) return;
                this.active = true;
                this.y = Math.random() * (this.bounds.height * 0.6) + (this.bounds.height * 0.1);
                
                if(Math.random() < 0.5) {
                    this.direction = 1;
                    this.x = -50;
                } else {
                    this.direction = -1;
                    this.x = this.bounds.width + 50;
                }
            }

            update(deltaTime, particleManager, worldManager) {
                if (!this.active) return;

                this.x += this.speed * this.direction * deltaTime;
                
                particleManager.spawnUFOMist(this.x, this.y);
                
                if(Math.random() < 0.1) {
                    // This now triggers grass redraw via the updated alterGround function if terrain changes.
                    worldManager.alterGround(this.x + (Math.random() - 0.5) * 50, this.y + (Math.random() - 0.5) * 50);
                }

                if(this.x < -100 || this.x > this.bounds.width + 100) {
                    this.active = false;
                }
            }

            draw() {
                if (!this.active) return;
                this.ctx.font = '4rem monospace';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText('üõ∏', this.x, this.y);
                this.ctx.textAlign = 'start';
                this.ctx.textBaseline = 'alphabetic';
            }
        }

        // ====================================================================
        // 6. UI MANAGER (Thoughts, Timers, Interaction)
        // ====================================================================

        // (UIManager implementation remains unchanged)
        class UIManager {
            constructor(wanderDot) {
                this.wanderDot = wanderDot;
                this.thoughtBubble = document.getElementById('thought-bubble');
                this.worldTimerElement = document.getElementById('world-timer');
                this.timerContainer = document.getElementById('timer-container');
                this.timerIcon = document.getElementById('timer-icon');
                
                this.idleThoughtTimer = null;
                this.madThoughtTimer = null;
                this.thoughtTimeout = null;
                this.fadeTimeout = null;
                this.idleEmojiHistory = [];

                this.bubbleAngle = -Math.PI / 2;
                this.targetBubbleAngle = -Math.PI / 2;
                this.riseStartTime = 0;
                this.bounceEndTime = 0;
                
                this.isMouseOverBubble = false;
                this.thoughtTimeoutStartTime = 0;
                this.thoughtTimeoutDuration = 0;
                this.thoughtTimeoutRemaining = 0;
                this.mousePos = { x: 0, y: 0 };

                this.setupEventListeners();
            }

             setupEventListeners() {
                window.addEventListener('mousemove', (event) => {
                    this.mousePos.x = event.clientX;
                    this.mousePos.y = event.clientY;
                });

                this.thoughtBubble.addEventListener('click', (event) => {
                    event.stopPropagation();
                    this.handleThoughtClick();
                });

                this.thoughtBubble.addEventListener('mouseenter', () => this.handleBubbleEnter());
                this.thoughtBubble.addEventListener('mouseleave', () => this.handleBubbleLeave());

                // Click listener for Timer toggle
                // Using 'pointerdown' for responsiveness on both desktop and mobile
                this.timerIcon.addEventListener('pointerdown', (event) => {
                    event.stopPropagation();
                    this.toggleTimerPin();
                });
            }

            toggleTimerPin() {
                this.timerContainer.classList.toggle('active');
            }

            getCurrentThought() {
                if (this.thoughtBubble.style.display === 'block') {
                    const span = this.thoughtBubble.querySelector('span');
                    // Return the base emoji if it's a timer thought (e.g., "ü§§ 3s" -> "ü§§")
                    if (span) {
                        const text = span.textContent;
                        // Use Unicode property escapes to robustly match the first emoji character
                        const match = text.match(/^(\p{Emoji})/u);
                        return match ? match[1] : text;
                    }
                }
                return null;
            }

            updateThoughtContent(content, isCompact = false) {
                if (this.thoughtBubble.style.display === 'block') {
                    const span = this.thoughtBubble.querySelector('span');
                    if (span) {
                       if (span.textContent !== content) {
                            span.textContent = content;
                       }
                       // Adjust font size if needed for compact display (like timers)
                       const targetFontSize = isCompact ? '1.5rem' : '2.5rem';
                       if (this.thoughtBubble.style.fontSize !== targetFontSize) {
                           this.thoughtBubble.style.fontSize = targetFontSize;
                       }
                    }
                }
            }

            hideThought() {
                if (!this.isMouseOverBubble) {
                    this.thoughtBubble.style.opacity = 0;
                    this.fadeTimeout = setTimeout(() => {
                        this.thoughtBubble.style.display = 'none';
                    }, 300);
                }
            }
             getNextIdleEmoji() {
                const candidateEmojis = Config.Emojis.idle.filter(e => !this.idleEmojiHistory.includes(e));
                const emojiPool = candidateEmojis.length > 0 ? candidateEmojis : Config.Emojis.idle;
                const nextEmoji = Utils.randomChoice(emojiPool);

                this.idleEmojiHistory.push(nextEmoji);
                if (this.idleEmojiHistory.length > 3) {
                    this.idleEmojiHistory.shift();
                }
                return nextEmoji;
            }

            startMadTimer() {
                this.stopMadTimer();
                this.madThoughtTimer = setInterval(() => {
                    // Don't show mad thoughts if Hangry (Hangry overrides standard mad behavior)
                    if (this.wanderDot.currentMoodState === 'mad' && !this.wanderDot.isHangry) {
                        this.showThought(Utils.randomChoice(Config.Emojis.madZone));
                    } else if (this.wanderDot.currentMoodState !== 'mad') {
                        this.stopMadTimer();
                    }
                }, 3000);
            }

            stopMadTimer() {
                clearInterval(this.madThoughtTimer);
                this.madThoughtTimer = null;
            }

            handleThoughtClick() {
                // Get the current thought emoji (handles timer text stripping)
                const emoji = this.getCurrentThought();
                
                const collected = Game.instance.itemManager.addItem(emoji);
                
                if (!collected) {
                    if (emoji === 'üëΩ') {
                        Game.instance.ufo.activate();
                    }
                }

                clearTimeout(this.thoughtTimeout);
                clearTimeout(this.fadeTimeout);
                this.thoughtBubble.style.display = 'none';
                this.isMouseOverBubble = false;
            }

            handleBubbleEnter() {
                this.isMouseOverBubble = true;
                this.thoughtTimeoutRemaining = this.thoughtTimeoutDuration - (Date.now() - this.thoughtTimeoutStartTime);
                clearTimeout(this.thoughtTimeout);
                clearTimeout(this.fadeTimeout);
                this.thoughtBubble.style.opacity = 1;
            }

            handleBubbleLeave() {
                this.isMouseOverBubble = false;
                this.thoughtTimeout = setTimeout(() => this.hideThought(), Math.max(500, this.thoughtTimeoutRemaining));
            }

            update(worldCreationTime) {
                this.updateTimer(worldCreationTime);
                if (this.thoughtBubble.style.display === 'block') {
                    this.updateBubblePosition();
                }
            }

            updateTimer(worldCreationTime) {
                const elapsedTime = Date.now() - worldCreationTime;
                const elapsedSeconds = Math.floor(elapsedTime / 1000);
                const minutes = Math.floor(elapsedSeconds / 60);
                const seconds = elapsedSeconds % 60;
                
                let timerText = `Your WanderDot's world has existed for `;
                if (minutes > 0) {
                    timerText += `${minutes} minute${minutes !== 1 ? 's' : ''} and `;
                }
                timerText += `${seconds} second${seconds !== 1 ? 's' : ''}.`;
                this.worldTimerElement.textContent = timerText;
            }

            showThought(emoji, duration = 2000) {
                if (!emoji) return;

                clearTimeout(this.thoughtTimeout);
                clearTimeout(this.fadeTimeout);

                this.prepareBubbleAnimation();

                this.thoughtBubble.innerHTML = `<span>${emoji}</span>`;
                this.thoughtBubble.style.fontSize = '2.5rem'; // Ensure font size is reset to default
                this.thoughtBubble.style.opacity = 1;
                this.thoughtBubble.style.display = 'block';

                this.thoughtTimeoutStartTime = Date.now();
                this.thoughtTimeoutDuration = duration;
                this.thoughtTimeout = setTimeout(() => this.hideThought(), duration);
            }

            prepareBubbleAnimation() {
                if (this.thoughtBubble.style.display === 'block') {
                    this.bounceEndTime = Date.now() + 300;
                } else {
                    const initialOrbitRadius = this.wanderDot.radius;
                    const initialX = this.wanderDot.x + Math.cos(this.bubbleAngle) * initialOrbitRadius;
                    const initialY = this.wanderDot.y + Math.sin(this.bubbleAngle) * initialOrbitRadius;
                    this.thoughtBubble.style.left = `${initialX}px`;
                    this.thoughtBubble.style.top = `${initialY}px`;
                }

                this.thoughtBubble.classList.remove('is-rising');
                void this.thoughtBubble.offsetWidth; 
                this.thoughtBubble.classList.add('is-rising');
                this.riseStartTime = Date.now();
            }

            // --- IDLE THOUGHT SCHEDULING (Unchanged) ---
            scheduleNextIdleThought(delay = 7000) {
                const IDLE_THOUGHT_DURATION = 4000;
                const BREAK_DURATION = 7000;
                
                clearTimeout(this.idleThoughtTimer);
                this.idleThoughtTimer = setTimeout(() => {
                    // Only show if idle (no target AND not eating) AND not annoyed AND not Hangry
                    if (this.wanderDot.targetX === null && 
                        !this.wanderDot.isEating && 
                        !this.wanderDot.isHangry &&
                        this.wanderDot.annoyance < Config.WARNING_ANNOYANCE_THRESHOLD) {
                        
                        const nextEmoji = this.getNextIdleEmoji();
                        this.showThought(nextEmoji, IDLE_THOUGHT_DURATION);
                        
                        this.scheduleNextIdleThought(IDLE_THOUGHT_DURATION + 300 + BREAK_DURATION);
                    } else {
                        // If busy, eating, or annoyed/hangry, check again later
                        this.scheduleNextIdleThought(BREAK_DURATION);
                    }
                }, delay);
            }

            // (updateBubblePosition, findBestBubbleAngle, calculateBubbleAnimations remain unchanged)
            updateBubblePosition() {
                const bubbleWidth = this.thoughtBubble.offsetWidth;
                const bubbleHeight = this.thoughtBubble.offsetHeight;
                const finalOrbitRadius = this.wanderDot.radius + bubbleHeight / 2 + 5;

                this.targetBubbleAngle = this.findBestBubbleAngle(finalOrbitRadius, bubbleWidth, bubbleHeight);
                this.bubbleAngle = Utils.lerp(this.bubbleAngle, this.targetBubbleAngle, 0.1);

                const { radius, verticalBob } = this.calculateBubbleAnimations(finalOrbitRadius);

                let bubbleTargetX = this.wanderDot.x + Math.cos(this.bubbleAngle) * radius;
                let bubbleTargetY = this.wanderDot.y - this.wanderDot.verticalOffset + Math.sin(this.bubbleAngle) * radius + verticalBob;

                if(this.isMouseOverBubble) {
                    const currentX = parseFloat(this.thoughtBubble.style.left) || bubbleTargetX;
                    const currentY = parseFloat(this.thoughtBubble.style.top) || bubbleTargetY;
                    bubbleTargetX = Utils.lerp(currentX, this.mousePos.x, 0.2);
                    bubbleTargetY = Utils.lerp(currentY, this.mousePos.y, 0.2);
                }

                this.thoughtBubble.style.left = `${bubbleTargetX}px`;
                this.thoughtBubble.style.top = `${bubbleTargetY}px`;
            }

            findBestBubbleAngle(radius, width, height) {
                const SAFE_MARGIN = 10;
                // Use Game.instance.bounds for accurate dimensions, especially after resize
                const bounds = Game.instance.bounds;
                const startAngle = -Math.PI / 2;

                for (let offset = 0; offset < Math.PI; offset += 0.1) {
                    for (const sign of [1, -1]) {
                        const angle = startAngle + offset * sign;
                        const testX = this.wanderDot.x + Math.cos(angle) * radius;
                        const testY = this.wanderDot.y + Math.sin(angle) * radius;

                        if (testX - width / 2 > SAFE_MARGIN && testX + width / 2 < bounds.width - SAFE_MARGIN &&
                            testY - height / 2 > SAFE_MARGIN && testY + height / 2 < bounds.height - SAFE_MARGIN) {
                            return angle;
                        }
                    }
                }
                return this.targetBubbleAngle;
            }

            calculateBubbleAnimations(finalOrbitRadius) {
                let radius = finalOrbitRadius;
                let verticalBob = 0;
                const animTime = Date.now();

                if (this.riseStartTime > 0 && animTime - this.riseStartTime < 400) {
                    const riseProgress = (animTime - this.riseStartTime) / 400;
                    radius = Utils.lerp(this.wanderDot.radius, finalOrbitRadius, riseProgress);
                } else {
                    this.riseStartTime = 0;
                    if (this.bounceEndTime > 0 && animTime < this.bounceEndTime) {
                        const bounceProgress = (animTime - (this.bounceEndTime - 300)) / 300;
                        verticalBob = Math.sin(bounceProgress * Math.PI) * -15;
                    } else {
                        this.bounceEndTime = 0;
                        verticalBob = Math.sin(animTime / 400) * -3;
                    }
                }
                return { radius, verticalBob };
            }
        }

        // ====================================================================
        // 7. GAME (Main Loop, Initialization)
        // ====================================================================

        // UPDATED: Adapted for single-canvas rendering and depth sorting.
        class Game {
            static instance = null;

            constructor() {
                if (Game.instance) return Game.instance;
                Game.instance = this;

                this.assetManager = new AssetManager();
                this.isInitialized = false; // Flag to ensure initialization happens after loading

                this.initializeCanvases();
                this.bounds = { width: this.mainCanvas.width, height: this.mainCanvas.height };

                this.worldCreationTime = Date.now();
                this.lastFrameTime = 0;
                this.lastClickTime = 0;

                // Load assets first, then proceed with initialization
                this.assetManager.loadAll(() => this.initializeAfterLoading());
            }

            // UPDATED: Removed initialization of entityCanvas and grassCanvas.
            initializeCanvases() {
                this.worldContainer = document.getElementById('world-container');
                
                this.pathCanvas = document.getElementById('pathCanvas');
                this.pathCtx = this.pathCanvas.getContext('2d');
                
                // Main Canvas handles everything now
                this.mainCanvas = document.getElementById('mainCanvas');
                this.ctx = this.mainCanvas.getContext('2d');

                this.resizeCanvases();
            }

            // UPDATED: Simplified resize.
            resizeCanvases() {
                const width = window.innerWidth;
                const height = window.innerHeight;

                this.worldContainer.style.width = `${width}px`;
                this.worldContainer.style.height = `${height}px`;

                this.mainCanvas.width = this.pathCanvas.width = width;
                this.mainCanvas.height = this.pathCanvas.height = height;
            }

            // (initializeAfterLoading remains unchanged)
            initializeAfterLoading() {
                this.initializeGameObjects();
                
                // Initialize UIs
                this.buffManager.initializeUI();
                this.itemManager.initializeUI();

                // Persistence (loadGame) removed.

                this.finalizeInitialization();
                this.setupEventListeners();
                this.isInitialized = true;
                this.start(); // Start the animation loop
            }

            // UPDATED: Pass the main context (this.ctx) to managers.
            initializeGameObjects() {
                // Pass main ctx instead of entityCtx
                this.entityManager = new EntityManager(this.ctx);
                // Pass pathCtx and mainCtx
                this.worldManager = new WorldManager(this.bounds.width, this.bounds.height, this.pathCtx, this.ctx, this.entityManager, this.assetManager);
                this.wanderDot = new WanderDot(this.bounds.width / 2, this.bounds.height / 2);
                this.uiManager = new UIManager(this.wanderDot);
                this.buffManager = new BuffManager(this.entityManager);
                this.itemManager = new ItemManager(this.buffManager);
                
                this.particleManager = new ParticleSystem(this.ctx);
                this.ufo = new UFO(this.ctx, this.bounds);
            }

            // (finalizeInitialization remains unchanged)
            finalizeInitialization() {
                // Generate the world fresh
                this.worldManager.generateGrassField(); 
                this.worldManager.redrawWorld();

                this.wanderDot.x = Utils.clamp(this.wanderDot.x, Config.BASE_RADIUS, this.bounds.width - Config.BASE_RADIUS);
                this.wanderDot.y = Utils.clamp(this.wanderDot.y, Config.BASE_RADIUS, this.bounds.height - Config.BASE_RADIUS);
                this.wanderDot.previousX = this.wanderDot.x;
                this.wanderDot.previousY = this.wanderDot.y;
            }

            // --- EVENTS ---
            setupEventListeners() {
                window.addEventListener('resize', () => this.handleResize());
                // Use pointerdown for better responsiveness on all devices
                // This works now because mainCanvas is the top layer.
                this.mainCanvas.addEventListener('pointerdown', (event) => this.handleClick(event));
            }

            handleResize() {
                 if (!this.isInitialized) return;

                // Resize canvases and the world container based on new window size
                this.resizeCanvases();
                
                // Update bounds based on the new canvas size
                this.bounds.width = this.mainCanvas.width;
                this.bounds.height = this.mainCanvas.height;

                // Notify managers to adapt to the new size
                this.worldManager.handleResize(this.bounds.width, this.bounds.height);
            }

            // (handleClick, animate, updateTimeBasedSystems, update remain unchanged)
            // ... [Methods omitted for brevity, they are identical to the previous turn] ...

            // UPDATED: Implements the depth sorting (Z-sorting) algorithm.
            draw(deltaTime) {
                // 1. Clear the main canvas (Path canvas is handled separately by WorldManager during updates)
                this.ctx.clearRect(0, 0, this.bounds.width, this.bounds.height);

                // 2. Collect all sortable entities
                let drawList = [];

                // Add Grass Blades
                // We wrap the blade data and create a closure function (draw) that calls the WorldManager's drawBlade helper.
                drawList.push(...this.worldManager.grassBlades.map(b => ({
                    y: b.y, // Sort by the base of the blade
                    draw: (ctx) => this.worldManager.drawBlade(ctx, b) 
                })));

                // Add Entities (Pebbles, Mushrooms, Dynamic Entities)
                const entities = this.entityManager.getAllEntities();
                drawList.push(...entities.map(e => ({
                    y: e.y, // Sort by the entity's Y position
                    draw: (ctx) => this.entityManager.drawEntity(ctx, e)
                })));

                // Add WanderDot
                drawList.push({
                    // Sort by the south edge (base) of the WanderDot, accounting for the shadow position
                    y: this.wanderDot.y + this.wanderDot.radius, 
                    draw: (ctx) => this.wanderDot.draw(ctx)
                });

                // Add UFO (if active)
                if (this.ufo.active) {
                    drawList.push({
                        y: this.ufo.y, // UFO center is fine for sorting
                        draw: (ctx) => this.ufo.draw()
                    });
                }

                // 3. Sort the list (Back to Front: Ascending Y order)
                drawList.sort((a, b) => a.y - b.y);

                // 4. Draw everything in the sorted order
                for (const item of drawList) {
                    item.draw(this.ctx);
                }

                // 5. Draw particles (Drawn last, on top of everything else)
                this.particleManager.updateAndDraw(deltaTime);
            }

            start() {
                // Start is called after assets load in initializeAfterLoading
                this.uiManager.scheduleNextIdleThought();
                requestAnimationFrame((time) => this.animate(time));
            }
        }

        // ====================================================================
        // 8. STARTUP
        // ====================================================================
        document.addEventListener('DOMContentLoaded', () => {
            // Check for Brown Mushroom emoji support before initializing the game
            if (!Utils.checkEmojiSupport(Config.Emojis.BROWN_MUSHROOM)) {
                // If the OS cannot display the brown mushroom (üçÑ‚Äçüü´) as one emoji, fallback to Wilted Flower (ü•Ä)
                Config.Emojis.BROWN_MUSHROOM = 'ü•Ä';
            }

            // Initialization starts here. The Game constructor handles asset loading before starting the simulation.
            const game = new Game();
            // game.start() is called internally after assets load.
        });

    </script>
</body>
</html>
