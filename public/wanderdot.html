<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>WanderDot's World</title>
    <style>
        /* --- 1. CSS VARIABLES & SETUP --- */
        :root {
            --color-field-bg: #013220;
            --color-ui-bg: rgba(0, 0, 0, 0.4);
            --color-ui-border: #ccc;
            --color-text: white;
            --color-eureka-glow: gold;
            --color-thought-bg: rgba(25, 25, 112, 0.5);
            --font-main: monospace;
        }

        /* Strict overflow hidden to prevent mobile scrolling/OOB viewing */
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            width: 100%;
            height: 100%;
        }

        body {
            background-color: var(--color-field-bg);
            font-family: var(--font-main);
            cursor: default;
            user-select: none; 
        }

        /* --- 2. WORLD CONTAINERS & LAYERS --- */
        #world-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }

        #grass-field {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            overflow: hidden;
            pointer-events: none;
            z-index: 0;
        }

        .grass-tuft {
            position: absolute;
            font-weight: bold;
        }

        canvas {
            display: block;
            position: absolute;
            top: 0; left: 0;
        }

        #pathCanvas { z-index: 1; }
        #entityCanvas { z-index: 2; } 
        #mainCanvas { z-index: 3; }

        /* --- 3. UI ELEMENTS --- */

        /* Thought Bubble (Unchanged) */
        #thought-bubble {
            position: absolute;
            display: none;
            font-size: 2.5rem;
            padding: 0.6rem;
            background-color: var(--color-thought-bg);
            border: 2px solid var(--color-ui-border);
            border-radius: 50%;
            backdrop-filter: blur(3px);
            transition: opacity 0.3s ease-in-out, left 0.1s linear, top 0.1s linear; 
            z-index: 4;
            cursor: pointer;
            transform: translate(-50%, -50%); 
        }

        .is-rising {
            animation: rise-up 0.4s cubic-bezier(0.18, 0.89, 0.32, 1.28);
        }

        #thought-bubble > span {
            pointer-events: none;
        }

        /* Buff Container */
        #buff-container {
            position: absolute;
            top: 20px; right: 20px;
            display: flex;
            flex-direction: row-reverse;
            gap: 15px;
            z-index: 5;
        }

        .buff-indicator {
            display: none;
            flex-direction: column;
            align-items: center;
            text-shadow: 0 0 5px black;
        }
        
        .buff-icon {
            font-size: 1.5rem;
            transition: box-shadow 0.3s ease-in-out;
        }

        .eureka-state .buff-icon {
            border-radius: 5px;
            box-shadow: 0 0 8px 3px var(--color-eureka-glow);
        }

        .buff-timer {
            font-size: 0.8rem;
            color: var(--color-text);
            margin-top: 2px;
        }
        
        /* Item Bar (Unchanged) */
        #item-bar {
            position: absolute;
            bottom: -100px;
            left: 50%;
            transform: translateX(-50%);
            background-color: var(--color-ui-bg);
            border: 2px solid var(--color-ui-border);
            border-bottom: none;
            border-radius: 10px 10px 0 0;
            padding: 5px;
            display: flex;
            gap: 5px;
            z-index: 5;
            transition: bottom 0.4s ease-in-out;
        }

        #item-bar.visible {
            bottom: 0;
        }

        .item-button {
            background-color: #333;
            border: 2px solid #888;
            border-radius: 5px;
            color: var(--color-text);
            font-size: 1rem;
            width: 60px; height: 60px;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .item-button.visible {
            display: flex;
        }

        .item-button.clicked {
            animation: use-item-anim 0.2s ease-out;
        }
        
        /* World Timer (Top Left) - Updated for Rollout Animation */
        #timer-container {
            position: absolute;
            top: 10px; left: 10px;
            z-index: 5;
            display: flex;
            align-items: center;
        }

        #timer-icon {
            font-size: 1.2rem;
            background-color: var(--color-ui-bg);
            border: 2px solid rgba(204, 204, 204, 0.5);
            padding: 5px;
            border-radius: 4px;
            /* Changed cursor to pointer as it's now clickable */
            cursor: pointer; 
            display: flex;
            align-items: center;
            justify-content: center;
            width: 1.8rem; height: 1.8rem;
        }

        #world-timer {
            margin-left: 10px;
            font-size: 0.9rem;
            color: var(--color-text);
            text-shadow: 0 0 5px black;
            background-color: rgba(128, 128, 128, 0.3);
            border-radius: 5px;
            white-space: nowrap;
            pointer-events: none;
            
            /* Rollout transition setup */
            opacity: 0;
            max-width: 0;
            padding: 8px 0px; /* Vertical padding only */
            overflow: hidden;
            transition: opacity 0.3s ease-in-out, max-width 0.5s ease-in-out, padding 0.5s ease-in-out;
        }

        /* Active states for rollout (Hover or Clicked) */
        #timer-container:hover #world-timer,
        #timer-container.active #world-timer {
            opacity: 1;
            max-width: 600px; /* Ample space for the text */
            padding: 8px 12px; /* Restore horizontal padding */
        }


        /* --- 4. KEYFRAME ANIMATIONS (Unchanged) --- */
        @keyframes rise-up {
            from { opacity: 0; transform: translate(-50%, -50%) scale(0.4); }
            to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }

        @keyframes blink {
            50% { opacity: 0.2; }
        }
        .blinking {
            animation: blink 0.5s infinite;
        }

        @keyframes blip-out {
            to { transform: scale(0); opacity: 0; }
        }
        .blip-out {
            animation: blip-out 0.3s forwards;
        }

        @keyframes use-item-anim {
            50% { transform: scale(0.85); }
        }
        
        @keyframes wiggle {
            0%, 100% { transform: rotate(0deg); }
            25% { transform: rotate(15deg); }
            75% { transform: rotate(-15deg); }
        }
    </style>
</head>
<body>
    <div id="world-container">
        <div id="grass-field"></div>
        <canvas id="pathCanvas"></canvas>
        <canvas id="entityCanvas"></canvas>
        <canvas id="mainCanvas"></canvas>
        
        <div id="thought-bubble"></div>
        <div id="timer-container">
            <div id="timer-icon">üï∞Ô∏è</div>
            <div id="world-timer"></div>
        </div>
        <div id="buff-container"></div>
        <div id="item-bar"></div>
    </div>

    <script>
        // ====================================================================
        // 0. CONFIGURATION & UTILITIES
        // ====================================================================

        const Config = {
            SAVE_KEY: 'WanderDot_Refactored_V5_Save',
            SAVE_INTERVAL: 10000, // ms

            // Mood Thresholds
            WARNING_ANNOYANCE_THRESHOLD: 25,
            ANNOYANCE_THRESHOLD: 40,
            MAD_THRESHOLD: 75,
            
            // Colors
            COLOR_NORMAL: { r: 255, g: 255, b: 224 },
            COLOR_ANNOYED: { r: 255, g: 165, b: 0 },
            COLOR_MAD: { r: 152, g: 14, b: 11 },
            COLOR_HANGRY_GLOW: 'rgba(255, 100, 100, 0.7)',
            
            // Terrain Colors
            COLOR_FIELD: { r: 1, g: 50, b: 32 },
            COLOR_DIRT: { r: 101, g: 67, b: 33 },
            COLOR_ALIEN_BLUE: { r: 100, g: 149, b: 237 }, 
            COLOR_ALIEN_CLAY: { r: 205, g: 133, b: 63 },

            // World Grid
            GRID_CELL_SIZE: 10,
            MAX_WEAR: 100,
            WEAR_PER_PIXEL: 0.05,
            GRASS_REMOVAL_THRESHOLD: 50,
            PEBBLE_SPAWN_THRESHOLD: 70,
            GRASS_TUFT_COUNT: 300,
            // Reduced UFO mushroom spawn chance
            UFO_MUSHROOM_CHANCE: 0.015, // Reduced from 0.05

            // WanderDot Base Stats
            BASE_SPEED: 120,
            BASE_RADIUS: 20,
            EAT_MUSHROOM_CHANCE: 0.02,
            EAT_DETECTION_RADIUS: 100,
            EAT_DURATION: 3500, // Increased to 3.5s

            // Kangaroo Mechanics
            BOUNCE_DISTANCE: 120,
            BOUNCE_HEIGHT: 60,
            BASE_IMPACT_WEAR: 15,

            // Buffs & Items Configuration
            WATCH_TIME_EXTENSION: 20000,
            MUSHROOM_BUFF_DURATION: 20000, // Flat 20s
            SEED_MATURATION_TIME: 60000, // 1 minute

            Items: {
                watch: { emoji: '‚åö', type: 'utility' },
                coffee: { emoji: '‚òï', type: 'buff', duration: 20000 },
                pizza: { emoji: 'üçï', type: 'buff', duration: 30000 },
                kangaroo: { emoji: 'ü¶ò', type: 'buff', duration: 30000 },
                lightbulb: { emoji: 'üí°', type: 'utility' },
                // hideTimer flag added
                mushroom: { emoji: 'üçÑ', type: 'buff', hideTimer: true } 
            },

            // Emojis
            Emojis: {
                idle: ['üí°', 'üò¥', 'üéÆ', 'üé∂', '‚òï', '‚åö', 'üçï', 'üëΩ', 'ü¶ò','üé•'],
                commandReceived: ['ü§î','üëÄ'],
                annoyed: ['üòí', 'üôÑ', 'üòë', 'ü§®'],
                mad: ['üò´', 'ü§°', 'üë∫', 'üò°', 'ü§¨'],
                madZone: ['üëø', '‚ò†Ô∏è', 'üëé', 'ü§¨'],
                cooldownToAnnoyed: ['üò§'],
                cooldownToNormal: ['ü•∞'],
                directClick: ['üòò', 'ü§≠', 'üòõ', 'üò≥', 'ü•µ', 'üçÜ', 'üí¶'],
                EATING_SEEKING: 'üëÖ',
                EATING_CONSUMING: 'ü§§',
                EATING_SATISFIED: 'üòã',
                // Entities
                SEED: 'ü•î', // Changed to Potato
                FLOWER: 'üåº',
                BROWN_MUSHROOM: 'üçÑ‚Äçüü´',
                DIAMOND: 'üî∏',
            }
        };

        // Terrain Types Enum
        const TerrainType = {
            NORMAL: 'normal',
            ALIEN_BLUE: 'alienBlue',
            ALIEN_CLAY: 'alienClay'
        };

        const Utils = {
            lerp(start, end, amount) {
                return start * (1 - amount) + end * amount;
            },
            lerpColor(colorA, colorB, amount) {
                const r = Math.round(Utils.lerp(colorA.r, colorB.r, amount));
                const g = Math.round(Utils.lerp(colorA.g, colorB.g, amount));
                const b = Math.round(Utils.lerp(colorA.b, colorB.b, amount));
                return `rgb(${r}, ${g}, ${b})`;
            },
            randomChoice(arr) {
                return arr[Math.floor(Math.random() * arr.length)];
            },
            distance(x1, y1, x2, y2) {
                return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
            },
            clamp(num, min, max) {
                return Math.max(min, Math.min(max, num));
            },
            randomRange(min, max) {
                return Math.random() * (max - min) + min;
            }
        };

        // ====================================================================
        // 1. ENTITY MANAGER (Seeds, Diamonds, Pebbles, Mushrooms)
        // ====================================================================
        
        class EntityManager {
            constructor(ctx) {
                this.ctx = ctx;
                this.pebbles = [];
                this.mushrooms = [];
                this.dynamicEntities = [];
                this.needsRedraw = true;
            }

            loadState(saveData) {
                this.pebbles = saveData.pebbles ?? [];
                this.mushrooms = saveData.mushrooms ?? [];
                this.dynamicEntities = saveData.dynamicEntities ?? [];
                this.needsRedraw = true;
            }

            saveState() {
                return {
                    pebbles: this.pebbles,
                    mushrooms: this.mushrooms,
                    dynamicEntities: this.dynamicEntities,
                };
            }

            // --- Dynamic Entities ---
            addEntity(type, x, y, data = {}) {
                const entity = {
                    type: type,
                    x: x, y: y,
                    createdAt: Date.now(),
                    ...data
                };
                this.dynamicEntities.push(entity);
                this.needsRedraw = true;
            }

            update(worldManager) {
                const now = Date.now();
                for (let i = this.dynamicEntities.length - 1; i >= 0; i--) {
                    const entity = this.dynamicEntities[i];
                    
                    if (entity.type === 'seed') {
                        if (now - entity.createdAt > Config.SEED_MATURATION_TIME) {
                            this.matureSeed(entity, i, worldManager);
                        }
                    }
                }
            }

            matureSeed(seed, index, worldManager) {
                const terrainInfo = worldManager.getTerrainInfoAtPoint(seed.x, seed.y);
                let newType = null;

                if (terrainInfo.wear < Config.GRASS_REMOVAL_THRESHOLD) {
                    if (terrainInfo.type === TerrainType.NORMAL) {
                        newType = 'flower';
                    } else if (terrainInfo.type === TerrainType.ALIEN_BLUE) {
                        newType = 'brownMushroom';
                    }
                }
                
                if (newType) {
                    seed.type = newType;
                } else {
                    this.dynamicEntities.splice(index, 1);
                }
                this.needsRedraw = true;
            }

            // --- Static Entities (Pebbles, Mushrooms) ---
            addPebble(pebble) {
                this.pebbles.push(pebble);
                this.needsRedraw = true;
            }

            addMushroom(mushroom) {
                if(!this.mushrooms.some(m => m.gridX === mushroom.gridX && m.gridY === mushroom.gridY)) {
                    this.mushrooms.push(mushroom);
                    this.needsRedraw = true;
                    return true;
                }
                return false;
            }

            removeMushroomByObject(mushroomObject) {
                const index = this.mushrooms.indexOf(mushroomObject);
                if (index > -1) {
                    this.mushrooms.splice(index, 1);
                    this.needsRedraw = true;
                    return true;
                }
                return false;
            }

            removeMushroomInArea(x, y, radius) {
                let removed = false;
                for(let i = this.mushrooms.length - 1; i >= 0; i--) {
                    const m = this.mushrooms[i];
                    if (Utils.distance(m.x, m.y, x, y) < radius) {
                        this.mushrooms.splice(i, 1);
                        removed = true;
                    }
                }
                if (removed) this.needsRedraw = true;
                return removed;
            }

            getNearbyMushroom(x, y, radius) {
                let closest = null;
                let minDistSq = radius * radius;

                for (const m of this.mushrooms) {
                    const distSq = (m.x - x)**2 + (m.y - y)**2;
                    if (distSq < minDistSq) {
                        minDistSq = distSq;
                        closest = m;
                    }
                }
                return closest;
            }

            // --- Rendering ---
            draw(bounds) {
                if (!this.needsRedraw) return;

                this.ctx.clearRect(0, 0, bounds.width, bounds.height);
                
                this.drawPebbles();
                this.drawDynamicEntities();
                this.drawMushrooms();
                
                this.needsRedraw = false;
            }

            drawPebbles() {
                this.ctx.font = 'bold 0.7rem monospace';
                this.pebbles.forEach(p => {
                    this.ctx.fillStyle = p.color;
                    this.ctx.globalAlpha = p.type === 'spaceRock' ? 1.0 : 0.8;
                    this.ctx.fillText(p.char, p.x, p.y);
                });
            }

            drawMushrooms() {
                this.ctx.font = '1rem monospace';
                this.ctx.globalAlpha = 1.0;
                this.mushrooms.forEach(m => {
                    this.ctx.fillText('üçÑ', m.x, m.y);
                });
            }

            drawDynamicEntities() {
                this.ctx.globalAlpha = 1.0;
                this.dynamicEntities.forEach(e => {
                    let emoji = '';
                    let fontSize = '1rem';
                    let textShadow = 'none';

                    if (e.type === 'seed') {
                        emoji = Config.Emojis.SEED;
                        fontSize = '0.5rem'; // Tiny
                        // Use text shadow to make the emoji appear dark/black
                        textShadow = '0 0 2px black, 0 0 2px black, 0 0 2px black'; 
                    }
                    else if (e.type === 'flower') emoji = Config.Emojis.FLOWER;
                    else if (e.type === 'brownMushroom') emoji = Config.Emojis.BROWN_MUSHROOM;
                    else if (e.type === 'diamond') emoji = Config.Emojis.DIAMOND;
                    
                    if (emoji) {
                        this.ctx.font = `${fontSize} monospace`;
                        this.ctx.shadowColor = textShadow === 'none' ? 'transparent' : 'black';
                        this.ctx.shadowBlur = textShadow === 'none' ? 0 : 2;
                        this.ctx.fillText(emoji, e.x, e.y);
                        this.ctx.shadowBlur = 0; // Reset shadow
                    }
                });
            }
        }

        // ====================================================================
        // 2. WORLD MANAGER (Environment, Paths, Grass)
        // ====================================================================

        class WorldManager {
            // (Constructor and Initialization methods remain robust for resizing)
            constructor(width, height, pathCtx, entityManager) {
                this.width = width;
                this.height = height;
                this.pathCtx = pathCtx;
                this.entityManager = entityManager;

                this.pathGrid = [];
                this.grassGrid = [];
                this.grassTufts = [];
                
                this.initializeGrid();
            }

            initializeGrid() {
                const gridWidth = Math.ceil(this.width / Config.GRID_CELL_SIZE);
                const gridHeight = Math.ceil(this.height / Config.GRID_CELL_SIZE);

                const newPathGrid = [];
                const newGrassGrid = [];

                // This logic correctly preserves data during resize (Handles Issue 5)
                for (let i = 0; i < gridWidth; i++) {
                    newPathGrid[i] = [];
                    newGrassGrid[i] = [];
                    for (let j = 0; j < gridHeight; j++) {
                        if (this.pathGrid[i] && this.pathGrid[i][j]) {
                            newPathGrid[i][j] = this.pathGrid[i][j];
                        } else {
                            newPathGrid[i][j] = { wear: 0, hasPebble: false, terrainType: TerrainType.NORMAL, mistOpacity: 0 };
                        }
                        newGrassGrid[i][j] = [];
                    }
                }
                this.pathGrid = newPathGrid;
                this.grassGrid = newGrassGrid;
            }

            // --- Persistence & Setup (Unchanged) ---
            loadState(saveData) {
                const loadedGrid = saveData.pathGrid;
                if (!loadedGrid || loadedGrid.length === 0) return;

                const gridWidth = this.pathGrid.length;
                const gridHeight = this.pathGrid[0].length;
                const loadedWidth = loadedGrid.length;
                const loadedHeight = loadedGrid[0]?.length || 0;

                for (let i = 0; i < Math.min(gridWidth, loadedWidth); i++) {
                    for (let j = 0; j < Math.min(gridHeight, loadedHeight); j++) {
                        if (loadedGrid[i] && loadedGrid[i][j]) {
                            if (loadedGrid[i][j].terrainType === 'alien') {
                                loadedGrid[i][j].terrainType = TerrainType.ALIEN_BLUE; 
                            }
                            this.pathGrid[i][j] = loadedGrid[i][j];
                        }
                    }
                }
            }

            saveState() {
                const clonedPathGrid = this.pathGrid.map(row => row.map(cell => ({...cell})));
                return {
                    pathGrid: clonedPathGrid,
                };
            }

            handleResize(width, height) {
                this.width = width;
                this.height = height;
                this.initializeGrid();
                this.generateGrassField();
                this.redrawWorld();
            }

            redrawWorld() {
                this.pathCtx.clearRect(0, 0, this.width, this.height);
                for (let i = 0; i < this.pathGrid.length; i++) {
                    for (let j = 0; j < this.pathGrid[i].length; j++) {
                        const cell = this.pathGrid[i][j];
                        if (cell.wear > 0 || cell.terrainType !== TerrainType.NORMAL) {
                            this.drawPathCell(i, j);
                        }
                    }
                }
            }

            // --- Utility Functions (Unchanged) ---
            isValidCell(gridX, gridY) {
                return gridX >= 0 && gridX < this.pathGrid.length && gridY >= 0 && gridY < this.pathGrid[0].length;
            }

            getTerrainInfoAtPoint(x, y) {
                const gridX = Math.floor(x / Config.GRID_CELL_SIZE);
                const gridY = Math.floor(y / Config.GRID_CELL_SIZE);
                if (this.isValidCell(gridX, gridY)) {
                    const cell = this.pathGrid[gridX][gridY];
                    return { type: cell.terrainType, wear: cell.wear };
                }
                return { type: TerrainType.NORMAL, wear: 0 };
            }

            // --- GRASS MANAGEMENT (Unchanged) ---
            generateGrassField() {
                const field = document.getElementById('grass-field');
                field.innerHTML = '';
                this.grassTufts = [];
                const grassTypes = ['^^', '^^^', '/\\/\\', '-^-', 'vV'];
                const grassColors = ['#228B22', '#3CB371', '#6B8E23', '#556B2F'];

                for (let i = 0; i < Config.GRASS_TUFT_COUNT; i++) {
                    const tuftEl = document.createElement('span');
                    const xVw = Math.random() * 100;
                    const yVh = Math.random() * 100;
                    const xPx = xVw / 100 * this.width;
                    const yPx = yVh / 100 * this.height;

                    tuftEl.classList.add('grass-tuft');
                    tuftEl.textContent = Utils.randomChoice(grassTypes);
                    tuftEl.style.color = Utils.randomChoice(grassColors);
                    tuftEl.style.left = `${xVw}vw`;
                    tuftEl.style.top = `${yVh}vh`;
                    tuftEl.style.fontSize = `${Math.random() * 0.8 + 0.5}rem`;
                    tuftEl.style.opacity = Math.random() * 0.5 + 0.4;
                    field.appendChild(tuftEl);
                    
                    const tuftData = { element: tuftEl, x: xPx, y: yPx, visible: true };
                    this.grassTufts.push(tuftData);

                    const gridX = Math.floor(xPx / Config.GRID_CELL_SIZE);
                    const gridY = Math.floor(yPx / Config.GRID_CELL_SIZE);

                    if (this.isValidCell(gridX, gridY)) {
                        this.grassGrid[gridX][gridY].push(tuftData);
                        
                        if (this.pathGrid[gridX][gridY].wear > Config.GRASS_REMOVAL_THRESHOLD) {
                            this.hideTuft(tuftData);
                        }
                    }
                }
            }

            updateGrassInCell(gridX, gridY) {
                const tufts = this.grassGrid[gridX]?.[gridY];
                if (!tufts) return;

                tufts.forEach(tuft => {
                    if (tuft.visible) {
                        this.hideTuft(tuft);
                    }
                });
            }

            hideTuft(tuftData) {
                tuftData.element.style.display = 'none';
                tuftData.visible = false;
            }

            wiggleNearbyGrass(x, y) {
                const WIGGLE_RADIUS = 70;
                this.grassTufts.forEach(tuft => {
                    if (tuft.visible && Utils.distance(tuft.x, tuft.y, x, y) < WIGGLE_RADIUS) {
                        tuft.element.style.animation = 'wiggle 0.5s ease-out';
                        tuft.element.addEventListener('animationend', () => {
                            tuft.element.style.animation = '';
                        }, { once: true });
                    }
                });
            }

            // --- WEAR AND TEAR ---

            applyMovementWear(startX, startY, endX, endY, buffManager) {
                const distance = Utils.distance(startX, startY, endX, endY);
                const steps = Math.ceil(distance / (Config.GRID_CELL_SIZE / 2));
                if (steps === 0) return;

                const buffs = buffManager.getActiveBuffs();
                let wearMultiplier = Config.WEAR_PER_PIXEL;
                
                // Coffee increases wear rate
                if (buffs.coffee) {
                    wearMultiplier *= (1 + 1.0 * buffs.coffee.potency);
                }
                // Mushroom buff no longer increases wear rate (Issue 3)

                // Pizza/Mushroom increases wear radius
                let wearRadius = 1;
                if (buffs.pizza || buffs.mushroom) {
                    wearRadius = 2;
                }
                // Simple check for combined stacking leading to larger radius
                if (buffs.pizza && buffs.mushroom) {
                    wearRadius = 3;
                }


                for (let i = 0; i <= steps; i++) {
                    const t = i / steps;
                    const currentX = Utils.lerp(startX, endX, t);
                    const currentY = Utils.lerp(startY, endY, t);
                    
                    this.applyWearToArea(currentX, currentY, wearRadius, (distance/steps) * wearMultiplier);
                }
            }

            applyLandingImpact(x, y, moodState, buffManager) {
                let impactWear = Config.BASE_IMPACT_WEAR;
                const buffs = buffManager.getActiveBuffs();

                if (buffs.coffee) {
                    impactWear *= (1 + 1.0 * buffs.coffee.potency);
                }
                if (buffs.kangaroo) {
                    impactWear *= (1 + 0.3 * buffs.kangaroo.potency);
                }
                // Mushroom buff no longer increases impact wear (Issue 3)

                if (moodState === 'mad') {
                    impactWear *= 1.7;
                    this.wiggleNearbyGrass(x, y);
                    Game.instance.particleManager.spawnLandingParticles(x, y);
                }

                const impactRadius = 2.5;
                this.applyWearToArea(x, y, impactRadius, impactWear, true);
                this.entityManager.removeMushroomInArea(x, y, Config.BASE_RADIUS * 2); 
            }

            applyWearToArea(x, y, radius, wearAmount, useFalloff = false) {
                const centerX = Math.floor(x / Config.GRID_CELL_SIZE);
                const centerY = Math.floor(y / Config.GRID_CELL_SIZE);
                const radiusSq = radius * radius;

                for (let i = -Math.ceil(radius); i <= Math.ceil(radius); i++) {
                    for (let j = -Math.ceil(radius); j <= Math.ceil(radius); j++) {
                        const distSq = i * i + j * j;
                        
                        if (!useFalloff && distSq > radiusSq) continue; 
                        
                        const distance = Math.sqrt(distSq);
                        if (useFalloff && distance > radius) continue;

                        const gridX = centerX + i;
                        const gridY = centerY + j;

                        if (this.isValidCell(gridX, gridY)) {
                            const cell = this.pathGrid[gridX][gridY];
                            const oldWear = cell.wear;
                            
                            let effectiveWear = wearAmount;
                            if (useFalloff) {
                                const falloff = 1 - (distance / radius);
                                effectiveWear *= falloff;
                            }

                            cell.wear = Math.min(Config.MAX_WEAR, cell.wear + effectiveWear);

                            if (Math.floor(cell.wear) > Math.floor(oldWear)) {
                                this.drawPathCell(gridX, gridY);
                                this.trySpawnEntity(gridX, gridY, cell);

                                if (cell.wear > Config.GRASS_REMOVAL_THRESHOLD && oldWear <= Config.GRASS_REMOVAL_THRESHOLD) {
                                    this.updateGrassInCell(gridX, gridY);
                                }
                            }
                        }
                    }
                }
            }

            // --- RENDERING & SPAWNING (Unchanged) ---
            drawPathCell(gridX, gridY) {
                const cell = this.pathGrid[gridX][gridY];
                const wearRatio = cell.wear / Config.MAX_WEAR;
                let baseColor, targetColor;
                let baseOpacity = 0;

                switch (cell.terrainType) {
                    case TerrainType.ALIEN_BLUE:
                        baseColor = Config.COLOR_ALIEN_BLUE;
                        targetColor = Config.COLOR_DIRT; 
                        baseOpacity = cell.mistOpacity ?? 0; 
                        break;
                    case TerrainType.ALIEN_CLAY:
                        baseColor = Config.COLOR_DIRT; 
                        targetColor = Config.COLOR_ALIEN_CLAY;
                        baseOpacity = 0.2;
                        break;
                    case TerrainType.NORMAL:
                    default:
                        baseColor = Config.COLOR_FIELD;
                        targetColor = Config.COLOR_DIRT;
                        break;
                }

                const pathColor = Utils.lerpColor(baseColor, targetColor, wearRatio);
                const pathOpacity = Math.max(wearRatio * 0.8, baseOpacity);

                this.pathCtx.fillStyle = pathColor;
                this.pathCtx.globalAlpha = pathOpacity;
                this.pathCtx.clearRect(gridX * Config.GRID_CELL_SIZE, gridY * Config.GRID_CELL_SIZE, Config.GRID_CELL_SIZE, Config.GRID_CELL_SIZE);
                this.pathCtx.fillRect(gridX * Config.GRID_CELL_SIZE, gridY * Config.GRID_CELL_SIZE, Config.GRID_CELL_SIZE, Config.GRID_CELL_SIZE);
                this.pathCtx.globalAlpha = 1.0;
            }

            trySpawnEntity(gridX, gridY, cell) {
                if (cell.hasPebble) return;

                if (cell.terrainType === TerrainType.ALIEN_CLAY && Math.random() < 0.005) {
                    const x = gridX * Config.GRID_CELL_SIZE + Utils.randomRange(2, Config.GRID_CELL_SIZE - 2);
                    const y = gridY * Config.GRID_CELL_SIZE + Utils.randomRange(2, Config.GRID_CELL_SIZE - 2);
                    this.entityManager.addEntity('diamond', x, y);
                }

                if (cell.wear > Config.PEBBLE_SPAWN_THRESHOLD) {
                    let spawnChance = 0.01;
                    let pebbleType = 'normal';
                    
                    if (cell.terrainType === TerrainType.ALIEN_BLUE) {
                        spawnChance = 0.03;
                        pebbleType = 'spaceRock';
                    } else if (cell.terrainType === TerrainType.ALIEN_CLAY) {
                        spawnChance = 0.008; 
                    }

                    if (Math.random() < spawnChance) {
                        this.spawnPebble(gridX, gridY, pebbleType);
                        cell.hasPebble = true;
                    }
                }
            }

            spawnPebble(gridX, gridY, type) {
                let colors, chars;

                if (type === 'spaceRock') {
                    colors = ['#4B0082', '#6A0DAD', '#551A8B'];
                    chars = ['*', 'o', 'O', '.:', '.:.'];
                } else {
                    colors = ['#000000', '#1C1C1C', '#2A1A10', '#3D2B1F'];
                    chars = ['..', '.-.', ".;'", '-_,`', ':'];
                }

                const pebble = {
                    x: gridX * Config.GRID_CELL_SIZE + Math.random() * Config.GRID_CELL_SIZE,
                    y: gridY * Config.GRID_CELL_SIZE + Math.random() * Config.GRID_CELL_SIZE,
                    char: Utils.randomChoice(chars),
                    color: Utils.randomChoice(colors),
                    type: type
                };
                this.entityManager.addPebble(pebble);
            }

            spawnMushroom(gridX, gridY) {
                const mushroom = {
                    x: gridX * Config.GRID_CELL_SIZE + (Config.GRID_CELL_SIZE / 2),
                    y: gridY * Config.GRID_CELL_SIZE + (Config.GRID_CELL_SIZE / 2),
                    gridX, gridY
                };
                return this.entityManager.addMushroom(mushroom);
            }

            // --- UFO/ALIEN TERRAFORMING ---
            alterGround(x, y) {
                const centerX = Math.floor(x / Config.GRID_CELL_SIZE);
                const centerY = Math.floor(y / Config.GRID_CELL_SIZE);
                const alterRadius = 3;

                for(let i = -alterRadius; i <= alterRadius; i++) {
                    for (let j = -alterRadius; j <= alterRadius; j++) {
                        const distSq = i*i + j*j;
                        if (distSq > alterRadius * alterRadius) continue;
                        
                        const gridX = centerX + i;
                        const gridY = centerY + j;

                        if (this.isValidCell(gridX, gridY)) {
                            const cell = this.pathGrid[gridX][gridY];
                            
                            const isGrass = cell.wear < Config.GRASS_REMOVAL_THRESHOLD;
                            const targetType = isGrass ? TerrainType.ALIEN_BLUE : TerrainType.ALIEN_CLAY;

                            
                            if (targetType === TerrainType.ALIEN_BLUE) {
                                const distance = Math.sqrt(distSq);
                                const falloff = 1 - (distance / alterRadius);
                                const newOpacity = Utils.clamp(falloff * Utils.randomRange(0.2, 0.5), 0.1, 0.5);
                                cell.mistOpacity = Math.max(cell.mistOpacity, newOpacity);
                            }

                            if (cell.terrainType !== targetType) {
                                cell.terrainType = targetType;
                            }
                            
                            this.drawPathCell(gridX, gridY);

                            // Spawn Mushrooms (using configured reduced chance)
                            if(targetType === TerrainType.ALIEN_BLUE && Math.random() < Config.UFO_MUSHROOM_CHANCE) {
                                this.spawnMushroom(gridX, gridY);
                            }
                        }
                    }
                }
            }
        }

        // ====================================================================
        // 3. WANDERDOT (The Circle, Mood, and Behavior)
        // ====================================================================

        class WanderDot {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.previousX = x;
                this.previousY = y;
                
                this.radius = Config.BASE_RADIUS;
                this.color = Utils.lerpColor(Config.COLOR_NORMAL, Config.COLOR_NORMAL, 0);

                this.speed = Config.BASE_SPEED;
                this.currentSpeedMultiplier = 1.0;

                this.dx = (Math.random() - 0.5) * 2;
                this.dy = (Math.random() - 0.5) * 2;
                this.targetX = null;
                this.targetY = null;

                // Mood state
                this.annoyance = 0;
                this.currentMoodState = 'normal';
                this.isCalm = false;
                this.isHangry = false;
                
                // Behavior state
                this.isEating = false;
                this.eatingStartTime = 0;
                this.eatingTarget = null;

                // Bounce state
                this.distanceTraveledOnCurrentBounce = 0;
                this.jiggleEndTime = 0;
                this.verticalOffset = 0;
            }

            loadState(saveData) {
                this.annoyance = saveData.annoyance ?? 0;
                this.isHangry = saveData.isHangry ?? false;
            }

            saveState() {
                return {
                    annoyance: this.annoyance,
                    x: this.x,
                    y: this.y,
                    isHangry: this.isHangry
                };
            }

            setTarget(x, y) {
                if (this.isHangry) {
                    return false;
                }

                if (this.isEating) {
                    this.triggerHangry();
                    return false;
                }

                this.targetX = x;
                this.targetY = y;
                return true;
            }

            triggerHangry() {
                this.isHangry = true;
                this.annoyance = Math.max(this.annoyance, Config.MAD_THRESHOLD + 1);
                // Reset eating state
                this.isEating = false;
                this.eatingTarget = null;
                this.eatingStartTime = 0;
                this.clearTarget();
                // Show angry thought bubble immediately
                Game.instance.uiManager.showThought(Utils.randomChoice(Config.Emojis.mad));
            }


            clearTarget() {
                this.targetX = null;
                this.targetY = null;
                this.distanceTraveledOnCurrentBounce = 0;
            }

            update(deltaTime, bounds, buffManager, worldManager, entityManager) {
                this.updateMood(deltaTime, buffManager);
                this.updatePosition(deltaTime, bounds, buffManager, worldManager, entityManager);
            }

            // --- MOOD LOGIC (Unchanged) ---
            getMoodState(annoyanceValue) {
                if (annoyanceValue > Config.MAD_THRESHOLD) return 'mad';
                if (annoyanceValue > Config.ANNOYANCE_THRESHOLD) return 'annoyed';
                return 'normal';
            }

            addAnnoyance(amount, isDirectClick) {
                let annoyanceToAdd = amount;

                if (this.isCalm) {
                    annoyanceToAdd = 5;
                    this.isCalm = false;
                }

                if (isDirectClick) {
                    annoyanceToAdd *= 1.5;
                }

                this.annoyance = Math.min(100, this.annoyance + annoyanceToAdd);
                return this.getReactionEmoji(isDirectClick);
            }

            getReactionEmoji(isDirectClick) {
                 if (isDirectClick) {
                    const levels = [20, 30, 45, 60, 75, 90];
                    let level = Config.Emojis.directClick.length - 1;
                    for (let i = 0; i < levels.length; i++) {
                        if (this.annoyance < levels[i]) {
                            level = i;
                            break;
                        }
                    }
                    return Config.Emojis.directClick[level];
                } else {
                    if (this.annoyance > Config.MAD_THRESHOLD) {
                        return Utils.randomChoice(Config.Emojis.mad);
                    } else if (this.annoyance > Config.ANNOYANCE_THRESHOLD) {
                        return Utils.randomChoice(Config.Emojis.annoyed);
                    } else {
                        return Utils.randomChoice(Config.Emojis.commandReceived);
                    }
                }
            }

            updateMood(deltaTime, buffManager) {
                // 1. Cooldown
                if (this.annoyance > 0) {
                    const cooldownPerSecond = (this.annoyance > Config.MAD_THRESHOLD) ? 1.8 : 3.0;
                    this.annoyance = Math.max(0, this.annoyance - (cooldownPerSecond * deltaTime));
                }

                // 2. State Change Detection
                const previousState = this.currentMoodState;
                this.currentMoodState = this.getMoodState(this.annoyance);

                let transitionEmoji = null;
                if (this.currentMoodState !== previousState) {
                    if (previousState === 'mad' && this.currentMoodState === 'annoyed') {
                        transitionEmoji = Config.Emojis.cooldownToAnnoyed[0];
                        // Exit Hangry state when cooling down to annoyed
                        if (this.isHangry) {
                            this.isHangry = false;
                        }
                    } else if (previousState === 'annoyed' && this.currentMoodState === 'normal') {
                         this.isCalm = true;
                         transitionEmoji = Config.Emojis.cooldownToNormal[0];
                    }
                }

                // 3. Appearance and Speed Update
                this.updateAppearance(buffManager);

                return transitionEmoji;
            }

            updateAppearance(buffManager) {
                const buffs = buffManager.getActiveBuffs();
                
                let speed = Config.BASE_SPEED;
                let radius = Config.BASE_RADIUS;

                if (buffs.coffee) {
                    speed *= (1 + 0.3 * buffs.coffee.potency);
                }
                
                // Pizza and Mushroom both increase size (Issue 3)
                if (buffs.pizza) {
                    radius *= (1 + 0.3 * buffs.pizza.potency);
                }
                if (buffs.mushroom) {
                    radius *= (1 + 0.3 * buffs.mushroom.potency);
                }

                this.speed = speed;
                this.radius = radius;

                 if (this.annoyance > Config.MAD_THRESHOLD) {
                    this.color = Utils.lerpColor(Config.COLOR_MAD, Config.COLOR_MAD, 0);
                    this.currentSpeedMultiplier = 0.3;
                } else if (this.annoyance > Config.ANNOYANCE_THRESHOLD) {
                    const t = (this.annoyance - Config.ANNOYANCE_THRESHOLD) / (Config.MAD_THRESHOLD - Config.ANNOYANCE_THRESHOLD);
                    this.color = Utils.lerpColor(Config.COLOR_ANNOYED, Config.COLOR_MAD, t);
                    this.currentSpeedMultiplier = Utils.lerp(0.5, 0.3, t);
                } else {
                    const t = this.annoyance / Config.ANNOYANCE_THRESHOLD;
                    this.color = Utils.lerpColor(Config.COLOR_NORMAL, Config.COLOR_ANNOYED, t);
                    this.currentSpeedMultiplier = Utils.lerp(1.0, 0.5, t);
                }
            }

            // --- MOVEMENT & BEHAVIOR LOGIC (Unchanged) ---
            updatePosition(deltaTime, bounds, buffManager, worldManager, entityManager) {
                this.previousX = this.x;
                this.previousY = this.y;

                // 1. Determine behavior and direction
                let movementAllowed = true;
                
                // Check if eating target still exists
                if (this.eatingTarget && !entityManager.mushrooms.includes(this.eatingTarget)) {
                    this.eatingTarget = null;
                    this.isEating = false;
                    this.clearTarget();
                }

                if (this.isEating) {
                    movementAllowed = this.handleEatingBehavior(entityManager, buffManager);
                } 
                
                if (movementAllowed) {
                    if (this.targetX !== null) {
                        this.moveToTarget();
                    } else {
                        this.wander(entityManager, buffManager);
                    }
                } else {
                    this.dx = 0;
                    this.dy = 0;
                }


                // 2. Calculate movement distance
                const buffs = buffManager.getActiveBuffs();
                let effectiveSpeed = this.speed * this.currentSpeedMultiplier;
                
                if (buffs.kangaroo) {
                    effectiveSpeed = Config.BASE_SPEED * (buffs.kangaroo.isEureka ? 1.3 : 1.0);
                }
                
                const distanceMoved = effectiveSpeed * deltaTime;

                // 3. Apply movement
                this.x += this.dx * distanceMoved;
                this.y += this.dy * distanceMoved;

                // 4. Handle World Interaction
                if (buffs.kangaroo) {
                    this.handleBounce(distanceMoved, buffManager, worldManager);
                } else {
                    this.verticalOffset = 0; 
                    if (movementAllowed) {
                         worldManager.applyMovementWear(this.previousX, this.previousY, this.x, this.y, buffManager);
                    }
                }

                // 5. Boundary Collision
                if (movementAllowed) {
                    this.handleBoundaries(bounds);
                }
            }

            handleEatingBehavior(entityManager, buffManager) {
                const uiManager = Game.instance.uiManager;

                // Stage 1: Moving towards the mushroom
                if (this.targetX !== null) {
                    if (uiManager.getCurrentThought() !== Config.Emojis.EATING_SEEKING) {
                        // Show for a long duration, ensuring it stays up until consumption or interruption
                        uiManager.showThought(Config.Emojis.EATING_SEEKING, Config.EAT_DURATION + 60000); 
                    }
                    return true;
                }

                // Stage 2: Reached the mushroom, start chewing animation
                if (this.eatingStartTime === 0) {
                    this.eatingStartTime = Date.now();
                    if (this.eatingTarget) {
                        entityManager.removeMushroomByObject(this.eatingTarget);
                    }
                    uiManager.showThought(Config.Emojis.EATING_CONSUMING, Config.EAT_DURATION);
                }

                // Stage 3: Check if chewing is done
                if (Date.now() - this.eatingStartTime > Config.EAT_DURATION) {
                    this.isEating = false;
                    this.eatingStartTime = 0;
                    this.eatingTarget = null;
                    
                    // Apply the buff (using the new flat duration)
                    buffManager.addBuffTime('mushroom', Config.MUSHROOM_BUFF_DURATION);

                    // Show satisfied thought bubble
                    uiManager.showThought(Config.Emojis.EATING_SATISFIED, 2000);

                    return true;
                }

                return false;
            }

            moveToTarget() {
                const targetX = this.targetX;
                const targetY = this.targetY;
                
                const vecX = targetX - this.x;
                const vecY = targetY - this.y;
                const distanceToTarget = Math.sqrt(vecX * vecX + vecY * vecY);

                const stopDistance = this.isEating ? 5 : this.radius;

                if (distanceToTarget < stopDistance) {
                    this.clearTarget();
                    if (!this.isEating) {
                        this.dx = (Math.random() - 0.5) * 2;
                        this.dy = (Math.random() - 0.5) * 2;
                    }
                } else {
                    this.dx = vecX / distanceToTarget;
                    this.dy = vecY / distanceToTarget;
                }
            }

            wander(entityManager, buffManager) {
                if (this.isEating || this.isHangry) {
                    return;
                }
                
                if (!buffManager.getActiveBuffs().mushroom) {
                    const nearbyMushroom = entityManager.getNearbyMushroom(this.x, this.y, Config.EAT_DETECTION_RADIUS);
                    if (nearbyMushroom && Math.random() < Config.EAT_MUSHROOM_CHANCE) {
                        this.isEating = true;
                        this.eatingTarget = nearbyMushroom;
                        this.targetX = nearbyMushroom.x;
                        this.targetY = nearbyMushroom.y;
                        return; 
                    }
                }

                if (Math.random() < 0.015) {
                    this.dx = (Math.random() - 0.5) * 2;
                    this.dy = (Math.random() - 0.5) * 2;
                }
            }

            handleBounce(distanceMoved, buffManager, worldManager) {
                this.distanceTraveledOnCurrentBounce += distanceMoved;

                let currentBounceHeight = Config.BOUNCE_HEIGHT;
                if (this.currentMoodState === 'mad') {
                    currentBounceHeight /= 2;
                }
                const bounceProgress = Math.min(Math.PI, (this.distanceTraveledOnCurrentBounce / Config.BOUNCE_DISTANCE) * Math.PI);
                this.verticalOffset = Math.sin(bounceProgress) * currentBounceHeight;

                if (this.distanceTraveledOnCurrentBounce >= Config.BOUNCE_DISTANCE) {
                    this.land(buffManager, worldManager);
                }
            }

            land(buffManager, worldManager) {
                worldManager.applyLandingImpact(this.x, this.y, this.currentMoodState, buffManager);
                
                this.jiggleEndTime = Date.now();
                this.verticalOffset = 0;
                this.distanceTraveledOnCurrentBounce = 0;

                if (buffManager.isKangarooEnding()) {
                    buffManager.deactivateBuff('kangaroo', true);
                }
            }

            handleBoundaries(bounds) {
                let hitBoundary = false;
                if (this.x + this.radius > bounds.width || this.x - this.radius < 0) {
                    this.dx *= -1;
                    this.x = Utils.clamp(this.x, this.radius, bounds.width - this.radius);
                    hitBoundary = true;
                }
                if (this.y + this.radius > bounds.height || this.y - this.radius < 0) {
                    this.dy *= -1;
                    this.y = Utils.clamp(this.y, this.radius, bounds.height - this.radius);
                    hitBoundary = true;
                }

                if (hitBoundary && this.targetX !== null) {
                    this.clearTarget();
                     // If boundary collision interrupted eating, cancel it without penalty
                    if (this.isEating) {
                        this.isEating = false;
                        this.eatingTarget = null;
                        const uiManager = Game.instance.uiManager;
                        if (uiManager.getCurrentThought() === Config.Emojis.EATING_SEEKING) {
                            uiManager.hideThought();
                        }
                    }
                }
            }

            // --- RENDERING ---
            draw(ctx) {
                let scaleFactor = 1;
                const buffs = Game.instance.buffManager.getActiveBuffs();

                if (buffs.kangaroo) {
                    const bounceProgress = Math.min(Math.PI, (this.distanceTraveledOnCurrentBounce / Config.BOUNCE_DISTANCE) * Math.PI);
                    scaleFactor = 1 - Math.sin(bounceProgress) * 0.2;
                }

                const currentRadius = this.radius * scaleFactor;

                // Draw Shadow
                // Show shadow if moving or bouncing, hide only if stationary chewing (eatingStartTime > 0)
                if (!(this.isEating && this.eatingStartTime > 0)) {
                    ctx.beginPath();
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.35)';
                    const shadowY = this.y + this.radius; 
                    const shadowScale = 1 - (this.verticalOffset / (Config.BOUNCE_HEIGHT * 3));
                    const shadowRadiusX = currentRadius * shadowScale;
                    const shadowRadiusY = (currentRadius / 3) * shadowScale;
                    ctx.ellipse(this.x, shadowY, shadowRadiusX, shadowRadiusY, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.closePath();
                }

                // Draw Circle
                ctx.save();
                
                let drawY = this.y - this.verticalOffset;
                let eatingWiggle = 0;

                // Eating Animation (Wiggle up and down)
                if (this.isEating && this.eatingStartTime > 0) {
                    const elapsed = Date.now() - this.eatingStartTime;
                    eatingWiggle = Math.sin(elapsed / 100) * 5;
                    drawY += eatingWiggle;
                }

                ctx.translate(this.x, drawY);

                // Landing Jiggle Effect
                const jiggleDuration = 300;
                const timeSinceJiggle = Date.now() - this.jiggleEndTime;
                if (timeSinceJiggle < jiggleDuration) {
                    const jiggleProgress = timeSinceJiggle / jiggleDuration;
                    let jiggleAmountMultiplier = (this.currentMoodState === 'mad') ? 0.4 : 0.2;
                    const jiggleAmount = Math.sin(jiggleProgress * Math.PI * 2) * (1 - jiggleProgress) * jiggleAmountMultiplier;
                    ctx.scale(1 + jiggleAmount, 1 - jiggleAmount);
                }

                // Draw Hangry Glow
                if (this.isHangry) {
                    ctx.shadowBlur = 25;
                    ctx.shadowColor = Config.COLOR_HANGRY_GLOW;
                }

                ctx.beginPath();
                ctx.arc(0, 0, currentRadius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.closePath();
                
                // Draw held item (Mushroom) during chewing phase (Issue 1)
                if (this.isEating && this.eatingStartTime > 0) {
                    ctx.shadowBlur = 0; // Don't glow the mushroom itself
                    ctx.font = `${this.radius * 0.8}px monospace`; // Slightly smaller font
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    // Draw slightly offset downwards so the wiggle makes it visible (Y axis is positive downwards)
                    // The eatingWiggle is already applied to the main translation, so we offset relative to the center.
                    ctx.fillText('üçÑ', 0, this.radius * 0.4); 
                }

                ctx.restore();
            }
        }

        // ====================================================================
        // 4. BUFF AND ITEM MANAGERS
        // ====================================================================

        class BuffManager {
            constructor(entityManager) {
                this.entityManager = entityManager;
                this.buffs = {};
                this.initializeDefinitions();
            }

            initializeDefinitions() {
                Object.entries(Config.Items).forEach(([name, data]) => {
                    if (data.type === 'buff') {
                        this.buffs[name] = {
                            endTime: 0,
                            blinkTimer: null,
                            duration: data.duration || 0,
                            isEureka: false,
                            isEnding: false,
                            emoji: data.emoji,
                            indicator: null,
                            hideTimer: data.hideTimer || false // (Issue 4)
                        };
                    }
                });
            }

            initializeUI() {
                const container = document.getElementById('buff-container');
                const sortedKeys = Object.keys(this.buffs).sort((a, b) => a.localeCompare(b));

                sortedKeys.forEach(name => {
                    const buff = this.buffs[name];
                    const indicator = document.createElement('div');
                    indicator.className = 'buff-indicator';
                    indicator.id = `buff-indicator-${name}`;
                    
                    // Conditionally hide the timer element (Issue 4)
                    const timerHTML = buff.hideTimer ? '' : '<div class="buff-timer"></div>';

                    indicator.innerHTML = `
                        <span class="buff-icon">${buff.emoji}</span>
                        ${timerHTML}
                    `;
                    container.appendChild(indicator);
                    buff.indicator = indicator;
                });
            }

            loadState(saveData) {
                const now = Date.now();
                const loadedBuffs = saveData.buffs;
                if (!loadedBuffs) return;

                Object.entries(loadedBuffs).forEach(([name, data]) => {
                    if (this.buffs[name] && data.remainingTime > 0) {
                        this.buffs[name].endTime = now + data.remainingTime;
                        this.buffs[name].isEureka = data.isEureka;
                        this.setupBuffIndicator(this.buffs[name]);
                        this.setupBlinkTimer(this.buffs[name]);
                    }
                });
            }

            saveState() {
                const savedBuffs = {};
                const now = Date.now();
                Object.entries(this.buffs).forEach(([name, buff]) => {
                    if (buff.endTime > now) {
                        savedBuffs[name] = {
                            remainingTime: buff.endTime - now,
                            isEureka: buff.isEureka
                        };
                    }
                });
                return savedBuffs;
            }

            update() {
                const currentTime = Date.now();
                Object.entries(this.buffs).forEach(([name, buff]) => {
                    if (buff.endTime > currentTime) {
                        this.updateTimerDisplay(buff, currentTime);
                    } else if (buff.indicator.style.display === 'flex' && !buff.isEnding) {
                        this.deactivateBuff(name);
                    }
                });
            }

            updateTimerDisplay(buff, currentTime) {
                // Skip update if timer is hidden (Issue 4)
                if (buff.hideTimer) return;

                const remainingSeconds = Math.ceil((buff.endTime - currentTime) / 1000);
                const minutes = Math.floor(remainingSeconds / 60);
                const seconds = remainingSeconds % 60;
                const timerText = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                
                const timerEl = buff.indicator.querySelector('.buff-timer');
                if (timerEl) {
                    timerEl.textContent = timerText;
                }
            }

            addBuffTime(name, duration) {
                const buff = this.buffs[name];
                if (!buff) return;

                const baseTime = Math.max(Date.now(), buff.endTime);
                buff.endTime = baseTime + duration;
                buff.isEnding = false;

                this.setupBuffIndicator(buff);
                this.setupBlinkTimer(buff);
            }

            setupBuffIndicator(buff) {
                buff.indicator.style.display = 'flex';
                buff.indicator.classList.remove('blinking', 'blip-out');
                if (buff.isEureka) {
                    buff.indicator.classList.add('eureka-state');
                }
            }

            setupBlinkTimer(buff) {
                clearTimeout(buff.blinkTimer);
                const remainingTime = buff.endTime - Date.now();
                const BLINK_THRESHOLD = 3000;

                if (remainingTime > BLINK_THRESHOLD) {
                    buff.blinkTimer = setTimeout(() => {
                        if (buff.endTime > Date.now()) {
                            buff.indicator.classList.add('blinking');
                        }
                    }, remainingTime - BLINK_THRESHOLD);
                } else if (remainingTime > 0) {
                    buff.indicator.classList.add('blinking');
                }
            }

            deactivateBuff(name, force = false) {
                const buff = this.buffs[name];
                
                if ((buff.endTime === 0 && !buff.isEnding)) return;

                if (name === 'kangaroo' && !force) {
                    if (Game.instance.wanderDot.verticalOffset > 0.1) {
                        buff.isEnding = true;
                        buff.endTime = 0;
                        return;
                    }
                }

                if (name === 'mushroom') {
                    const dot = Game.instance.wanderDot;
                    this.entityManager.addEntity('seed', dot.x, dot.y);
                }

                buff.endTime = 0;
                buff.isEureka = false;
                buff.isEnding = false;
                clearTimeout(buff.blinkTimer);

                buff.indicator.classList.add('blip-out');
                buff.indicator.addEventListener('animationend', () => {
                    buff.indicator.style.display = 'none';
                    buff.indicator.className = 'buff-indicator';
                }, { once: true });
            }

            getActiveBuffs() {
                const currentTime = Date.now();
                const active = {};
                Object.entries(this.buffs).forEach(([name, buff]) => {
                    if (buff.endTime > currentTime || buff.isEnding) {
                        active[name] = {
                            isEureka: buff.isEureka,
                            potency: buff.isEureka ? 2.0 : 1.0
                        };
                    }
                });
                return active;
            }

            isKangarooEnding() {
                return this.buffs.kangaroo?.isEnding;
            }

            applyWatchExtension() {
                Object.keys(this.buffs).forEach(name => {
                    if (name !== 'mushroom' && this.buffs[name].endTime > Date.now()) {
                        this.addBuffTime(name, Config.WATCH_TIME_EXTENSION);
                    }
                });
            }

            applyEureka() {
                Object.entries(this.buffs).forEach(([name, buff]) => {
                    if (name !== 'mushroom' && buff.endTime > Date.now()) {
                        buff.isEureka = true;
                        buff.indicator.classList.add('eureka-state');
                    }
                });
            }
        }

        class ItemManager {
            // (Implementation remains unchanged)
            constructor(buffManager) {
                this.buffManager = buffManager;
                this.items = {};
                this.initializeDefinitions();
            }

            initializeDefinitions() {
                Object.entries(Config.Items).forEach(([name, data]) => {
                    if (name !== 'mushroom') {
                        this.items[name] = {
                            count: 0,
                            button: null,
                            emoji: data.emoji,
                            type: data.type
                        };
                    }
                });
            }

            initializeUI() {
                const itemBar = document.getElementById('item-bar');
                itemBar.addEventListener('click', (event) => {
                    const button = event.target.closest('.item-button');
                    if (button && button.dataset.itemName) {
                        this.useItem(button.dataset.itemName);
                    }
                });

                Object.entries(this.items).forEach(([name, item]) => {
                    const button = document.createElement('button');
                    button.className = 'item-button';
                    button.dataset.itemName = name;
                    itemBar.appendChild(button);
                    item.button = button;
                });
                this.updateItemBar();
            }

            loadState(saveData) {
                const loadedItems = saveData.items;
                if (!loadedItems) return;

                Object.entries(loadedItems).forEach(([name, count]) => {
                    if (this.items[name]) {
                        this.items[name].count = count;
                    }
                });
                this.updateItemBar();
            }

            saveState() {
                const savedItems = {};
                Object.entries(this.items).forEach(([name, item]) => {
                    savedItems[name] = item.count;
                });
                return savedItems;
            }

            addItem(emoji) {
                const itemName = Object.keys(this.items).find(name => this.items[name].emoji === emoji);
                if (itemName) {
                    this.items[itemName].count++;
                    this.updateItemBar();
                    return true;
                }
                return false;
            }

            useItem(name) {
                const item = this.items[name];
                if (item.count > 0) {
                    item.count--;
                    this.updateItemBar();
                    this.animateButton(item.button);

                    if (item.type === 'buff') {
                        this.buffManager.addBuffTime(name, this.buffManager.buffs[name].duration);
                    } else if (name === 'watch') {
                        this.buffManager.applyWatchExtension();
                    } else if (name === 'lightbulb') {
                        this.buffManager.applyEureka();
                    }
                }
            }

            animateButton(button) {
                button.classList.add('clicked');
                button.addEventListener('animationend', () => button.classList.remove('clicked'), { once: true });
            }

            updateItemBar() {
                const itemBar = document.getElementById('item-bar');
                let totalItems = 0;
                Object.values(this.items).forEach(item => {
                    if (item.count > 0) {
                        item.button.classList.add('visible');
                        item.button.textContent = `${item.emoji}x${item.count}`;
                        totalItems++;
                    } else {
                        item.button.classList.remove('visible');
                    }
                });

                itemBar.classList.toggle('visible', totalItems > 0);
            }
        }
        
        // ====================================================================
        // 5. PARTICLE SYSTEM & UFO
        // ====================================================================

        // (Implementation remains unchanged)
        class ParticleSystem {
            constructor(ctx) {
                this.ctx = ctx;
                this.particles = [];
            }

            spawnLandingParticles(x, y) {
                const count = 10;
                for(let i=0; i < count; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.random() * 50 + 20;
                    this.particles.push({
                        type: 'pebble', x: x, y: y,
                        dx: Math.cos(angle) * speed, dy: Math.sin(angle) * speed,
                        life: 1, maxLife: 1
                    });
                }
            }

            spawnUFOMist(x, y) {
                if (Math.random() < 0.5) return; 

                this.particles.push({
                    type: 'mist',
                    x: x + (Math.random() - 0.5) * 80,
                    y: y + (Math.random() - 0.5) * 40,
                    dx: (Math.random() - 0.5) * 20,
                    dy: (Math.random() - 0.5) * 10,
                    life: 2, maxLife: 2
                });
            }

            updateAndDraw(deltaTime) {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const p = this.particles[i];
                    p.x += p.dx * deltaTime;
                    p.y += p.dy * deltaTime;
                    p.life -= deltaTime;

                    if(p.life <= 0) {
                        this.particles.splice(i, 1);
                    } else {
                        this.drawParticle(p);
                    }
                }
            }

            drawParticle(p) {
                const opacity = p.life / p.maxLife;
                this.ctx.beginPath();
                if(p.type === 'pebble') {
                    this.ctx.fillStyle = `rgba(30, 30, 30, ${0.5 * opacity})`;
                    this.ctx.arc(p.x, p.y, 2, 0, Math.PI * 2);
                } else if (p.type === 'mist') {
                    this.ctx.fillStyle = `rgba(200, 220, 255, ${0.2 * opacity})`;
                    this.ctx.arc(p.x, p.y, 10, 0, Math.PI * 2);
                }
                this.ctx.fill();
            }
        }

        class UFO {
            constructor(ctx, bounds) {
                this.ctx = ctx;
                this.bounds = bounds;
                this.active = false;
                this.x = 0;
                this.y = 0;
                this.speed = 300;
                this.direction = 1;
            }

            activate() {
                if (this.active) return;
                this.active = true;
                this.y = Math.random() * (this.bounds.height * 0.6) + (this.bounds.height * 0.1);
                
                if(Math.random() < 0.5) {
                    this.direction = 1;
                    this.x = -50;
                } else {
                    this.direction = -1;
                    this.x = this.bounds.width + 50;
                }
            }

            update(deltaTime, particleManager, worldManager) {
                if (!this.active) return;

                this.x += this.speed * this.direction * deltaTime;
                
                particleManager.spawnUFOMist(this.x, this.y);
                
                if(Math.random() < 0.1) {
                    worldManager.alterGround(this.x + (Math.random() - 0.5) * 50, this.y + (Math.random() - 0.5) * 50);
                }

                if(this.x < -100 || this.x > this.bounds.width + 100) {
                    this.active = false;
                }
            }

            draw() {
                if (!this.active) return;
                this.ctx.font = '4rem monospace';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText('üõ∏', this.x, this.y);
                this.ctx.textAlign = 'start';
                this.ctx.textBaseline = 'alphabetic';
            }
        }

        // ====================================================================
        // 6. UI MANAGER (Thoughts, Timers, Interaction)
        // ====================================================================

        class UIManager {
            constructor(wanderDot) {
                this.wanderDot = wanderDot;
                this.thoughtBubble = document.getElementById('thought-bubble');
                this.worldTimerElement = document.getElementById('world-timer');
                this.timerContainer = document.getElementById('timer-container');
                this.timerIcon = document.getElementById('timer-icon');
                
                this.idleThoughtTimer = null;
                this.madThoughtTimer = null;
                this.thoughtTimeout = null;
                this.fadeTimeout = null;
                this.idleEmojiHistory = [];

                this.bubbleAngle = -Math.PI / 2;
                this.targetBubbleAngle = -Math.PI / 2;
                this.riseStartTime = 0;
                this.bounceEndTime = 0;
                
                this.isMouseOverBubble = false;
                this.thoughtTimeoutStartTime = 0;
                this.thoughtTimeoutDuration = 0;
                this.thoughtTimeoutRemaining = 0;
                this.mousePos = { x: 0, y: 0 };

                this.setupEventListeners();
            }

             setupEventListeners() {
                window.addEventListener('mousemove', (event) => {
                    this.mousePos.x = event.clientX;
                    this.mousePos.y = event.clientY;
                });

                this.thoughtBubble.addEventListener('click', (event) => {
                    event.stopPropagation();
                    this.handleThoughtClick();
                });

                this.thoughtBubble.addEventListener('mouseenter', () => this.handleBubbleEnter());
                this.thoughtBubble.addEventListener('mouseleave', () => this.handleBubbleLeave());

                // NEW: Add click listener for Timer toggle (Issue 7)
                // Using 'pointerdown' for responsiveness on both desktop and mobile
                this.timerIcon.addEventListener('pointerdown', (event) => {
                    event.stopPropagation();
                    this.toggleTimerPin();
                });
            }

            // NEW: Toggle Timer Pinning (Issue 7)
            toggleTimerPin() {
                this.timerContainer.classList.toggle('active');
            }

            getCurrentThought() {
                if (this.thoughtBubble.style.display === 'block') {
                    const span = this.thoughtBubble.querySelector('span');
                    return span ? span.textContent : null;
                }
                return null;
            }

            hideThought() {
                if (!this.isMouseOverBubble) {
                    this.thoughtBubble.style.opacity = 0;
                    this.fadeTimeout = setTimeout(() => {
                        this.thoughtBubble.style.display = 'none';
                    }, 300);
                }
            }
             getNextIdleEmoji() {
                const candidateEmojis = Config.Emojis.idle.filter(e => !this.idleEmojiHistory.includes(e));
                const emojiPool = candidateEmojis.length > 0 ? candidateEmojis : Config.Emojis.idle;
                const nextEmoji = Utils.randomChoice(emojiPool);

                this.idleEmojiHistory.push(nextEmoji);
                if (this.idleEmojiHistory.length > 3) {
                    this.idleEmojiHistory.shift();
                }
                return nextEmoji;
            }

            startMadTimer() {
                this.stopMadTimer();
                this.madThoughtTimer = setInterval(() => {
                    // Don't show mad thoughts if Hangry (Hangry overrides standard mad behavior)
                    if (this.wanderDot.currentMoodState === 'mad' && !this.wanderDot.isHangry) {
                        this.showThought(Utils.randomChoice(Config.Emojis.madZone));
                    } else if (this.wanderDot.currentMoodState !== 'mad') {
                        this.stopMadTimer();
                    }
                }, 3000);
            }

            stopMadTimer() {
                clearInterval(this.madThoughtTimer);
                this.madThoughtTimer = null;
            }

            handleThoughtClick() {
                const emoji = this.getCurrentThought();
                
                const collected = Game.instance.itemManager.addItem(emoji);
                
                if (!collected) {
                    if (emoji === 'üëΩ') {
                        Game.instance.ufo.activate();
                    }
                }

                clearTimeout(this.thoughtTimeout);
                clearTimeout(this.fadeTimeout);
                this.thoughtBubble.style.display = 'none';
                this.isMouseOverBubble = false;
            }

            handleBubbleEnter() {
                this.isMouseOverBubble = true;
                this.thoughtTimeoutRemaining = this.thoughtTimeoutDuration - (Date.now() - this.thoughtTimeoutStartTime);
                clearTimeout(this.thoughtTimeout);
                clearTimeout(this.fadeTimeout);
                this.thoughtBubble.style.opacity = 1;
            }

            handleBubbleLeave() {
                this.isMouseOverBubble = false;
                this.thoughtTimeout = setTimeout(() => this.hideThought(), Math.max(500, this.thoughtTimeoutRemaining));
            }

            update(worldCreationTime) {
                this.updateTimer(worldCreationTime);
                if (this.thoughtBubble.style.display === 'block') {
                    this.updateBubblePosition();
                }
            }

            updateTimer(worldCreationTime) {
                const elapsedTime = Date.now() - worldCreationTime;
                const elapsedSeconds = Math.floor(elapsedTime / 1000);
                const minutes = Math.floor(elapsedSeconds / 60);
                const seconds = elapsedSeconds % 60;
                
                let timerText = `Your WanderDot's world has existed for `;
                if (minutes > 0) {
                    timerText += `${minutes} minute${minutes !== 1 ? 's' : ''} and `;
                }
                timerText += `${seconds} second${seconds !== 1 ? 's' : ''}.`;
                this.worldTimerElement.textContent = timerText;
            }


            showThought(emoji, duration = 2000) {
                if (!emoji) return;

                clearTimeout(this.thoughtTimeout);
                clearTimeout(this.fadeTimeout);

                this.prepareBubbleAnimation();

                this.thoughtBubble.innerHTML = `<span>${emoji}</span>`;
                this.thoughtBubble.style.opacity = 1;
                this.thoughtBubble.style.display = 'block';

                this.thoughtTimeoutStartTime = Date.now();
                this.thoughtTimeoutDuration = duration;
                this.thoughtTimeout = setTimeout(() => this.hideThought(), duration);
            }

            prepareBubbleAnimation() {
                if (this.thoughtBubble.style.display === 'block') {
                    this.bounceEndTime = Date.now() + 300;
                } else {
                    const initialOrbitRadius = this.wanderDot.radius;
                    const initialX = this.wanderDot.x + Math.cos(this.bubbleAngle) * initialOrbitRadius;
                    const initialY = this.wanderDot.y + Math.sin(this.bubbleAngle) * initialOrbitRadius;
                    this.thoughtBubble.style.left = `${initialX}px`;
                    this.thoughtBubble.style.top = `${initialY}px`;
                }

                this.thoughtBubble.classList.remove('is-rising');
                void this.thoughtBubble.offsetWidth; 
                this.thoughtBubble.classList.add('is-rising');
                this.riseStartTime = Date.now();
            }

            // --- IDLE THOUGHT SCHEDULING (Unchanged) ---
            scheduleNextIdleThought(delay = 7000) {
                const IDLE_THOUGHT_DURATION = 4000;
                const BREAK_DURATION = 7000;
                
                clearTimeout(this.idleThoughtTimer);
                this.idleThoughtTimer = setTimeout(() => {
                    // Only show if idle (no target AND not eating) AND not annoyed AND not Hangry
                    if (this.wanderDot.targetX === null && 
                        !this.wanderDot.isEating && 
                        !this.wanderDot.isHangry &&
                        this.wanderDot.annoyance < Config.WARNING_ANNOYANCE_THRESHOLD) {
                        
                        const nextEmoji = this.getNextIdleEmoji();
                        this.showThought(nextEmoji, IDLE_THOUGHT_DURATION);
                        
                        this.scheduleNextIdleThought(IDLE_THOUGHT_DURATION + 300 + BREAK_DURATION);
                    } else {
                        // If busy, eating, or annoyed/hangry, check again later
                        this.scheduleNextIdleThought(BREAK_DURATION);
                    }
                }, delay);
            }

            // (updateBubblePosition, findBestBubbleAngle, calculateBubbleAnimations remain unchanged)
            updateBubblePosition() {
                const bubbleWidth = this.thoughtBubble.offsetWidth;
                const bubbleHeight = this.thoughtBubble.offsetHeight;
                const finalOrbitRadius = this.wanderDot.radius + bubbleHeight / 2 + 5;

                this.targetBubbleAngle = this.findBestBubbleAngle(finalOrbitRadius, bubbleWidth, bubbleHeight);
                this.bubbleAngle = Utils.lerp(this.bubbleAngle, this.targetBubbleAngle, 0.1);

                const { radius, verticalBob } = this.calculateBubbleAnimations(finalOrbitRadius);

                let bubbleTargetX = this.wanderDot.x + Math.cos(this.bubbleAngle) * radius;
                let bubbleTargetY = this.wanderDot.y - this.wanderDot.verticalOffset + Math.sin(this.bubbleAngle) * radius + verticalBob;

                if(this.isMouseOverBubble) {
                    const currentX = parseFloat(this.thoughtBubble.style.left) || bubbleTargetX;
                    const currentY = parseFloat(this.thoughtBubble.style.top) || bubbleTargetY;
                    bubbleTargetX = Utils.lerp(currentX, this.mousePos.x, 0.2);
                    bubbleTargetY = Utils.lerp(currentY, this.mousePos.y, 0.2);
                }

                this.thoughtBubble.style.left = `${bubbleTargetX}px`;
                this.thoughtBubble.style.top = `${bubbleTargetY}px`;
            }

            findBestBubbleAngle(radius, width, height) {
                const SAFE_MARGIN = 10;
                const bounds = { width: window.innerWidth, height: window.innerHeight };
                const startAngle = -Math.PI / 2;

                for (let offset = 0; offset < Math.PI; offset += 0.1) {
                    for (const sign of [1, -1]) {
                        const angle = startAngle + offset * sign;
                        const testX = this.wanderDot.x + Math.cos(angle) * radius;
                        const testY = this.wanderDot.y + Math.sin(angle) * radius;

                        if (testX - width / 2 > SAFE_MARGIN && testX + width / 2 < bounds.width - SAFE_MARGIN &&
                            testY - height / 2 > SAFE_MARGIN && testY + height / 2 < bounds.height - SAFE_MARGIN) {
                            return angle;
                        }
                    }
                }
                return this.targetBubbleAngle;
            }

            calculateBubbleAnimations(finalOrbitRadius) {
                let radius = finalOrbitRadius;
                let verticalBob = 0;
                const animTime = Date.now();

                if (this.riseStartTime > 0 && animTime - this.riseStartTime < 400) {
                    const riseProgress = (animTime - this.riseStartTime) / 400;
                    radius = Utils.lerp(this.wanderDot.radius, finalOrbitRadius, riseProgress);
                } else {
                    this.riseStartTime = 0;
                    if (this.bounceEndTime > 0 && animTime < this.bounceEndTime) {
                        const bounceProgress = (animTime - (this.bounceEndTime - 300)) / 300;
                        verticalBob = Math.sin(bounceProgress * Math.PI) * -15;
                    } else {
                        this.bounceEndTime = 0;
                        verticalBob = Math.sin(animTime / 400) * -3;
                    }
                }
                return { radius, verticalBob };
            }
        }

        // ====================================================================
        // 7. GAME (Main Loop, Initialization, Persistence)
        // ====================================================================

        class Game {
            static instance = null;

            constructor() {
                if (Game.instance) return Game.instance;
                Game.instance = this;

                this.initializeCanvases();
                // Ensure bounds reflect the actual window size immediately
                this.bounds = { width: window.innerWidth, height: window.innerHeight };

                this.worldCreationTime = Date.now();
                this.lastFrameTime = 0;
                this.lastClickTime = 0;
                this.lastSaveTime = 0;

                this.initializeGameObjects();
                this.loadGame();
                this.finalizeInitialization();
                this.setupEventListeners();
            }

            initializeCanvases() {
                this.mainCanvas = document.getElementById('mainCanvas');
                this.ctx = this.mainCanvas.getContext('2d');
                this.pathCanvas = document.getElementById('pathCanvas');
                this.pathCtx = this.pathCanvas.getContext('2d');
                this.entityCanvas = document.getElementById('entityCanvas');
                this.entityCtx = this.entityCanvas.getContext('2d');
                this.resizeCanvases();
            }

            resizeCanvases() {
                // Use window.innerWidth/Height for consistency
                this.mainCanvas.width = this.pathCanvas.width = this.entityCanvas.width = window.innerWidth;
                this.mainCanvas.height = this.pathCanvas.height = this.entityCanvas.height = window.innerHeight;
            }

            initializeGameObjects() {
                this.entityManager = new EntityManager(this.entityCtx);
                this.worldManager = new WorldManager(this.bounds.width, this.bounds.height, this.pathCtx, this.entityManager);
                this.wanderDot = new WanderDot(this.bounds.width / 2, this.bounds.height / 2);
                this.uiManager = new UIManager(this.wanderDot);
                this.buffManager = new BuffManager(this.entityManager);
                this.itemManager = new ItemManager(this.buffManager);
                
                this.particleManager = new ParticleSystem(this.ctx);
                this.ufo = new UFO(this.ctx, this.bounds);
            }

            finalizeInitialization() {
                this.buffManager.initializeUI();
                this.itemManager.initializeUI();
                
                this.worldManager.generateGrassField();
                this.worldManager.redrawWorld();

                this.wanderDot.x = Utils.clamp(this.wanderDot.x, Config.BASE_RADIUS, this.bounds.width - Config.BASE_RADIUS);
                this.wanderDot.y = Utils.clamp(this.wanderDot.y, Config.BASE_RADIUS, this.bounds.height - Config.BASE_RADIUS);
                this.wanderDot.previousX = this.wanderDot.x;
                this.wanderDot.previousY = this.wanderDot.y;
            }

            // --- PERSISTENCE (Unchanged) ---
            saveGame() {
                // Prevent saving during the transient eating state (chewing phase)
                if (this.wanderDot.isEating && this.wanderDot.eatingStartTime > 0) return;

                const saveData = {
                    version: 5,
                    worldCreationTime: this.worldCreationTime,
                    world: this.worldManager.saveState(),
                    entities: this.entityManager.saveState(),
                    wanderDot: this.wanderDot.saveState(),
                    items: this.itemManager.saveState(),
                    buffs: this.buffManager.saveState(),
                };

                try {
                    localStorage.setItem(Config.SAVE_KEY, JSON.stringify(saveData));
                    this.lastSaveTime = Date.now();
                } catch (e) {
                    console.error("Error saving game (localStorage might be full):", e);
                }
            }

            loadGame() {
                const saveDataRaw = localStorage.getItem(Config.SAVE_KEY);
                if (!saveDataRaw) return;

                try {
                    const saveData = JSON.parse(saveDataRaw);
                    
                    this.worldCreationTime = saveData.worldCreationTime ?? Date.now();
                    
                    if (saveData.world) this.worldManager.loadState(saveData.world);
                    
                    // Handle legacy loading structures if necessary
                    if (saveData.entities) {
                        this.entityManager.loadState(saveData.entities);
                    } else if (saveData.world && saveData.version < 3) {
                         this.entityManager.loadState({
                            pebbles: saveData.world.pebbles, 
                            mushrooms: saveData.world.mushrooms,
                            dynamicEntities: saveData.world.dynamicObjects
                        });
                    }
                    
                    this.wanderDot.loadState(saveData.wanderDot);
                    
                    if (saveData.wanderDot.x && saveData.wanderDot.y) {
                        this.wanderDot.x = saveData.wanderDot.x;
                        this.wanderDot.y = saveData.wanderDot.y;
                    }

                    this.itemManager.loadState(saveData);
                    this.buffManager.loadState(saveData);

                } catch (e) {
                    console.error("Error loading game (data might be corrupted):", e);
                }
            }

            // --- EVENTS ---
            setupEventListeners() {
                window.addEventListener('resize', () => this.handleResize());
                // Use pointerdown for better responsiveness on all devices
                this.mainCanvas.addEventListener('pointerdown', (event) => this.handleClick(event));
                window.addEventListener('beforeunload', () => this.saveGame());
            }

            handleResize() {
                // Update bounds and canvases immediately based on new window size
                this.bounds.width = window.innerWidth;
                this.bounds.height = window.innerHeight;
                this.resizeCanvases();
                // Notify managers to adapt to the new size (Handles Issue 5)
                this.worldManager.handleResize(this.bounds.width, this.bounds.height);
                this.entityManager.needsRedraw = true;
            }

            handleClick(event) {
                // Prevent default browser behavior (like drag/select)
                event.preventDefault(); 

                const clickX = event.clientX;
                const clickY = event.clientY;

                if (this.uiManager.thoughtBubble.style.display === 'block') {
                    const bubbleRect = this.uiManager.thoughtBubble.getBoundingClientRect();
                    if (clickX >= bubbleRect.left && clickX <= bubbleRect.right &&
                        clickY >= bubbleRect.top && clickY <= bubbleRect.bottom) {
                        return; 
                    }
                }

                const currentTime = Date.now();
                const timeDiff = currentTime - this.lastClickTime;
                
                const distanceToCenter = Utils.distance(clickX, clickY, this.wanderDot.x, this.wanderDot.y - this.wanderDot.verticalOffset);
                const isDirectClick = distanceToCenter <= this.wanderDot.radius;

                let commandAccepted = false;

                // Try to issue command
                if (!isDirectClick) {
                   // Attempt to set target. If it returns false, the command was ignored (Hangry or interrupted eating)
                   commandAccepted = this.wanderDot.setTarget(clickX, clickY);
                } else {
                    // Direct click always registers as interaction (unless Hangry)
                    commandAccepted = !this.wanderDot.isHangry; 
                    if (commandAccepted) {
                        this.wanderDot.clearTarget();
                        // Cancel eating without penalty on direct click
                        if (this.wanderDot.isEating) {
                             this.wanderDot.isEating = false;
                             this.wanderDot.eatingTarget = null;
                        }
                    }
                }

                // Calculate and apply annoyance if an interaction occurred OR if the dot is Hangry (to reinforce the anger)
                if (commandAccepted || this.wanderDot.isHangry) {
                    const annoyanceToAdd = Math.min(35, 10 + (2500 / timeDiff));
                    const reactionEmoji = this.wanderDot.addAnnoyance(annoyanceToAdd, isDirectClick);
                    
                    // Show reaction thought, unless the dot is currently chewing (to avoid overriding ü§§)
                    if (!(this.wanderDot.isEating && this.wanderDot.eatingStartTime > 0)) {
                         this.uiManager.showThought(reactionEmoji);
                    }
                }
                
                // Manage Mad Timer
                const currentMood = this.wanderDot.currentMoodState;
                if (currentMood === 'mad' && !this.uiManager.madThoughtTimer) {
                     this.uiManager.startMadTimer();
                } 

                this.lastClickTime = currentTime;
                // Always reschedule idle thoughts after a click attempt
                this.uiManager.scheduleNextIdleThought();
            }

            // Main game loop (Unchanged)
            animate(currentTime) {
                requestAnimationFrame((time) => this.animate(time));

                if (!this.lastFrameTime) {
                    this.lastFrameTime = currentTime;
                    return;
                }
                const deltaTime = (currentTime - this.lastFrameTime) / 1000;
                
                // Handle large deltaTime spikes (e.g., tab inactive)
                if (deltaTime > 0.1) {
                     this.lastFrameTime = currentTime;
                     this.updateTimeBasedSystems();
                     return;
                }

                this.lastFrameTime = currentTime;

                this.update(deltaTime);
                this.draw(deltaTime);

                if (Date.now() - this.lastSaveTime > Config.SAVE_INTERVAL) {
                    this.saveGame();
                }
            }

            updateTimeBasedSystems() {
                this.entityManager.update(this.worldManager);
                this.buffManager.update();
                this.uiManager.update(this.worldCreationTime);
            }

            update(deltaTime) {
                // Update WanderDot
                const transitionEmoji = this.wanderDot.update(deltaTime, this.bounds, this.buffManager, this.worldManager, this.entityManager);
                
                if (transitionEmoji) {
                    this.uiManager.showThought(transitionEmoji);
                    if (transitionEmoji === Config.Emojis.cooldownToAnnoyed[0]) {
                        this.uiManager.stopMadTimer();
                    }
                }

                this.updateTimeBasedSystems();

                // Update UFO
                this.ufo.update(deltaTime, this.particleManager, this.worldManager);
            }

            draw(deltaTime) {
                // Clear main canvas
                this.ctx.clearRect(0, 0, this.bounds.width, this.bounds.height);

                // Draw environment/entities
                this.entityManager.draw(this.bounds);
                
                // Draw main actors
                this.wanderDot.draw(this.ctx);
                this.ufo.draw();

                // Draw particles
                this.particleManager.updateAndDraw(deltaTime);
            }

            start() {
                this.uiManager.scheduleNextIdleThought();
                requestAnimationFrame((time) => this.animate(time));
            }
        }

        // ====================================================================
        // 8. STARTUP
        // ====================================================================
        document.addEventListener('DOMContentLoaded', () => {
            const game = new Game();
            game.start();
        });

    </script>
</body>
</html>
