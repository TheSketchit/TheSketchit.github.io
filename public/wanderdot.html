<!DOCTYPE html>
<html lang="en">
<head>
Â  Â  <meta charset="UTF-8">
Â  Â  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
Â  Â  <title>WanderDot's World</title>
Â  Â  <style>
Â  Â  Â  Â  /* --- 1. CSS VARIABLES & SETUP --- */
Â  Â  Â  Â  :root {
Â  Â  Â  Â  Â  Â  --color-field-bg: #013220;
Â  Â  Â  Â  Â  Â  --color-ui-border: #ccc;
Â  Â  Â  Â  Â  Â  --color-text: white;
Â  Â  Â  Â  Â  Â  --color-eureka-glow: gold;
Â  Â  Â  Â  Â  Â  --color-thought-bg: rgba(25, 25, 112, 0.5);
Â  Â  Â  Â  Â  Â  --font-main: monospace;
Â  Â  Â  Â  }

Â  Â  Â  Â  /* Strict overflow hidden to prevent mobile scrolling/OOB viewing */
Â  Â  Â  Â  html, body {
Â  Â  Â  Â  Â  Â  margin: 0;
Â  Â  Â  Â  Â  Â  padding: 0;
Â  Â  Â  Â  Â  Â  overflow: hidden;
Â  Â  Â  Â  Â  Â  width: 100%;
Â  Â  Â  Â  Â  Â  height: 100%;
Â  Â  Â  Â  }

Â  Â  Â  Â  body {
Â  Â  Â  Â  Â  Â  background-color: var(--color-field-bg);
Â  Â  Â  Â  Â  Â  font-family: var(--font-main);
Â  Â  Â  Â  Â  Â  cursor: default;
Â  Â  Â  Â  Â  Â  user-select: none;
Â  Â  Â  Â  Â  Â  /* Ensure pixel art scales cleanly */
Â  Â  Â  Â  Â  Â  image-rendering: pixelated;
Â  Â  Â  Â  Â  Â  image-rendering: crisp-edges;
Â  Â  Â  Â  }

Â  Â  Â  Â  /* --- 2. WORLD CONTAINERS & LAYERS --- */
Â  Â  Â  Â  #world-container {
Â  Â  Â  Â  Â  Â  position: relative;
Â  Â  Â  Â  Â  Â  /* Dimensions are set explicitly by JS (Game.resizeCanvases) */
Â  Â  Â  Â  Â  Â  overflow: hidden;
Â  Â  Â  Â  }

Â  Â  Â  Â  canvas {
Â  Â  Â  Â  Â  Â  display: block;
Â  Â  Â  Â  Â  Â  position: absolute;
Â  Â  Â  Â  Â  Â  top: 0; left: 0;
Â  Â  Â  Â  }

Â  Â  Â  Â  /* Z-Index layering */
Â  Â  Â  Â  #pathCanvas { z-index: 1; }
Â  Â  Â  Â  #entityCanvas { z-index: 2; }
Â  Â  Â  Â  #mainCanvas { z-index: 3; } /* Handles Grass, WanderDot, UFO, Particles */

Â  Â  Â  Â  /* --- 3. UI ELEMENTS --- */

Â  Â  Â  Â  /* Pause Modal (NEW) */
Â  Â  Â  Â  #pause-overlay {
Â  Â  Â  Â  Â  Â  position: fixed;
Â  Â  Â  Â  Â  Â  top: 0; left: 0;
Â  Â  Â  Â  Â  Â  width: 100%; height: 100%;
Â  Â  Â  Â  Â  Â  background-color: rgba(0, 0, 0, 0.7);
Â  Â  Â  Â  Â  Â  display: none; /* Hidden by default */
Â  Â  Â  Â  Â  Â  align-items: center;
Â  Â  Â  Â  Â  Â  justify-content: center;
Â  Â  Â  Â  Â  Â  z-index: 99;
Â  Â  Â  Â  Â  Â  color: var(--color-text);
Â  Â  Â  Â  Â  Â  text-align: center;
Â  Â  Â  Â  }

Â  Â  Â  Â  #pause-modal {
Â  Â  Â  Â  Â  Â  background-color: rgba(30, 30, 30, 0.9);
Â  Â  Â  Â  Â  Â  padding: 20px 40px;
Â  Â  Â  Â  Â  Â  border-radius: 10px;
Â  Â  Â  Â  Â  Â  border: 2px solid var(--color-ui-border);
Â  Â  Â  Â  }
Â  Â  Â  Â  #pause-modal h2 {
Â  Â  Â  Â  Â  Â  Â font-size: 1.5rem;
Â  Â  Â  Â  Â  Â  Â margin-bottom: 15px;
Â  Â  Â  Â  }

Â  Â  Â  Â  #resume-button {
Â  Â  Â  Â  Â  Â  padding: 8px 16px;
Â  Â  Â  Â  Â  Â  font-size: 1rem;
Â  Â  Â  Â  Â  Â  background-color: #008CBA;
Â  Â  Â  Â  Â  Â  border: none;
Â  Â  Â  Â  Â  Â  border-radius: 5px;
Â  Â  Â  Â  Â  Â  color: white;
Â  Â  Â  Â  Â  Â  cursor: pointer;
Â  Â  Â  Â  Â  Â  transition: background-color 0.3s;
Â  Â  Â  Â  }
Â  Â  Â  Â  #resume-button:hover {
Â  Â  Â  Â  Â  Â  background-color: #007B9A;
Â  Â  Â  Â  }


Â  Â  Â  Â  /* Game Over Modal (NEW) */
Â  Â  Â  Â  #game-over-overlay {
Â  Â  Â  Â  Â  Â  position: fixed;
Â  Â  Â  Â  Â  Â  top: 0; left: 0;
Â  Â  Â  Â  Â  Â  width: 100%; height: 100%;
Â  Â  Â  Â  Â  Â  background-color: rgba(0, 0, 0, 0.8);
Â  Â  Â  Â  Â  Â  display: none; /* Hidden by default */
Â  Â  Â  Â  Â  Â  align-items: center;
Â  Â  Â  Â  Â  Â  justify-content: center;
Â  Â  Â  Â  Â  Â  z-index: 100;
Â  Â  Â  Â  Â  Â  color: var(--color-text);
Â  Â  Â  Â  Â  Â  text-align: center;
Â  Â  Â  Â  }

Â  Â  Â  Â  #game-over-modal {
Â  Â  Â  Â  Â  Â  background-color: #333;
Â  Â  Â  Â  Â  Â  padding: 30px 50px;
Â  Â  Â  Â  Â  Â  border-radius: 15px;
Â  Â  Â  Â  Â  Â  border: 3px solid var(--color-ui-border);
Â  Â  Â  Â  Â  Â  box-shadow: 0 0 30px rgba(255, 50, 50, 0.5);
Â  Â  Â  Â  }

Â  Â  Â  Â  #game-over-modal h1 {
Â  Â  Â  Â  Â  Â  font-size: 2.5rem;
Â  Â  Â  Â  Â  Â  color: #FF6347; /* Tomato Red */
Â  Â  Â  Â  Â  Â  margin-bottom: 20px;
Â  Â  Â  Â  }

Â  Â  Â  Â  #game-over-modal p {
Â  Â  Â  Â  Â  Â  font-size: 1.2rem;
Â  Â  Â  Â  Â  Â  margin-bottom: 30px;
Â  Â  Â  Â  }

Â  Â  Â  Â  #restart-button {
Â  Â  Â  Â  Â  Â  padding: 10px 20px;
Â  Â  Â  Â  Â  Â  font-size: 1.1rem;
Â  Â  Â  Â  Â  Â  background-color: #4CAF50;
Â  Â  Â  Â  Â  Â  border: none;
Â  Â  Â  Â  Â  Â  border-radius: 5px;
Â  Â  Â  Â  Â  Â  color: white;
Â  Â  Â  Â  Â  Â  cursor: pointer;
Â  Â  Â  Â  Â  Â  transition: background-color 0.3s;
Â  Â  Â  Â  }

Â  Â  Â  Â  #restart-button:hover {
Â  Â  Â  Â  Â  Â  background-color: #45a049;
Â  Â  Â  Â  }


Â  Â  Â  Â  /* Thought Bubble */
Â  Â  Â  Â  #thought-bubble {
Â  Â  Â  Â  Â  Â  position: absolute;
Â  Â  Â  Â  Â  Â  display: none;
Â  Â  Â  Â  Â  Â  font-size: 2.5rem; /* Default font size, can be changed dynamically by UIManager */
Â  Â  Â  Â  Â  Â  padding: 0.6rem;
Â  Â  Â  Â  Â  Â  background-color: var(--color-thought-bg);
Â  Â  Â  Â  Â  Â  border: 2px solid var(--color-ui-border);
Â  Â  Â  Â  Â  Â  border-radius: 50%;
Â  Â  Â  Â  Â  Â  backdrop-filter: blur(3px);
Â  Â  Â  Â  Â  Â  transition: opacity 0.3s ease-in-out, left 0.1s linear, top 0.1s linear;
Â  Â  Â  Â  Â  Â  z-index: 4;
Â  Â  Â  Â  Â  Â  cursor: pointer;
Â  Â  Â  Â  Â  Â  transform: translate(-50%, -50%);
Â  Â  Â  Â  Â  Â  white-space: nowrap;
Â  Â  Â  Â  }

Â  Â  Â  Â  .is-rising {
Â  Â  Â  Â  Â  Â  animation: rise-up 0.4s cubic-bezier(0.18, 0.89, 0.32, 1.28);
Â  Â  Â  Â  }

Â  Â  Â  Â  #thought-bubble > span {
Â  Â  Â  Â  Â  Â  pointer-events: none;
Â  Â  Â  Â  }

Â  Â  Â  Â  /* Buff Container */
Â  Â  Â  Â  #buff-container {
Â  Â  Â  Â  Â  Â  position: absolute;
Â  Â  Â  Â  Â  Â  top: 20px; right: 20px;
Â  Â  Â  Â  Â  Â  display: flex;
Â  Â  Â  Â  Â  Â  flex-direction: row-reverse;
Â  Â  Â  Â  Â  Â  gap: 15px;
Â  Â  Â  Â  Â  Â  z-index: 5;
Â  Â  Â  Â  }

Â  Â  Â  Â  .buff-indicator {
Â  Â  Â  Â  Â  Â  display: none;
Â  Â  Â  Â  Â  Â  flex-direction: column;
Â  Â  Â  Â  Â  Â  align-items: center;
Â  Â  Â  Â  Â  Â  text-shadow: 0 0 5px black;
Â  Â  Â  Â  }

Â  Â  Â  Â  .buff-icon {
Â  Â  Â  Â  Â  Â  font-size: 1.5rem;
Â  Â  Â  Â  Â  Â  transition: box-shadow 0.3s ease-in-out;
Â  Â  Â  Â  }

Â  Â  Â  Â  .eureka-state .buff-icon {
Â  Â  Â  Â  Â  Â  border-radius: 5px;
Â  Â  Â  Â  Â  Â  box-shadow: 0 0 8px 3px var(--color-eureka-glow);
Â  Â  Â  Â  }

Â  Â  Â  Â  .buff-timer {
Â  Â  Â  Â  Â  Â  font-size: 0.8rem;
Â  Â  Â  Â  Â  Â  color: var(--color-text);
Â  Â  Â  Â  Â  Â  margin-top: 2px;
Â  Â  Â  Â  }

Â  Â  Â  Â  /* Bottom Bar (NEW) */
Â  Â  Â  Â  #bottom-bar {
Â  Â  Â  Â  Â  Â  position: fixed;
Â  Â  Â  Â  Â  Â  bottom: 0;
Â  Â  Â  Â  Â  Â  left: 0;
Â  Â  Â  Â  Â  Â  width: 100%;
Â  Â  Â  Â  Â  Â  /* Define a height for the bar */
Â  Â  Â  Â  Â  Â  height: 80px;
Â  Â  Â  Â  Â  Â  background-color: rgba(30, 30, 30, 0.9);
Â  Â  Â  Â  Â  Â  border-top: 2px solid var(--color-ui-border);
Â  Â  Â  Â  Â  Â  display: flex;
Â  Â  Â  Â  Â  Â  align-items: center;
Â  Â  Â  Â  Â  Â  justify-content: space-between;
Â  Â  Â  Â  Â  Â  padding: 0 15px;
Â  Â  Â  Â  Â  Â  box-sizing: border-box;
Â  Â  Â  Â  Â  Â  z-index: 10; /* Highest Z-index */
Â  Â  Â  Â  }

Â  Â  Â  Â  /* Stats Container (NEW) */
Â  Â  Â  Â  #stats-container {
Â  Â  Â  Â  Â  Â  display: flex;
Â  Â  Â  Â  Â  Â  gap: 25px;
Â  Â  Â  Â  Â  Â  color: var(--color-text);
Â  Â  Â  Â  Â  Â  font-size: 1.1rem;
Â  Â  Â  Â  }

Â  Â  Â  Â  .stat-item {
Â  Â  Â  Â  Â  Â  white-space: nowrap;
Â  Â  Â  Â  }

Â  Â  Â  Â  /* Bar Graphs (NEW) */
Â  Â  Â  Â  #bar-graphs-container {
Â  Â  Â  Â  Â  Â  display: flex;
Â  Â  Â  Â  Â  Â  flex-direction: column;
Â  Â  Â  Â  Â  Â  gap: 8px;
Â  Â  Â  Â  Â  Â  flex-grow: 1;
Â  Â  Â  Â  Â  Â  max-width: 350px;
Â  Â  Â  Â  Â  Â  margin: 0 30px;
Â  Â  Â  Â  }

Â  Â  Â  Â  .graph-wrapper {
Â  Â  Â  Â  Â  Â  display: flex;
Â  Â  Â  Â  Â  Â  align-items: center;
Â  Â  Â  Â  Â  Â  gap: 15px;
Â  Â  Â  Â  }

Â  Â  Â  Â  .graph-label {
Â  Â  Â  Â  Â  Â  color: var(--color-text);
Â  Â  Â  Â  Â  Â  font-size: 0.9rem;
Â  Â  Â  Â  Â  Â  width: 60px;
Â  Â  Â  Â  Â  Â  text-align: right;
Â  Â  Â  Â  }

Â  Â  Â  Â  .graph-bar {
Â  Â  Â  Â  Â  Â  flex-grow: 1;
Â  Â  Â  Â  Â  Â  height: 22px;
Â  Â  Â  Â  Â  Â  background-color: #444;
Â  Â  Â  Â  Â  Â  border-radius: 5px;
Â  Â  Â  Â  Â  Â  overflow: hidden;
Â  Â  Â  Â  Â  Â  position: relative;
Â  Â  Â  Â  Â  Â  box-shadow: inset 0 0 5px rgba(0,0,0,0.3);
Â  Â  Â  Â  }

Â  Â  Â  Â  .graph-bar-fill {
Â  Â  Â  Â  Â  Â  height: 100%;
Â  Â  Â  Â  Â  Â  width: 100%;
Â  Â  Â  Â  Â  Â  transition: width 0.5s ease-in-out, background-color 0.5s ease-in-out;
Â  Â  Â  Â  }

Â  Â  Â  Â  .graph-bar-text {
Â  Â  Â  Â  Â  Â  position: absolute;
Â  Â  Â  Â  Â  Â  right: 10px;
Â  Â  Â  Â  Â  Â  top: 50%;
Â  Â  Â  Â  Â  Â  transform: translateY(-50%);
Â  Â  Â  Â  Â  Â  /* Start hidden (UPDATED) */
Â  Â  Â  Â  Â  Â  color: rgba(255, 255, 255, 1);
Â  Â  Â  Â  Â  Â  opacity: 0;
Â  Â  Â  Â  Â  Â  font-size: 0.75rem;
Â  Â  Â  Â  Â  Â  pointer-events: none;
Â  Â  Â  Â  Â  Â  transition: opacity 0.5s ease-in-out;
Â  Â  Â  Â  Â  Â  text-shadow: 0 0 5px black;
Â  Â  Â  Â  }

Â  Â  Â  Â  /* Show text when state is active (NEW) */
Â  Â  Â  Â  .graph-bar.active-state .graph-bar-text {
Â  Â  Â  Â  Â  Â  opacity: 1;
Â  Â  Â  Â  }


Â  Â  Â  Â  /* World Timer Display (NEW) */
Â  Â  Â  Â  #world-timer-display {
Â  Â  Â  Â  Â  Â  color: var(--color-text);
Â  Â  Â  Â  Â  Â  font-size: 1.1rem;
Â  Â  Â  Â  Â  Â  margin-right: 25px;
Â  Â  Â  Â  }

Â  Â  Â  Â  /* Chest Container & Button (NEW) */
Â  Â  Â  Â  #chest-container {
Â  Â  Â  Â  Â  Â  position: relative; /* Anchor point for the item bar */
Â  Â  Â  Â  }

Â  Â  Â  Â  #chest-button {
Â  Â  Â  Â  Â  Â  width: 64px;
Â  Â  Â  Â  Â  Â  height: 64px;
Â  Â  Â  Â  Â  Â  /* Background image set by AssetManager */
Â  Â  Â  Â  Â  Â  background-repeat: no-repeat;
Â  Â  Â  Â  Â  Â  background-position: center center;
Â  Â  Â  Â  Â  Â  background-size: contain;
Â  Â  Â  Â  Â  Â  background-color: transparent;
Â  Â  Â  Â  Â  Â  border: none;
Â  Â  Â  Â  Â  Â  cursor: pointer;
Â  Â  Â  Â  Â  Â  padding: 0;
Â  Â  Â  Â  Â  Â  transition: transform 0.1s ease-out;
Â  Â  Â  Â  }

Â  Â  Â  Â  #chest-button:active {
Â  Â  Â  Â  Â  Â  transform: scale(0.9);
Â  Â  Â  Â  }

Â  Â  Â  Â  /* Item Bar (UPDATED) */
Â  Â  Â  Â  #item-bar {
Â  Â  Â  Â  Â  Â  position: absolute;
Â  Â  Â  Â  Â  Â  /* Repositioned to align vertically above the chest */
Â  Â  Â  Â  Â  Â  bottom: 75px; /* Above the chest button */
Â  Â  Â  Â  Â  Â  right: 0;
Â  Â  Â  Â  Â  Â  transform: none; /* Removed translateX */
Â  Â  Â  Â  Â  Â  background-color: rgba(30, 30, 30, 0.85);
Â  Â  Â  Â  Â  Â  border: 2px solid var(--color-ui-border);
Â  Â  Â  Â  Â  Â  border-bottom: none;
Â  Â  Â  Â  Â  Â  border-radius: 10px 10px 0 0;
Â  Â  Â  Â  Â  Â  padding: 5px;
Â  Â  Â  Â  Â  Â  display: flex;
Â  Â  Â  Â  Â  Â  flex-direction: column-reverse; /* Items stack upwards */
Â  Â  Â  Â  Â  Â  gap: 5px;
Â  Â  Â  Â  Â  Â  z-index: 5;
Â  Â  Â  Â  Â  Â  /* Updated transition for sliding up */
Â  Â  Â  Â  Â  Â  transition: max-height 0.4s ease-in-out, opacity 0.3s ease-in-out;
Â  Â  Â  Â  Â  Â  max-height: 0;
Â  Â  Â  Â  Â  Â  opacity: 0;
Â  Â  Â  Â  Â  Â  overflow: hidden;
Â  Â  Â  Â  }

Â  Â  Â  Â  #item-bar.visible {
Â  Â  Â  Â  Â  Â  /* Set a max-height large enough for several items */
Â  Â  Â  Â  Â  Â  max-height: 500px;
Â  Â  Â  Â  Â  Â  opacity: 1;
Â  Â  Â  Â  }

Â  Â  Â  Â  .item-button {
Â  Â  Â  Â  Â  Â  background-color: #333;
Â  Â  Â  Â  Â  Â  border: 2px solid #888;
Â  Â  Â  Â  Â  Â  border-radius: 5px;
Â  Â  Â  Â  Â  Â  color: var(--color-text);
Â  Â  Â  Â  Â  Â  font-size: 1rem;
Â  Â  Â  Â  Â  Â  width: 60px; height: 60px;
Â  Â  Â  Â  Â  Â  cursor: pointer;
Â  Â  Â  Â  Â  Â  display: none;
Â  Â  Â  Â  Â  Â  align-items: center;
Â  Â  Â  Â  Â  Â  justify-content: center;
Â  Â  Â  Â  }

Â  Â  Â  Â  .item-button.visible {
Â  Â  Â  Â  Â  Â  display: flex;
Â  Â  Â  Â  }

Â  Â  Â  Â  .item-button.clicked {
Â  Â  Â  Â  Â  Â  animation: use-item-anim 0.2s ease-out;
Â  Â  Â  Â  }

Â  Â  Â  Â  /* --- 3.5. MOBILE RESPONSIVENESS (UPDATED) --- */
Â  Â  Â  Â  @media (max-width: 768px) {
Â  Â  Â  Â  Â  Â  Â #bottom-bar {
Â  Â  Â  Â  Â  Â  Â  Â  Â height: 110px; /* Taller on mobile */
Â  Â  Â  Â  Â  Â  Â  Â  Â flex-wrap: wrap;
Â  Â  Â  Â  Â  Â  Â  Â  Â padding: 5px 10px;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  #stats-container {
Â  Â  Â  Â  Â  Â  Â  Â  font-size: 0.9rem;
Â  Â  Â  Â  Â  Â  Â  Â  gap: 15px;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  #world-timer-display {
Â  Â  Â  Â  Â  Â  Â  Â  font-size: 0.9rem;
Â  Â  Â  Â  Â  Â  Â  Â  margin-right: 15px;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  #bar-graphs-container {
Â  Â  Â  Â  Â  Â  Â  Â  width: 100%;
Â  Â  Â  Â  Â  Â  Â  Â  order: 2; /* Move graphs below stats/chest */
Â  Â  Â  Â  Â  Â  Â  Â  margin: 5px 0 0 0;
Â  Â  Â  Â  Â  Â  Â  Â  max-width: none;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â .graph-label {
Â  Â  Â  Â  Â  Â  Â  Â  Â font-size: 0.8rem;
Â  Â  Â  Â  Â  Â  Â  Â  Â width: 50px;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  .graph-bar {
Â  Â  Â  Â  Â  Â  Â  Â  height: 18px;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }


Â  Â  Â  Â  /* --- 4. KEYFRAME ANIMATIONS (Unchanged) --- */
Â  Â  Â  Â  @keyframes rise-up {
Â  Â  Â  Â  Â  Â  from { opacity: 0; transform: translate(-50%, -50%) scale(0.4); }
Â  Â  Â  Â  Â  Â  to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
Â  Â  Â  Â  }

Â  Â  Â  Â  @keyframes blink {
Â  Â  Â  Â  Â  Â  50% { opacity: 0.2; }
Â  Â  Â  Â  }
Â  Â  Â  Â  .blinking {
Â  Â  Â  Â  Â  Â  animation: blink 0.5s infinite;
Â  Â  Â  Â  }

Â  Â  Â  Â  @keyframes blip-out {
Â  Â  Â  Â  Â  Â  to { transform: scale(0); opacity: 0; }
Â  Â  Â  Â  }
Â  Â  Â  Â  .blip-out {
Â  Â  Â  Â  Â  Â  animation: blip-out 0.3s forwards;
Â  Â  Â  Â  }

Â  Â  Â  Â  @keyframes use-item-anim {
Â  Â  Â  Â  Â  Â  50% { transform: scale(0.85); }
Â  Â  Â  Â  }

Â  Â  Â  Â  @keyframes wiggle {
Â  Â  Â  Â  Â  Â  0%, 100% { transform: rotate(0deg); }
Â  Â  Â  Â  Â  Â  25% { transform: rotate(15deg); }
Â  Â  Â  Â  Â  Â  75% { transform: rotate(-15deg); }
Â  Â  Â  Â  }
Â  Â  </style>
</head>
<body>
Â  Â  <div id="world-container">
Â  Â  Â  Â  <canvas id="pathCanvas"></canvas>
Â  Â  Â  Â  <canvas id="entityCanvas"></canvas>
Â  Â  Â  Â  <canvas id="mainCanvas"></canvas>

Â  Â  Â  Â  <div id="thought-bubble"></div>
Â  Â  Â  Â  <div id="buff-container"></div>
Â  Â  </div>

Â  Â  <div id="pause-overlay">
Â  Â  Â  Â  <div id="pause-modal">
Â  Â  Â  Â  Â  Â  <h2>Game Paused</h2>
Â  Â  Â  Â  Â  Â  <button id="resume-button">Resume</button>
Â  Â  Â  Â  </div>
Â  Â  </div>

Â  Â  <div id="game-over-overlay">
Â  Â  Â  Â  <div id="game-over-modal">
Â  Â  Â  Â  Â  Â  <h1>GAME OVER</h1>
Â  Â  Â  Â  Â  Â  <p>Under your watchful eye, WanderDot survived for <span id="survival-time">[00m:00s]</span>.</p>
Â  Â  Â  Â  Â  Â  <button id="restart-button">Restart Game</button>
Â  Â  Â  Â  </div>
Â  Â  </div>

Â  Â <div id="bottom-bar">
Â  Â  Â  Â  <div id="stats-container">
Â  Â  Â  Â  Â  Â  <div class="stat-item" id="stat-strength">ğŸ’ª: <span></span></div>
Â  Â  Â  Â  Â  Â  <div class="stat-item" id="stat-radius">â­•: <span></span></div>
Â  Â  Â  Â  Â  Â  <div class="stat-item" id="stat-speed">ğŸ: <span></span></div>
Â  Â  Â  Â  </div>
Â  Â  Â  Â  <div id="bar-graphs-container">
Â  Â  Â  Â  Â  Â  <div class="graph-wrapper">
Â  Â  Â  Â  Â  Â  Â  Â  <div class="graph-label">Mood</div>
Â  Â  Â  Â  Â  Â  Â  Â  <div class="graph-bar" id="mood-bar-bg">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div class="graph-bar-fill" id="mood-bar-fill"></div>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <span class="graph-bar-text">Mad</span>
Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  <div class="graph-wrapper">
Â  Â  Â  Â  Â  Â  Â  Â  <div class="graph-label">Hunger</div>
Â  Â  Â  Â  Â  Â  Â  Â  <div class="graph-bar" id="hunger-bar-bg">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div class="graph-bar-fill" id="hunger-bar-fill"></div>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <span class="graph-bar-text">Hangry</span>
Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  </div>
Â  Â  Â  Â  <div id="world-timer-display">[00m:00s]</div>
Â  Â  Â  Â  <div id="chest-container">
Â  Â  Â  Â  Â  Â  Â <div id="item-bar"></div>
Â  Â  Â  Â  Â  Â  Â <button id="chest-button"></button>
Â  Â  Â  Â  </div>
Â  Â  </div>

Â  Â  <script>
Â  Â  Â  Â  // ====================================================================
Â  Â  Â  Â  // 0. CONFIGURATION & UTILITIES
Â  Â  Â  Â  // ====================================================================

Â  Â  Â  Â  const Config = {
Â  Â  Â  Â  Â  Â  // Mood Thresholds
Â  Â  Â  Â  Â  Â  WARNING_ANNOYANCE_THRESHOLD: 45,
Â  Â  Â  Â  Â  Â  ANNOYANCE_THRESHOLD: 55,
Â  Â  Â  Â  Â  Â  MAD_THRESHOLD: 75,

Â  Â  Â  Â  Â  Â  // Mood/Hunger Interaction
Â  Â  Â  Â  Â  Â  MOOD_HUNGER_DRAIN_MULTIPLIER: 2.0, // Hunger drains 2x faster when mad/annoyed
Â  Â  Â  Â  Â  Â  HUNGER_MOOD_DRAIN_MULTIPLIER: 0.5, // Mood restoration is 50% slower when hungry

Â  Â  Â  Â  Â  Â  // Mood Mechanics
Â  Â  Â  Â  Â  Â  MOOD_DECAY_PER_SECOND: 0.3,Â  Â  Â // Baseline annoyance increase (Mood decrease). Takes ~5.5 mins to reach max if idle.
Â  Â  Â  Â  Â  Â  MOOD_BOOST_FLOWER_RADIUS: 100,Â  Â  // Radius to gain mood boost from flowers
Â  Â  Â  Â  Â  Â  MOOD_BOOST_FLOWER_RATE: 3.5,Â  Â  Â // Annoyance decrease per second near a flower
Â  Â  Â  Â  Â  Â  // MOOD_BOOST_IDLE_THOUGHT: 10,Â  // Removed: Replaced by click-based boost
Â  Â  Â  Â  Â  Â  MOOD_BOOST_CLICKABLE_THOUGHT: 5, // NEW: Annoyance decrease when a positive thought (ğŸ®, ğŸ¥) is clicked


Â  Â  Â  Â  Â  Â  // Colors
Â  Â  Â  Â  Â  Â  COLOR_NORMAL: { r: 255, g: 255, b: 224 },
Â  Â  Â  Â  Â  Â  COLOR_HAPPY: { r: 144, g: 238, b: 144 }, // NEW: LightGreen for happy/kangaroo mood
Â  Â  Â  Â  Â  Â  COLOR_ANNOYED: { r: 255, g: 165, b: 0 },
Â  Â  Â  Â  Â  Â  COLOR_MAD: { r: 152, g: 14, b: 11 },
Â  Â  Â  Â  Â  Â  COLOR_HANGRY_GLOW: 'rgba(255, 100, 100, 0.7)',

Â  Â  Â  Â  Â  Â  // Terrain Colors
Â  Â  Â  Â  Â  Â  COLOR_FIELD: { r: 1, g: 50, b: 32 },
Â  Â  Â  Â  Â  Â  COLOR_DIRT: { r: 101, g: 67, b: 33 },
Â  Â  Â  Â  Â  Â  COLOR_ALIEN_BLUE: { r: 100, g: 149, b: 237 },
Â  Â  Â  Â  Â  Â  COLOR_ALIEN_CLAY: { r: 205, g: 133, b: 63 },

Â  Â  Â  Â  Â  Â  // World Grid
Â  Â  Â  Â  Â  Â  GRID_CELL_SIZE: 10,
Â  Â  Â  Â  Â  Â  MAX_WEAR: 100,
Â  Â  Â  Â  Â  Â  WEAR_PER_PIXEL: 0.05, // Wear applied to the dirt path

Â  Â  Â  Â  Â  Â  // Grass Configuration
Â  Â  Â  Â  Â  Â  GRASS_CLUMP_COUNT: 300,
Â  Â  Â  Â  Â  Â  GRASS_CLUMP_MIN_SIZE: 3,
Â  Â  Â  Â  Â  Â  GRASS_CLUMP_MAX_SIZE: 6,
Â  Â  Â  Â  Â  Â  GRASS_CLUMP_RADIUS: 15,

Â  Â  Â  Â  Â  Â  GRASS_DEATH_THRESHOLD: 0.05,
Â  Â  Â  Â  Â  Â  GRASS_SLIDE_DISTANCE: 10,
Â  Â  Â  Â  Â  Â  GRASS_BEND_ANGLE: 45 * (Math.PI / 180),
Â  Â  Â  Â  Â  Â  // NEW: Grass Shadow Config
Â  Â  Â  Â  Â  Â  GRASS_SHADOW_OFFSET_X: -2, // Small offset behind (assuming light comes from top-right slightly)
Â  Â  Â  Â  Â  Â  GRASS_SHADOW_OFFSET_Y: 1,
Â  Â  Â  Â  Â  Â  GRASS_SHADOW_OPACITY: 0.3,

Â  Â  Â  Â  Â  Â  // NEW: Alien Mist Decay
Â  Â  Â  Â  Â  Â  MIST_DECAY_PER_SECOND: 0.05, // Takes 10 seconds to decay 0.5 opacity

Â  Â  Â  Â  Â  Â  // NEW: Spatial Grid for optimization (Defines the size of cells for interaction checks)
Â  Â  Â  Â  Â  Â  SPATIAL_GRID_SIZE: 100,


Â  Â  Â  Â  Â  Â  // Legacy thresholds
Â  Â  Â  Â  Â  Â  GRASS_REMOVAL_THRESHOLD: 50,
Â  Â  Â  Â  Â  Â  PEBBLE_SPAWN_THRESHOLD: 70,

Â  Â  Â  Â  Â  Â  UFO_MUSHROOM_CHANCE: 0.015,

Â  Â  Â  Â  Â  Â  // WanderDot Base Stats
Â  Â  Â  Â  Â  Â  BASE_SPEED: 120,
Â  Â  Â  Â  Â  Â  BASE_RADIUS: 20,
Â  Â  Â  Â  Â  Â  EAT_MUSHROOM_CHANCE: 0.02,
Â  Â  Â  Â  Â  Â  EAT_DETECTION_RADIUS: 100,
Â  Â  Â  Â  Â  Â  EAT_DURATION: 4000,

Â  Â  Â  Â  Â  Â  // Hunger Mechanics (NEW)
Â  Â  Â  Â  Â  Â  MAX_HUNGER: 100,
Â  Â  Â  Â  Â  Â  HUNGER_DECAY_PER_SECOND: 0.5, // Takes 200 seconds (3.3 mins) to get very hungry
Â  Â  Â  Â  Â  Â  HANGRY_HUNGER_THRESHOLD: 20,
Â  Â  Â  Â  Â  Â  MUSHROOM_HUNGER_RESTORE: 50,
Â  Â  Â  Â  Â  Â  // PIZZA_HUNGER_RESTORE is defined in Buffs/Items

Â  Â  Â  Â  Â  Â  // Kangaroo Mechanics
Â  Â  Â  Â  Â  Â  BOUNCE_DISTANCE: 120,
Â  Â  Â  Â  Â  Â  BOUNCE_HEIGHT: 60,
Â  Â  Â  Â  Â  Â  BASE_IMPACT_WEAR: 15,

Â  Â  Â  Â  Â  Â  // Buffs & Items Configuration
Â  Â  Â  Â  Â  Â  WATCH_TIME_EXTENSION: 20000,
Â  Â  Â  Â  Â  Â  MUSHROOM_BUFF_DURATION: 20000,
Â  Â  Â  Â  Â  Â  SEED_MATURATION_TIME: 60000,

Â  Â  Â  Â  Â  Â  Items: {
Â  Â  Â  Â  Â  Â  Â  Â  watch: { emoji: 'âŒš', type: 'utility' },
Â  Â  Â  Â  Â  Â  Â  Â  coffee: { emoji: 'â˜•', type: 'buff', duration: 20000 },
Â  Â  Â  Â  Â  Â  Â  Â  pizza: { emoji: 'ğŸ•', type: 'buff', duration: 30000, hungerRestore: 100 }, // NEW: Pizza restores hunger
Â  Â  Â  Â  Â  Â  Â  Â  kangaroo: { emoji: 'ğŸ¦˜', type: 'buff', duration: 30000 },
Â  Â  Â  Â  Â  Â  Â  Â  lightbulb: { emoji: 'ğŸ’¡', type: 'utility' },
Â  Â  Â  Â  Â  Â  Â  Â  mushroom: { emoji: 'ğŸ„', type: 'buff', hideTimer: true }
Â  Â  Â  Â  Â  Â  },

Â  Â  Â  Â  Â  Â  // Emojis
Â  Â  Â  Â  Â  Â  Emojis: {
Â  Â  Â  Â  Â  Â  Â  Â  // Note: Using ğŸ¥ (Film Frames) as it was in the original code list, matching the user request for ğŸ“½ï¸ (Projector) functionality.
Â  Â  Â  Â  Â  Â  Â  Â  idle: ['ğŸ’¡', 'ğŸ˜´', 'ğŸ®', 'ğŸ¶', 'â˜•', 'âŒš', 'ğŸ•', 'ğŸ‘½', 'ğŸ¦˜','ğŸ¥'],
Â  Â  Â  Â  Â  Â  Â  Â  commandReceived: ['ğŸ¤”','ğŸ‘€'],
Â  Â  Â  Â  Â  Â  Â  Â  annoyed: ['ğŸ˜’', 'ğŸ™„', 'ğŸ˜‘', 'ğŸ¤¨'],
Â  Â  Â  Â  Â  Â  Â  Â  mad: ['ğŸ˜«', 'ğŸ¤¡', 'ğŸ‘º', 'ğŸ˜¡', 'ğŸ¤¬'],
Â  Â  Â  Â  Â  Â  Â  Â  madZone: ['ğŸ‘¿', 'â˜ ï¸', 'ğŸ‘', 'ğŸ¤¬'],
Â  Â  Â  Â  Â  Â  Â  Â  cooldownToAnnoyed: ['ğŸ˜¤'],
Â  Â  Â  Â  Â  Â  Â  Â  cooldownToNormal: ['ğŸ¥°'],
Â  Â  Â  Â  Â  Â  Â  Â  directClick: ['ğŸ˜˜', 'ğŸ¤­', 'ğŸ˜›', 'ğŸ˜³', 'ğŸ¥µ', 'ğŸ†', 'ğŸ’¦'],
Â  Â  Â  Â  Â  Â  Â  Â  EATING_SEEKING: 'ğŸ‘…',
Â  Â  Â  Â  Â  Â  Â  Â  EATING_CONSUMING: 'ğŸ¤¤',
Â  Â  Â  Â  Â  Â  Â  Â  EATING_SATISFIED: 'ğŸ˜‹',
Â  Â  Â  Â  Â  Â  Â  Â  // Entities
Â  Â  Â  Â  Â  Â  Â  Â  SEED: 'ğŸ¥”',
Â  Â  Â  Â  Â  Â  Â  Â  FLOWER: 'ğŸŒ¼',
Â  Â  Â  Â  Â  Â  Â  Â  BROWN_MUSHROOM: 'ğŸ„â€ğŸŸ«',
Â  Â  Â  Â  Â  Â  Â  Â  DIAMOND: 'ğŸ”¸',
Â  Â  Â  Â  Â  Â  },

Â  Â  Â  Â  Â  Â  // Asset Paths (UPDATED: Removed alienGrass paths)
Â  Â  Â  Â  Â  Â  Assets: {
Â  Â  Â  Â  Â  Â  Â  Â  grass: [
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  '../images/grass/grass_blade_01.png',
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  '../images/grass/grass_blade_02.png',
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  '../images/grass/grass_blade_03.png',
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  '../images/grass/grass_blade_04.png',
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  '../images/grass/grass_blade_05.png',
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  '../images/grass/grass_blade_06.png',
Â  Â  Â  Â  Â  Â  Â  Â  ],
Â  Â  Â  Â  Â  Â  Â  Â  // alienGrass removed, handled by programmatic tinting
Â  Â  Â  Â  Â  Â  Â  Â  chest: '../images/chest.png'
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  };

Â  Â  Â  Â  // Terrain Types Enum
Â  Â  Â  Â  const TerrainType = {
Â  Â  Â  Â  Â  Â  NORMAL: 'normal',
Â  Â  Â  Â  Â  Â  ALIEN_BLUE: 'alienBlue',
Â  Â  Â  Â  Â  Â  ALIEN_CLAY: 'alienClay'
Â  Â  Â  Â  };

Â  Â  Â  Â  const Utils = {
Â  Â  Â  Â  Â  Â  lerp(start, end, amount) {
Â  Â  Â  Â  Â  Â  Â  Â  return start * (1 - amount) + end * amount;
Â  Â  Â  Â  Â  Â  },
Â  Â  Â  Â  Â  Â  lerpColor(colorA, colorB, amount) {
Â  Â  Â  Â  Â  Â  Â  Â  const r = Math.round(Utils.lerp(colorA.r, colorB.r, amount));
Â  Â  Â  Â  Â  Â  Â  Â  const g = Math.round(Utils.lerp(colorA.g, colorB.g, amount));
Â  Â  Â  Â  Â  Â  Â  Â  const b = Math.round(Utils.lerp(colorA.b, colorB.b, amount));
Â  Â  Â  Â  Â  Â  Â  Â  return `rgb(${r}, ${g}, ${b})`;
Â  Â  Â  Â  Â  Â  },
Â  Â  Â  Â  Â  Â  // NEW: Helper to convert RGB object to string
Â  Â  Â  Â  Â  Â  colorToString(colorObj) {
Â  Â  Â  Â  Â  Â  Â  Â  return `rgb(${colorObj.r}, ${colorObj.g}, ${colorObj.b})`;
Â  Â  Â  Â  Â  Â  },
Â  Â  Â  Â  Â  Â  // NEW: Helper to convert RGB string (from lerpColor) to RGBA string
Â  Â  Â  Â  Â  Â  rgbStringToRGBA(rgbString, alpha) {
Â  Â  Â  Â  Â  Â  Â  Â  // Assumes format "rgb(r, g, b)"
Â  Â  Â  Â  Â  Â  Â  Â  // Added safety check for initialization
Â  Â  Â  Â  Â  Â  Â  Â  if (!rgbString || !rgbString.startsWith('rgb(')) return `rgba(0, 0, 0, ${alpha})`;
Â  Â  Â  Â  Â  Â  Â  Â  return rgbString.replace('rgb', 'rgba').replace(')', `, ${alpha})`);
Â  Â  Â  Â  Â  Â  },
Â  Â  Â  Â  Â  Â  randomChoice(arr) {
Â  Â  Â  Â  Â  Â  Â  Â  return arr[Math.floor(Math.random() * arr.length)];
Â  Â  Â  Â  Â  Â  },
Â  Â  Â  Â  Â  Â  distance(x1, y1, x2, y2) {
Â  Â  Â  Â  Â  Â  Â  Â  return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
Â  Â  Â  Â  Â  Â  },
Â  Â  Â  Â  Â  Â  clamp(num, min, max) {
Â  Â  Â  Â  Â  Â  Â  Â  return Math.max(min, Math.min(max, num));
Â  Â  Â  Â  Â  Â  },
Â  Â  Â  Â  Â  Â  randomRange(min, max) {
Â  Â  Â  Â  Â  Â  Â  Â  return Math.random() * (max - min) + min;
Â  Â  Â  Â  Â  Â  },
Â  Â  Â  Â  Â  Â  checkEmojiSupport(emoji) {
Â  Â  Â  Â  Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const canvas = document.createElement('canvas');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const ctx = canvas.getContext('2d');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (!ctx) return true;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.font = '20px sans-serif';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const metrics = ctx.measureText(emoji);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const baselineMetrics = ctx.measureText('ğŸ„');

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return metrics.width <= baselineMetrics.width * 1.5;
Â  Â  Â  Â  Â  Â  Â  Â  } catch (e) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  console.warn("Emoji support check failed, assuming support:", e);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return true;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  };

Â  Â  Â  Â  // ====================================================================
Â  Â  Â  Â  // 0.5. ASSET MANAGER
Â  Â  Â  Â  // ====================================================================

Â  Â  Â  Â  // UPDATED: Pre-renders tinted and silhouette versions of grass assets for performance.
Â  Â  Â  Â  class AssetManager {
Â  Â  Â  Â  Â  Â  constructor() {
Â  Â  Â  Â  Â  Â  Â  Â  this.images = {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  grass: [],
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // NEW: Store pre-rendered variations (as Canvases)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  tintedGrass: [],
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  silhouetteGrass: [],
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  chest: null
Â  Â  Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  Â  Â  this.loadedCount = 0;
Â  Â  Â  Â  Â  Â  Â  Â  this.totalCount = 0;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // --- Pre-rendering Helpers (NEW) ---

Â  Â  Â  Â  Â  Â  // Creates an offscreen canvas containing a tinted version of the image.
Â  Â  Â  Â  Â  Â  generateTintedImage(image, tintColor) {
Â  Â  Â  Â  Â  Â  Â  Â  const canvas = document.createElement('canvas');
Â  Â  Â  Â  Â  Â  Â  Â  canvas.width = image.width;
Â  Â  Â  Â  Â  Â  Â  Â  canvas.height = image.height;
Â  Â  Â  Â  Â  Â  Â  Â  const ctx = canvas.getContext('2d');

Â  Â  Â  Â  Â  Â  Â  Â  // 1. Draw the original image
Â  Â  Â  Â  Â  Â  Â  Â  ctx.drawImage(image, 0, 0);

Â  Â  Â  Â  Â  Â  Â  Â  // 2. Apply the tint color using the 'color' blend mode.
Â  Â  Â  Â  Â  Â  Â  Â  // This changes the hue and saturation of the underlying pixels while preserving luminosity.
Â  Â  Â  Â  Â  Â  Â  Â  ctx.globalCompositeOperation = 'color';
Â  Â  Â  Â  Â  Â  Â  Â  ctx.fillStyle = tintColor;
Â  Â  Â  Â  Â  Â  Â  Â  ctx.fillRect(0, 0, canvas.width, canvas.height);

Â  Â  Â  Â  Â  Â  Â  Â  // 3. Ensure the tint only applies where the original image was opaque (restore alpha).
Â  Â  Â  Â  Â  Â  Â  Â  ctx.globalCompositeOperation = 'destination-in';
Â  Â  Â  Â  Â  Â  Â  Â  ctx.drawImage(image, 0, 0);

Â  Â  Â  Â  Â  Â  Â  Â  return canvas;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // Creates an offscreen canvas containing a black silhouette of the image.
Â  Â  Â  Â  Â  Â  generateSilhouette(image) {
Â  Â  Â  Â  Â  Â  Â  Â  const canvas = document.createElement('canvas');
Â  Â  Â  Â  Â  Â  Â  Â  canvas.width = image.width;
Â  Â  Â  Â  Â  Â  Â  Â  canvas.height = image.height;
Â  Â  Â  Â  Â  Â  Â  Â  const ctx = canvas.getContext('2d');

Â  Â  Â  Â  Â  Â  Â  Â  // 1. Draw the original image (needed for the next step)
Â  Â  Â  Â  Â  Â  Â  Â  ctx.drawImage(image, 0, 0);

Â  Â  Â  Â  Â  Â  Â  Â  // 2. Fill the canvas with black, but only where the original image was present ('source-in').
Â  Â  Â  Â  Â  Â  Â  Â  ctx.globalCompositeOperation = 'source-in';
Â  Â  Â  Â  Â  Â  Â  Â  ctx.fillStyle = 'black';
Â  Â  Â  Â  Â  Â  Â  Â  ctx.fillRect(0, 0, canvas.width, canvas.height);

Â  Â  Â  Â  Â  Â  Â  Â  return canvas;
Â  Â  Â  Â  Â  Â  }


Â  Â  Â  Â  Â  Â  loadAll(onComplete) {
Â  Â  Â  Â  Â  Â  Â  Â  const grassPaths = Config.Assets.grass;
Â  Â  Â  Â  Â  Â  Â  Â  // const alienGrassPaths = Config.Assets.alienGrass; // Removed
Â  Â  Â  Â  Â  Â  Â  Â  const chestPath = Config.Assets.chest;

Â  Â  Â  Â  Â  Â  Â  Â  // Count total assets
Â  Â  Â  Â  Â  Â  Â  Â  this.totalCount = grassPaths.length + (chestPath ? 1 : 0);

Â  Â  Â  Â  Â  Â  Â  Â  if (this.totalCount === 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  onComplete();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // Unified load/error handling
Â  Â  Â  Â  Â  Â  Â  Â  const onLoad = () => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.loadedCount++;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.loadedCount === this.totalCount) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  onComplete();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  };

Â  Â  Â  Â  Â  Â  Â  Â  const onError = (path) => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  console.error(`Failed to load asset: ${path}. Ensure the path is correct.`);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  onLoad(); // Proceed even if an asset fails
Â  Â  Â  Â  Â  Â  Â  Â  };

Â  Â  Â  Â  Â  Â  Â  Â  Â // Load Chest
Â  Â  Â  Â  Â  Â  Â  Â  if (chestPath) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const img = new Image();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  img.src = chestPath;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  img.onload = () => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.images.chest = img;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Apply the loaded image to the button background
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const chestButton = document.getElementById('chest-button');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (chestButton) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  chestButton.style.backgroundImage = `url('${chestPath}')`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  onLoad();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  img.onerror = () => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â console.error(`Failed to load chest asset: ${chestPath}. Using fallback.`);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â // Fallback if image fails
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â const chestButton = document.getElementById('chest-button');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â if (chestButton) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â chestButton.textContent = 'ğŸ“¦';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â chestButton.style.fontSize = '2.5rem';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â onError(chestPath);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // Load standard grass and generate variations (UPDATED)
Â  Â  Â  Â  Â  Â  Â  Â  const alienTintColor = Utils.colorToString(Config.COLOR_ALIEN_BLUE);

Â  Â  Â  Â  Â  Â  Â  Â  grassPaths.forEach((path, index) => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const img = new Image();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  img.src = path;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  img.onload = () => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.images.grass[index] = img;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Generate and store tinted version
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.images.tintedGrass[index] = this.generateTintedImage(img, alienTintColor);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Generate and store silhouette version
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.images.silhouetteGrass[index] = this.generateSilhouette(img);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  onLoad();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  img.onerror = () => onError(path);
Â  Â  Â  Â  Â  Â  Â  Â  });

Â  Â  Â  Â  Â  Â  Â  Â  // Load alien grass (Removed)
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  // ====================================================================
Â  Â  Â  Â  // 1. ENTITY MANAGER (Seeds, Diamonds, Pebbles, Mushrooms)
Â  Â  Â  Â  // ====================================================================

Â  Â  Â  Â  // (EntityManager implementation remains unchanged)
Â  Â  Â  Â  class EntityManager {
Â  Â  Â  Â  Â  Â  constructor(ctx) {
Â  Â  Â  Â  Â  Â  Â  Â  this.ctx = ctx;
Â  Â  Â  Â  Â  Â  Â  Â  this.pebbles = [];
Â  Â  Â  Â  Â  Â  Â  Â  this.mushrooms = [];
Â  Â  Â  Â  Â  Â  Â  Â  this.dynamicEntities = [];
Â  Â  Â  Â  Â  Â  Â  Â  this.needsRedraw = true;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // --- Dynamic Entities ---
Â  Â  Â  Â  Â  Â  addEntity(type, x, y, data = {}) {
Â  Â  Â  Â  Â  Â  Â  Â  const entity = {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  type: type,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  x: x, y: y,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  createdAt: Date.now(),
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ...data
Â  Â  Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  Â  Â  this.dynamicEntities.push(entity);
Â  Â  Â  Â  Â  Â  Â  Â  this.needsRedraw = true;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // NEW: Helper to find nearby dynamic entities of a specific type
Â  Â  Â  Â  Â  Â  getNearbyDynamicEntities(type, x, y, radius) {
Â  Â  Â  Â  Â  Â  Â  Â  const nearby = [];
Â  Â  Â  Â  Â  Â  Â  Â  const radiusSq = radius * radius;

Â  Â  Â  Â  Â  Â  Â  Â  for (const entity of this.dynamicEntities) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (entity.type === type) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const distSq = (entity.x - x)**2 + (entity.y - y)**2;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (distSq < radiusSq) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  nearby.push(entity);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  return nearby;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  removeDynamicEntitiesInArea(x, y, radius) {
Â  Â  Â  Â  Â  Â  Â  Â  let removed = false;
Â  Â  Â  Â  Â  Â  Â  Â  const radiusSq = radius * radius;
Â  Â  Â  Â  Â  Â  Â  Â  const destructibleTypes = ['flower', 'brownMushroom'];

Â  Â  Â  Â  Â  Â  Â  Â  for (let i = this.dynamicEntities.length - 1; i >= 0; i--) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const entity = this.dynamicEntities[i];

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (destructibleTypes.includes(entity.type)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const distSq = (entity.x - x)**2 + (entity.y - y)**2;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Check if the entity center is within the radius
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (distSq < radiusSq) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.dynamicEntities.splice(i, 1);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  removed = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  if (removed) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.needsRedraw = true;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  return removed;
Â  Â  Â  Â  Â  Â  }


Â  Â  Â  Â  Â  Â  update(worldManager) {
Â  Â  Â  Â  Â  Â  Â  Â  const now = Date.now();
Â  Â  Â  Â  Â  Â  Â  Â  for (let i = this.dynamicEntities.length - 1; i >= 0; i--) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const entity = this.dynamicEntities[i];

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (entity.type === 'seed') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (now - entity.createdAt > Config.SEED_MATURATION_TIME) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.matureSeed(entity, i, worldManager);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  matureSeed(seed, index, worldManager) {
Â  Â  Â  Â  Â  Â  Â  Â  const terrainInfo = worldManager.getTerrainInfoAtPoint(seed.x, seed.y);
Â  Â  Â  Â  Â  Â  Â  Â  let newType = null;

Â  Â  Â  Â  Â  Â  Â  Â  // Maturation still relies on the underlying dirt path wear level
Â  Â  Â  Â  Â  Â  Â  Â  if (terrainInfo.wear < Config.GRASS_REMOVAL_THRESHOLD) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (terrainInfo.type === TerrainType.NORMAL) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  newType = 'flower';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else if (terrainInfo.type === TerrainType.ALIEN_BLUE) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  newType = 'brownMushroom';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  if (newType) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  seed.type = newType;
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.dynamicEntities.splice(index, 1);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  this.needsRedraw = true;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // --- Static Entities (Pebbles, Mushrooms) (Unchanged) ---
Â  Â  Â  Â  Â  Â  addPebble(pebble) {
Â  Â  Â  Â  Â  Â  Â  Â  this.pebbles.push(pebble);
Â  Â  Â  Â  Â  Â  Â  Â  this.needsRedraw = true;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  addMushroom(mushroom) {
Â  Â  Â  Â  Â  Â  Â  Â  if(!this.mushrooms.some(m => m.gridX === mushroom.gridX && m.gridY === mushroom.gridY)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.mushrooms.push(mushroom);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.needsRedraw = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return true;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  return false;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  removeMushroomByObject(mushroomObject) {
Â  Â  Â  Â  Â  Â  Â  Â  const index = this.mushrooms.indexOf(mushroomObject);
Â  Â  Â  Â  Â  Â  Â  Â  if (index > -1) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.mushrooms.splice(index, 1);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.needsRedraw = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return true;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  return false;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  removeMushroomInArea(x, y, radius) {
Â  Â  Â  Â  Â  Â  Â  Â  let removed = false;
Â  Â  Â  Â  Â  Â  Â  Â  for(let i = this.mushrooms.length - 1; i >= 0; i--) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const m = this.mushrooms[i];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (Utils.distance(m.x, m.y, x, y) < radius) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.mushrooms.splice(i, 1);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  removed = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  if (removed) this.needsRedraw = true;
Â  Â  Â  Â  Â  Â  Â  Â  return removed;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  getNearbyMushroom(x, y, radius) {
Â  Â  Â  Â  Â  Â  Â  Â  let closest = null;
Â  Â  Â  Â  Â  Â  Â  Â  let minDistSq = radius * radius;

Â  Â  Â  Â  Â  Â  Â  Â  for (const m of this.mushrooms) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const distSq = (m.x - x)**2 + (m.y - y)**2;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (distSq < minDistSq) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  minDistSq = distSq;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  closest = m;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  return closest;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // --- Rendering (Unchanged) ---
Â  Â  Â  Â  Â  Â  draw(bounds) {
Â  Â  Â  Â  Â  Â  Â  Â  if (!this.needsRedraw) return;

Â  Â  Â  Â  Â  Â  Â  Â  this.ctx.clearRect(0, 0, bounds.width, bounds.height);

Â  Â  Â  Â  Â  Â  Â  Â  this.drawPebbles();
Â  Â  Â  Â  Â  Â  Â  Â  this.drawDynamicEntities();
Â  Â  Â  Â  Â  Â  Â  Â  this.drawMushrooms();

Â  Â  Â  Â  Â  Â  Â  Â  this.needsRedraw = false;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  drawPebbles() {
Â  Â  Â  Â  Â  Â  Â  Â  this.ctx.font = 'bold 0.7rem monospace';
Â  Â  Â  Â  Â  Â  Â  Â  this.pebbles.forEach(p => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.ctx.fillStyle = p.color;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.ctx.globalAlpha = p.type === 'spaceRock' ? 1.0 : 0.8;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.ctx.fillText(p.char, p.x, p.y);
Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  drawMushrooms() {
Â  Â  Â  Â  Â  Â  Â  Â  this.ctx.font = '1rem monospace';
Â  Â  Â  Â  Â  Â  Â  Â  this.ctx.globalAlpha = 1.0;
Â  Â  Â  Â  Â  Â  Â  Â  this.mushrooms.forEach(m => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.ctx.fillText('ğŸ„', m.x, m.y);
Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  drawDynamicEntities() {
Â  Â  Â  Â  Â  Â  Â  Â  this.ctx.globalAlpha = 1.0;
Â  Â  Â  Â  Â  Â  Â  Â  this.dynamicEntities.forEach(e => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let emoji = '';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let fontSize = '1rem';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let textShadow = 'none';

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (e.type === 'seed') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  emoji = Config.Emojis.SEED;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  fontSize = '0.5rem'; // Tiny
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Use text shadow to make the emoji appear dark/black
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  textShadow = '0 0 2px black, 0 0 2px black, 0 0 2px black';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  else if (e.type === 'brownMushroom') emoji = Config.Emojis.BROWN_MUSHROOM;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  else if (e.type === 'flower') emoji = Config.Emojis.FLOWER;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  else if (e.type === 'diamond') emoji = Config.Emojis.DIAMOND;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (emoji) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.ctx.font = `${fontSize} monospace`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.ctx.shadowColor = textShadow === 'none' ? 'transparent' : 'black';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.ctx.shadowBlur = textShadow === 'none' ? 0 : 2;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.ctx.fillText(emoji, e.x, e.y);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.ctx.shadowBlur = 0; // Reset shadow
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  // ====================================================================
Â  Â  Â  Â  // 2. WORLD MANAGER (Environment, Paths, Grass)
Â  Â  Â  Â  // ====================================================================

Â  Â  Â  Â  // UPDATED: Implements Spatial Grid, Pre-sorted grass list, Gradient Paths, and Mist Decay.
Â  Â  Â  Â  class WorldManager {
Â  Â  Â  Â  Â  Â  constructor(width, height, pathCtx, entityManager, assetManager) {
Â  Â  Â  Â  Â  Â  Â  Â  this.width = width;
Â  Â  Â  Â  Â  Â  Â  Â  this.height = height;
Â  Â  Â  Â  Â  Â  Â  Â  this.pathCtx = pathCtx;
Â  Â  Â  Â  Â  Â  Â  Â  this.entityManager = entityManager;
Â  Â  Â  Â  Â  Â  Â  Â  this.assetManager = assetManager;

Â  Â  Â  Â  Â  Â  Â  Â  this.pathGrid = [];
Â  Â  Â  Â  Â  Â  Â  Â  this.grassBlades = []; // This list is kept sorted by Y-coordinate (Back to Front)

Â  Â  Â  Â  Â  Â  Â  Â  // NEW: Spatial Grid for interaction optimization
Â  Â  Â  Â  Â  Â  Â  Â  this.spatialGrid = [];
Â  Â  Â  Â  Â  Â  Â  Â  this.gridWidth = 0;
Â  Â  Â  Â  Â  Â  Â  Â  this.gridHeight = 0;

Â  Â  Â  Â  Â  Â  Â  Â  this.initializeGrid();
Â  Â  Â  Â  Â  Â  Â  Â  this.initializeSpatialGrid(); // Initialize the spatial grid structure
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  initializeGrid() {
Â  Â  Â  Â  Â  Â  Â  Â  const gridWidth = Math.ceil(this.width / Config.GRID_CELL_SIZE);
Â  Â  Â  Â  Â  Â  Â  Â  const gridHeight = Math.ceil(this.height / Config.GRID_CELL_SIZE);

Â  Â  Â  Â  Â  Â  Â  Â  const newPathGrid = [];

Â  Â  Â  Â  Â  Â  Â  Â  // Initialize fresh grid or handle resize (preserving existing data if resizing)
Â  Â  Â  Â  Â  Â  Â  Â  for (let i = 0; i < gridWidth; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  newPathGrid[i] = [];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  for (let j = 0; j < gridHeight; j++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Check if cell already exists (from previous size during a resize event)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.pathGrid[i] && this.pathGrid[i][j]) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â newPathGrid[i][j] = this.pathGrid[i][j];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Initialize new cell
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  newPathGrid[i][j] = { wear: 0, hasPebble: false, terrainType: TerrainType.NORMAL, mistOpacity: 0 };
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  this.pathGrid = newPathGrid;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // NEW: Initialize Spatial Grid Structure
Â  Â  Â  Â  Â  Â  initializeSpatialGrid() {
Â  Â  Â  Â  Â  Â  Â  Â  this.gridWidth = Math.ceil(this.width / Config.SPATIAL_GRID_SIZE);
Â  Â  Â  Â  Â  Â  Â  Â  this.gridHeight = Math.ceil(this.height / Config.SPATIAL_GRID_SIZE);
Â  Â  Â  Â  Â  Â  Â  Â  this.spatialGrid = [];
Â  Â  Â  Â  Â  Â  Â  Â  for (let i = 0; i < this.gridWidth; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.spatialGrid[i] = [];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  for (let j = 0; j < this.gridHeight; j++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.spatialGrid[i][j] = []; // Initialize empty array for blades in this cell
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  handleResize(width, height) {
Â  Â  Â  Â  Â  Â  Â  Â  this.width = width;
Â  Â  Â  Â  Â  Â  Â  Â  this.height = height;
Â  Â  Â  Â  Â  Â  Â  Â  this.initializeGrid();
Â  Â  Â  Â  Â  Â  Â  Â  this.initializeSpatialGrid(); // Re-initialize spatial structure
Â  Â  Â  Â  Â  Â  Â  Â  // Regenerate grass field on resize to fill the new area correctly and populate the spatial grid.
Â  Â  Â  Â  Â  Â  Â  Â  this.grassBlades = [];
Â  Â  Â  Â  Â  Â  Â  Â  this.generateGrassField();
Â  Â  Â  Â  Â  Â  Â  Â  this.redrawWorld();
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  redrawWorld() {
Â  Â  Â  Â  Â  Â  Â  Â  // Redraw Paths (Only paths are drawn here now)
Â  Â  Â  Â  Â  Â  Â  Â  this.pathCtx.clearRect(0, 0, this.width, this.height);
Â  Â  Â  Â  Â  Â  Â  Â  for (let i = 0; i < this.pathGrid.length; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  for (let j = 0; j < (this.pathGrid[i]?.length || 0); j++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const cell = this.pathGrid[i][j];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (cell.wear > 0 || cell.terrainType !== TerrainType.NORMAL) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.drawPathCell(i, j);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // --- Utility Functions ---
Â  Â  Â  Â  Â  Â  isValidCell(gridX, gridY) {
Â  Â  Â  Â  Â  Â  Â  Â  return gridX >= 0 && gridX < this.pathGrid.length && gridY >= 0 && this.pathGrid[0] && gridY < this.pathGrid[0].length;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  getTerrainInfoAtPoint(x, y) {
Â  Â  Â  Â  Â  Â  Â  Â  const gridX = Math.floor(x / Config.GRID_CELL_SIZE);
Â  Â  Â  Â  Â  Â  Â  Â  const gridY = Math.floor(y / Config.GRID_CELL_SIZE);
Â  Â  Â  Â  Â  Â  Â  Â  if (this.isValidCell(gridX, gridY)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const cell = this.pathGrid[gridX][gridY];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return { type: cell.terrainType, wear: cell.wear };
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  return { type: TerrainType.NORMAL, wear: 0 };
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // --- GRASS MANAGEMENT ---

Â  Â  Â  Â  Â  Â  // Generates grass in clumps. UPDATED: Populates spatial grid and sorts the master list.
Â  Â  Â  Â  Â  Â  generateGrassField() {
Â  Â  Â  Â  Â  Â  Â  Â  // If blades already exist, don't regenerate yet. (HandleResize clears this if needed)
Â  Â  Â  Â  Â  Â  Â  Â  if (this.grassBlades.length > 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // Ensure spatial grid is clear (important if called manually later)
Â  Â  Â  Â  Â  Â  Â  Â  this.initializeSpatialGrid();

Â  Â  Â  Â  Â  Â  Â  Â  this.grassBlades = [];
Â  Â  Â  Â  Â  Â  Â  Â  const grassImageCount = this.assetManager.images.grass.length;

Â  Â  Â  Â  Â  Â  Â  Â  if (grassImageCount === 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  console.warn("No grass assets loaded. Skipping grass generation.");
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // Iterate through the desired number of clumps
Â  Â  Â  Â  Â  Â  Â  Â  for (let i = 0; i < Config.GRASS_CLUMP_COUNT; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // 1. Choose clump center point
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const centerX = Math.random() * this.width;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const centerY = Math.random() * this.height;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // 2. Choose clump size
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const clumpSize = Math.floor(Utils.randomRange(Config.GRASS_CLUMP_MIN_SIZE, Config.GRASS_CLUMP_MAX_SIZE + 1));

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // 3. Generate blades within the clump radius
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  for (let j = 0; j < clumpSize; j++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const angle = Math.random() * Math.PI * 2;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const distance = Math.random() * Config.GRASS_CLUMP_RADIUS;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const xPx = centerX + Math.cos(angle) * distance;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const yPx = centerY + Math.sin(angle) * distance;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Basic bounds check
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (xPx < 0 || xPx >= this.width || yPx < 0 || yPx >= this.height) continue;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const blade = {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  x: xPx,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  y: yPx,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  imageIndex: Math.floor(Math.random() * grassImageCount),
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Scale reduced by half
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  scale: Utils.randomRange(0.4, 0.8),
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Initial health (opacity) set to 50%
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  health: 0.5,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  offsetX: 0,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  offsetY: 0,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  angle: 0,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  isAlien: false
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  };

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.grassBlades.push(blade);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // NEW: Add blade to the spatial grid
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const gridX = Math.floor(xPx / Config.SPATIAL_GRID_SIZE);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const gridY = Math.floor(yPx / Config.SPATIAL_GRID_SIZE);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Safety check (should be covered by bounds check, but robust)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (gridX >= 0 && gridX < this.gridWidth && gridY >= 0 && gridY < this.gridHeight) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.spatialGrid[gridX][gridY].push(blade);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // NEW: Sort the master list once after generation for efficient Z-sorting during draw.
Â  Â  Â  Â  Â  Â  Â  Â  this.grassBlades.sort((a, b) => a.y - b.y);
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // Handles interaction (sliding, bending) for animation ONLY.
Â  Â  Â  Â  Â  Â  // UPDATED: Uses spatial grid for massive performance improvement.
Â  Â  Â  Â  Â  Â  interactWithGrass(impactX, impactY, radius) {
Â  Â  Â  Â  Â  Â  Â  Â  const radiusSq = radius * radius;

Â  Â  Â  Â  Â  Â  Â  Â  // 1. Determine affected spatial grid cells (Bounding Box check)
Â  Â  Â  Â  Â  Â  Â  Â  const minGridX = Math.max(0, Math.floor((impactX - radius) / Config.SPATIAL_GRID_SIZE));
Â  Â  Â  Â  Â  Â  Â  Â  const maxGridX = Math.min(this.gridWidth - 1, Math.floor((impactX + radius) / Config.SPATIAL_GRID_SIZE));
Â  Â  Â  Â  Â  Â  Â  Â  const minGridY = Math.max(0, Math.floor((impactY - radius) / Config.SPATIAL_GRID_SIZE));
Â  Â  Â  Â  Â  Â  Â  Â  const maxGridY = Math.min(this.gridHeight - 1, Math.floor((impactY + radius) / Config.SPATIAL_GRID_SIZE));

Â  Â  Â  Â  Â  Â  Â  Â  // 2. Iterate only through blades in the affected cells
Â  Â  Â  Â  Â  Â  Â  Â  for (let gx = minGridX; gx <= maxGridX; gx++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  for (let gy = minGridY; gy <= maxGridY; gy++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const cellBlades = this.spatialGrid[gx][gy];

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  for (let i = 0; i < cellBlades.length; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const blade = cellBlades[i];

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // 3. Perform the standard interaction check (distance check)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const distSq = (blade.x - impactX)**2 + (blade.y - impactY)**2;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (distSq < radiusSq) {

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Apply Slide and Bend Animation
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const distance = Math.sqrt(distSq);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (distance > 0.1) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Calculate vector from impact point to the blade
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const dx = blade.x - impactX;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const dy = blade.y - impactY;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Normalize the vector
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const nx = dx / distance;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const ny = dy / distance;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Calculate intensity (stronger when closer)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const intensity = (1 - (distance / radius));

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Slide
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const slideAmount = intensity * Config.GRASS_SLIDE_DISTANCE;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  blade.offsetX = nx * slideAmount;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  blade.offsetY = ny * slideAmount;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Bend
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  blade.angle = nx * intensity * Config.GRASS_BEND_ANGLE;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // Updates grass health based on the wear level of the dirt underneath.
Â  Â  Â  Â  Â  Â  // UPDATED: Must maintain the spatial grid when removing blades.
Â  Â  Â  Â  Â  Â  updateGrassHealthFromDirt() {
Â  Â  Â  Â  Â  Â  Â  Â  // We iterate backwards through the master list for safe removal.
Â  Â  Â  Â  Â  Â  Â  Â  for (let i = this.grassBlades.length - 1; i >= 0; i--) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const blade = this.grassBlades[i];

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Find the grid cell the blade occupies
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const gridX = Math.floor(blade.x / Config.GRID_CELL_SIZE);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const gridY = Math.floor(blade.y / Config.GRID_CELL_SIZE);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.isValidCell(gridX, gridY)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const cell = this.pathGrid[gridX][gridY];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const wearRatio = cell.wear / Config.MAX_WEAR;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Health = Base Opacity (0.5) * (1 - WearRatio)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  blade.health = 0.5 * (1 - wearRatio);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  blade.health = 0.5;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Check for Death
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (blade.health <= Config.GRASS_DEATH_THRESHOLD) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Remove from master list
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.grassBlades.splice(i, 1);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // NEW: Remove from spatial grid (Crucial!)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.removeBladeFromSpatialGrid(blade);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â // NEW: Helper to remove a blade from the spatial grid
Â  Â  Â  Â  Â  Â  removeBladeFromSpatialGrid(blade) {
Â  Â  Â  Â  Â  Â  Â  Â  const gridX = Math.floor(blade.x / Config.SPATIAL_GRID_SIZE);
Â  Â  Â  Â  Â  Â  Â  Â  const gridY = Math.floor(blade.y / Config.SPATIAL_GRID_SIZE);

Â  Â  Â  Â  Â  Â  Â  Â  if (gridX >= 0 && gridX < this.gridWidth && gridY >= 0 && gridY < this.gridHeight) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const cell = this.spatialGrid[gridX][gridY];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const index = cell.indexOf(blade);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (index > -1) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  cell.splice(index, 1);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }


Â  Â  Â  Â  Â  Â  // Update loop for grass (handles animation decay AND health updates)
Â  Â  Â  Â  Â  Â  updateGrass(deltaTime) {
Â  Â  Â  Â  Â  Â  Â  Â  // 1. Update health based on underlying dirt wear
Â  Â  Â  Â  Â  Â  Â  Â  this.updateGrassHealthFromDirt();

Â  Â  Â  Â  Â  Â  Â  Â  // 2. Handle animation decay (springing back)
Â  Â  Â  Â  Â  Â  Â  Â  const decayRate = 5;

Â  Â  Â  Â  Â  Â  Â  Â  // Note: We still iterate all blades here, as we don't track which specific blades are currently animating.
Â  Â  Â  Â  Â  Â  Â  Â  // This loop is relatively fast compared to the interaction/drawing loops.
Â  Â  Â  Â  Â  Â  Â  Â  for (const blade of this.grassBlades) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const needsUpdate = Math.abs(blade.offsetX) > 0.1 || Math.abs(blade.offsetY) > 0.1 || Math.abs(blade.angle) > 0.01;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (needsUpdate) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Lerp offsets and angle back towards 0
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  blade.offsetX = Utils.lerp(blade.offsetX, 0, decayRate * deltaTime);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  blade.offsetY = Utils.lerp(blade.offsetY, 0, decayRate * deltaTime);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  blade.angle = Utils.lerp(blade.angle, 0, decayRate * deltaTime);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else if (blade.offsetX !== 0 || blade.offsetY !== 0 || blade.angle !== 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Snap to 0 when very close
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  blade.offsetX = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  blade.offsetY = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  blade.angle = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // Draws a single blade of grass. Called by the main Game loop during sorted rendering.
Â  Â  Â  Â  Â  Â  // UPDATED: Uses pre-rendered assets for tinting and shadows for performance.
Â  Â  Â  Â  Â  Â  drawBlade(ctx, blade) {
Â  Â  Â  Â  Â  Â  Â  Â  const index = blade.imageIndex;

Â  Â  Â  Â  Â  Â  Â  Â  // Ensure the index is valid and assets exist (they are generated in AssetManager)
Â  Â  Â  Â  Â  Â  Â  Â  if (!this.assetManager.images.grass[index] || !this.assetManager.images.tintedGrass[index] || !this.assetManager.images.silhouetteGrass[index]) return;

Â  Â  Â  Â  Â  Â  Â  Â  // Select the appropriate image (standard or pre-tinted)
Â  Â  Â  Â  Â  Â  Â  Â  const img = blade.isAlien ? this.assetManager.images.tintedGrass[index] : this.assetManager.images.grass[index];
Â  Â  Â  Â  Â  Â  Â  Â  const shadowImg = this.assetManager.images.silhouetteGrass[index];

Â  Â  Â  Â  Â  Â  Â  Â  // Check if image/canvas is valid (img can be Image or Canvas)
Â  Â  Â  Â  Â  Â  Â  Â  if (!img || (img instanceof HTMLImageElement && !img.complete)) return;


Â  Â  Â  Â  Â  Â  Â  Â  const width = img.width * blade.scale;
Â  Â  Â  Â  Â  Â  Â  Â  const height = img.height * blade.scale;

Â  Â  Â  Â  Â  Â  Â  Â  // Calculate the position of the base of the blade (pivot point), including interaction offsets
Â  Â  Â  Â  Â  Â  Â  Â  const baseX = blade.x + blade.offsetX;
Â  Â  Â  Â  Â  Â  Â  Â  const baseY = blade.y + blade.offsetY;

Â  Â  Â  Â  Â  Â  Â  Â  // Calculate blade opacity based on health
Â  Â  Â  Â  Â  Â  Â  Â  const bladeOpacity = Math.max(0, blade.health);

Â  Â  Â  Â  Â  Â  Â  Â  // Helper function to apply transformations and draw
Â  Â  Â  Â  Â  Â  Â  Â  // This handles drawing the image (shadow or blade) at a specific world-space offset from baseX/Y, applying the blade's rotation.
Â  Â  Â  Â  Â  Â  Â  Â  const drawTransformed = (imageToDraw, drawOffsetX, drawOffsetY, opacity) => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.globalAlpha = opacity;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (blade.angle !== 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.save();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Translate to the pivot point (base position + desired drawing offset)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.translate(baseX + drawOffsetX, baseY + drawOffsetY);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Apply the bend rotation
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.rotate(blade.angle);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Draw relative to the translated/rotated origin (centered on pivot)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.drawImage(imageToDraw, -width / 2, -height, width, height);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.restore();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Optimized drawing for non-rotated blades
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const drawX = baseX + drawOffsetX - width / 2;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const drawY = baseY + drawOffsetY - height;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.drawImage(imageToDraw, drawX, drawY, width, height);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  };

Â  Â  Â  Â  Â  Â  Â  Â  // 1. Draw Shadow (using the pre-rendered silhouette)
Â  Â  Â  Â  Â  Â  Â  Â  // This is significantly faster than using ctx.shadowBlur/shadowColor.
Â  Â  Â  Â  Â  Â  Â  Â  const shadowOpacity = bladeOpacity * Config.GRASS_SHADOW_OPACITY;
Â  Â  Â  Â  Â  Â  Â  Â  drawTransformed(shadowImg, Config.GRASS_SHADOW_OFFSET_X, Config.GRASS_SHADOW_OFFSET_Y, shadowOpacity);

Â  Â  Â  Â  Â  Â  Â  Â  // 2. Draw Blade (using the standard or pre-tinted image)
Â  Â  Â  Â  Â  Â  Â  Â  drawTransformed(img, 0, 0, bladeOpacity);

Â  Â  Â  Â  Â  Â  Â  Â  // Reset alpha for subsequent draws
Â  Â  Â  Â  Â  Â  Â  Â  ctx.globalAlpha = 1.0;
Â  Â  Â  Â  Â  Â  }


Â  Â  Â  Â  Â  Â  // --- WEAR AND TEAR (Dirt Paths) ---
Â  Â  Â  Â  Â  Â  applyMovementWear(startX, startY, endX, endY, buffManager) {
Â  Â  Â  Â  Â  Â  Â  Â  const distance = Utils.distance(startX, startY, endX, endY);
Â  Â  Â  Â  Â  Â  Â  Â  const steps = Math.ceil(distance / 5);
Â  Â  Â  Â  Â  Â  Â  Â  if (steps === 0) return;

Â  Â  Â  Â  Â  Â  Â  Â  const wanderDot = Game.instance.wanderDot; // Get reference to the dot

Â  Â  Â  Â  Â  Â  Â  Â  // Use the dot's calculated strength multiplier
Â  Â  Â  Â  Â  Â  Â  Â  let dirtWearMultiplier = Config.WEAR_PER_PIXEL * wanderDot.currentStrengthMultiplier;


Â  Â  Â  Â  Â  Â  Â  Â  // Determine wear radius (this logic remains here as it's about the area of effect)
Â  Â  Â  Â  Â  Â  Â  Â  const buffs = buffManager.getActiveBuffs();
Â  Â  Â  Â  Â  Â  Â  Â  let dirtWearRadius = 1;
Â  Â  Â  Â  Â  Â  Â  Â  if (buffs.pizza || buffs.mushroom) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  dirtWearRadius = 2;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  if (buffs.pizza && buffs.mushroom) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  dirtWearRadius = 3;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  const isHeavy = buffs.pizza || buffs.mushroom;
Â  Â  Â  Â  Â  Â  Â  Â  const currentDotRadius = wanderDot.radius;

Â  Â  Â  Â  Â  Â  Â  Â  // Define interaction radius for the animation effect
Â  Â  Â  Â  Â  Â  Â  Â  const interactionRadius = 35;

Â  Â  Â  Â  Â  Â  Â  Â  for (let i = 0; i <= steps; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const t = i / steps;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const currentX = Utils.lerp(startX, endX, t);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const currentY = Utils.lerp(startY, endY, t);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // 1. Apply Wear to Dirt Path
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.applyWearToArea(currentX, currentY, dirtWearRadius, (distance/steps) * dirtWearMultiplier);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // 2. Interact with Grass (Animation only)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.interactWithGrass(currentX, currentY, interactionRadius);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // 3. Entity Destruction while rolling
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (isHeavy) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.entityManager.removeDynamicEntitiesInArea(currentX, currentY, currentDotRadius);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  applyLandingImpact(x, y, moodState, buffManager) {
Â  Â  Â  Â  Â  Â  Â  Â  const wanderDot = Game.instance.wanderDot;

Â  Â  Â  Â  Â  Â  Â  Â  // Base impact wear multiplied by the dot's current strength (which includes mood/buffs)
Â  Â  Â  Â  Â  Â  Â  Â  let impactWear = Config.BASE_IMPACT_WEAR * wanderDot.currentStrengthMultiplier;


Â  Â  Â  Â  Â  Â  Â  Â  const buffs = buffManager.getActiveBuffs();
Â  Â  Â  Â  Â  Â  Â  Â  const isHeavy = buffs.pizza || buffs.mushroom;


Â  Â  Â  Â  Â  Â  Â  Â  if (moodState === 'mad') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Strength already includes the mad multiplier, so we just spawn particles.
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Game.instance.particleManager.spawnLandingParticles(x, y);
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  const impactRadius = 2.5;

Â  Â  Â  Â  Â  Â  Â  Â  // 1. Apply Wear to Dirt Path
Â  Â  Â  Â  Â  Â  Â  Â  this.applyWearToArea(x, y, impactRadius, impactWear, true);

Â  Â  Â  Â  Â  Â  Â  Â  // 2. Interact with Grass (Animation only)
Â  Â  Â  Â  Â  Â  Â  Â  const landingInteractionRadius = 60;
Â  Â  Â  Â  Â  Â  Â  Â  this.interactWithGrass(x, y, landingInteractionRadius);

Â  Â  Â  Â  Â  Â  Â  Â  // 3. Entity Destruction on impact
Â  Â  Â  Â  Â  Â  Â  Â  this.entityManager.removeMushroomInArea(x, y, Config.BASE_RADIUS * 2);

Â  Â  Â  Â  Â  Â  Â  Â  if (isHeavy) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const currentDotRadius = wanderDot.radius;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.entityManager.removeDynamicEntitiesInArea(x, y, currentDotRadius);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // UPDATED: Modified to ensure redraw happens on any wear change (for gradients).
Â  Â  Â  Â  Â  Â  applyWearToArea(x, y, radius, wearAmount, useFalloff = false) {
Â  Â  Â  Â  Â  Â  Â  Â  const centerX = Math.floor(x / Config.GRID_CELL_SIZE);
Â  Â  Â  Â  Â  Â  Â  Â  const centerY = Math.floor(y / Config.GRID_CELL_SIZE);
Â  Â  Â  Â  Â  Â  Â  Â  const radiusSq = radius * radius;

Â  Â  Â  Â  Â  Â  Â  Â  for (let i = -Math.ceil(radius); i <= Math.ceil(radius); i++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  for (let j = -Math.ceil(radius); j <= Math.ceil(radius); j++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const distSq = i * i + j * j;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (!useFalloff && distSq > radiusSq) continue;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const distance = Math.sqrt(distSq);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (useFalloff && distance > radius) continue;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const gridX = centerX + i;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const gridY = centerY + j;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.isValidCell(gridX, gridY)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const cell = this.pathGrid[gridX][gridY];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const oldWear = cell.wear;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let effectiveWear = wearAmount;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (useFalloff) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const falloff = 1 - (distance / radius);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  effectiveWear *= falloff;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  cell.wear = Math.min(Config.MAX_WEAR, cell.wear + effectiveWear);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // UPDATED: Redraw cell if wear changed (needed for gradients), but only spawn entities on significant change.
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (cell.wear !== oldWear) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.drawPathCell(gridX, gridY);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Keep entity spawn optimization
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (Math.floor(cell.wear) > Math.floor(oldWear)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.trySpawnEntity(gridX, gridY, cell);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // --- RENDERING & SPAWNING ---

Â  Â  Â  Â  Â  Â  // UPDATED: Uses radial gradients with improved blending for softer edges on paths and alien mist.
Â  Â  Â  Â  Â  Â  drawPathCell(gridX, gridY) {
Â  Â  Â  Â  Â  Â  Â  Â  const cell = this.pathGrid[gridX][gridY];
Â  Â  Â  Â  Â  Â  Â  Â  const wearRatio = cell.wear / Config.MAX_WEAR;
Â  Â  Â  Â  Â  Â  Â  Â  let baseColor, targetColor;
Â  Â  Â  Â  Â  Â  Â  Â  let baseOpacity = 0;

Â  Â  Â  Â  Â  Â  Â  Â  // Define the visual impact radius of the gradient
Â  Â  Â  Â  Â  Â  Â  Â  const cellSize = Config.GRID_CELL_SIZE;

Â  Â  Â  Â  Â  Â  Â  Â  // UPDATED: Increased radius for better overlap and blending, especially for mist.
Â  Â  Â  Â  Â  Â  Â  Â  // We need a radius slightly larger than the distance to the corner (approx 0.707 * cellSize) to ensure good overlap.
Â  Â  Â  Â  Â  Â  Â  Â  const gradientRadius = cellSize * 0.85; // Increased from 0.8

Â  Â  Â  Â  Â  Â  Â  Â  const centerX = gridX * cellSize + cellSize / 2;
Â  Â  Â  Â  Â  Â  Â  Â  const centerY = gridY * cellSize + cellSize / 2;

Â  Â  Â  Â  Â  Â  Â  Â  switch (cell.terrainType) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  case TerrainType.ALIEN_BLUE:
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  baseColor = Config.COLOR_ALIEN_BLUE;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  targetColor = Config.COLOR_DIRT;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  baseOpacity = cell.mistOpacity ?? 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  case TerrainType.ALIEN_CLAY:
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Clay remains relatively sharp
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  baseColor = Config.COLOR_DIRT;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  targetColor = Config.COLOR_ALIEN_CLAY;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  baseOpacity = 0.2;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  case TerrainType.NORMAL:
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  default:
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  baseColor = Config.COLOR_FIELD;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  targetColor = Config.COLOR_DIRT;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // 1. Calculate the resulting color and opacity based on wear.
Â  Â  Â  Â  Â  Â  Â  Â  // pathColor is an RGB string: "rgb(r, g, b)"
Â  Â  Â  Â  Â  Â  Â  Â  const pathColor = Utils.lerpColor(baseColor, targetColor, wearRatio);
Â  Â  Â  Â  Â  Â  Â  Â  // pathOpacity is a float: 0.0 to 1.0
Â  Â  Â  Â  Â  Â  Â  Â  const pathOpacity = Math.max(wearRatio * 0.8, baseOpacity);

Â  Â  Â  Â  Â  Â  Â  Â  // Clear the existing cell area before redrawing. This is crucial for correct opacity blending.
Â  Â  Â  Â  Â  Â  Â  Â  this.pathCtx.clearRect(gridX * cellSize, gridY * cellSize, cellSize, cellSize);

Â  Â  Â  Â  Â  Â  Â  Â  // Optimization for ALIEN_CLAY or very high wear: use fillRect as it's fully opaque/sharp anyway
Â  Â  Â  Â  Â  Â  Â  Â  // This also ensures Clay looks distinct from regular dirt.
Â  Â  Â  Â  Â  Â  Â  Â  if (cell.terrainType === TerrainType.ALIEN_CLAY || wearRatio >= 0.99) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.pathCtx.fillStyle = pathColor;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.pathCtx.globalAlpha = pathOpacity;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.pathCtx.fillRect(gridX * cellSize, gridY * cellSize, cellSize, cellSize);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.pathCtx.globalAlpha = 1.0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // 2. Create the radial gradient.

Â  Â  Â  Â  Â  Â  Â  Â  // The gradient fades from the calculated color/opacity at the center
Â  Â  Â  Â  Â  Â  Â  Â  // to the same color but with 0 opacity at the edges.

Â  Â  Â  Â  Â  Â  Â  Â  const centerColorRGBA = Utils.rgbStringToRGBA(pathColor, pathOpacity);
Â  Â  Â  Â  Â  Â  Â  Â  // The edge color uses the same RGB components but 0 alpha.
Â  Â  Â  Â  Â  Â  Â  Â  const edgeColorRGBA = Utils.rgbStringToRGBA(pathColor, 0);


Â  Â  Â  Â  Â  Â  Â  Â  const gradient = this.pathCtx.createRadialGradient(centerX, centerY, 0, centerX, centerY, gradientRadius);

Â  Â  Â  Â  Â  Â  Â  Â  // Define the gradient falloff profile
Â  Â  Â  Â  Â  Â  Â  Â  gradient.addColorStop(0, centerColorRGBA);

Â  Â  Â  Â  Â  Â  Â  Â  // UPDATED: Use different profiles for mist vs dirt/wear.
Â  Â  Â  Â  Â  Â  Â  Â  let solidCoreRatio;

Â  Â  Â  Â  Â  Â  Â  Â  // Check if we are primarily rendering mist (low wear on ALIEN_BLUE)
Â  Â  Â  Â  Â  Â  Â  Â  if (cell.terrainType === TerrainType.ALIEN_BLUE && wearRatio < 0.3) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Mist Profile: Softer, fades almost immediately from the center to break the grid pattern.
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  solidCoreRatio = 0.1;
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Dirt Profile: Standard wear-based core.
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  solidCoreRatio = Math.min(0.7, wearRatio * 0.7 + 0.3);
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  gradient.addColorStop(solidCoreRatio, centerColorRGBA);

Â  Â  Â  Â  Â  Â  Â  Â  gradient.addColorStop(1, edgeColorRGBA);

Â  Â  Â  Â  Â  Â  Â  Â  // 3. Draw the gradient onto the canvas.
Â  Â  Â  Â  Â  Â  Â  Â  this.pathCtx.fillStyle = gradient;
Â  Â  Â  Â  Â  Â  Â  Â  // We fill the entire cell area. The gradient handles the shaping and opacity.
Â  Â  Â  Â  Â  Â  Â  Â  // Note: We don't use globalAlpha here because the gradient stops define the alpha.
Â  Â  Â  Â  Â  Â  Â  Â  this.pathCtx.fillRect(gridX * cellSize, gridY * cellSize, cellSize, cellSize);
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  trySpawnEntity(gridX, gridY, cell) {
Â  Â  Â  Â  Â  Â  Â  Â  if (cell.hasPebble) return;

Â  Â  Â  Â  Â  Â  Â  Â  if (cell.terrainType === TerrainType.ALIEN_CLAY && Math.random() < 0.005) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const x = gridX * Config.GRID_CELL_SIZE + Utils.randomRange(2, Config.GRID_CELL_SIZE - 2);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const y = gridY * Config.GRID_CELL_SIZE + Utils.randomRange(2, Config.GRID_CELL_SIZE - 2);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.entityManager.addEntity('diamond', x, y);
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  if (cell.wear > Config.PEBBLE_SPAWN_THRESHOLD) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let spawnChance = 0.01;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let pebbleType = 'normal';

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (cell.terrainType === TerrainType.ALIEN_BLUE) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  spawnChance = 0.03;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  pebbleType = 'spaceRock';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else if (cell.terrainType === TerrainType.ALIEN_CLAY) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  spawnChance = 0.008;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (Math.random() < spawnChance) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.spawnPebble(gridX, gridY, pebbleType);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  cell.hasPebble = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  spawnPebble(gridX, gridY, type) {
Â  Â  Â  Â  Â  Â  Â  Â  let colors, chars;

Â  Â  Â  Â  Â  Â  Â  Â  if (type === 'spaceRock') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  colors = ['#4B0082', '#6A0DAD', '#551A8B'];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  chars = ['*', 'o', 'O', '.:', '.:.'];
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  colors = ['#000000', '#1C1C1C', '#2A1A10', '#3D2B1F'];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  chars = ['..', '.-.', ".;'", '-_,`', ':'];
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  const pebble = {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  x: gridX * Config.GRID_CELL_SIZE + Math.random() * Config.GRID_CELL_SIZE,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  y: gridY * Config.GRID_CELL_SIZE + Math.random() * Config.GRID_CELL_SIZE,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  char: Utils.randomChoice(chars),
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  color: Utils.randomChoice(colors),
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  type: type
Â  Â  Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  Â  Â  this.entityManager.addPebble(pebble);
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  spawnMushroom(gridX, gridY) {
Â  Â  Â  Â  Â  Â  Â  Â  const mushroom = {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  x: gridX * Config.GRID_CELL_SIZE + (Config.GRID_CELL_SIZE / 2),
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  y: gridY * Config.GRID_CELL_SIZE + (Config.GRID_CELL_SIZE / 2),
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  gridX, gridY
Â  Â  Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  Â  Â  return this.entityManager.addMushroom(mushroom);
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // NEW: Update loop for mist decay
Â  Â  Â  Â  Â  Â  updateMistDecay(deltaTime) {
Â  Â  Â  Â  Â  Â  Â  Â  const decayAmount = Config.MIST_DECAY_PER_SECOND * deltaTime;

Â  Â  Â  Â  Â  Â  Â  Â  // Iterate through the grid to find active mist.
Â  Â  Â  Â  Â  Â  Â  Â  for (let i = 0; i < this.pathGrid.length; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  for (let j = 0; j < (this.pathGrid[i]?.length || 0); j++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const cell = this.pathGrid[i][j];

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (cell.terrainType === TerrainType.ALIEN_BLUE && cell.mistOpacity > 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  cell.mistOpacity = Math.max(0, cell.mistOpacity - decayAmount);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Check if it should revert to NORMAL
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // It reverts if mist is gone AND wear is low enough (still grassy).
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (cell.mistOpacity <= 0.01 && cell.wear < Config.GRASS_REMOVAL_THRESHOLD) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  cell.terrainType = TerrainType.NORMAL;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  cell.mistOpacity = 0; // Ensure it's zeroed out
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Revert the grass blades in this area back to green
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.revertGrassBlades(i, j);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Redraw the cell because opacity or type changed
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.drawPathCell(i, j);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // NEW: Helper method to revert grass blades when terrain changes back to NORMAL
Â  Â  Â  Â  Â  Â  revertGrassBlades(gridX, gridY) {
Â  Â  Â  Â  Â  Â  Â  Â  // Determine the pixel bounds of the pathGrid cell
Â  Â  Â  Â  Â  Â  Â  Â  const cellSize = Config.GRID_CELL_SIZE;
Â  Â  Â  Â  Â  Â  Â  Â  const minX = gridX * cellSize;
Â  Â  Â  Â  Â  Â  Â  Â  const maxX = (gridX + 1) * cellSize;
Â  Â  Â  Â  Â  Â  Â  Â  const minY = gridY * cellSize;
Â  Â  Â  Â  Â  Â  Â  Â  const maxY = (gridY + 1) * cellSize;

Â  Â  Â  Â  Â  Â  Â  Â  // Calculate the spatial grid cells that overlap this pathGrid cell.
Â  Â  Â  Â  Â  Â  Â  Â  const spatialSize = Config.SPATIAL_GRID_SIZE;
Â  Â  Â  Â  Â  Â  Â  Â  const minSGX = Math.max(0, Math.floor(minX / spatialSize));
Â  Â  Â  Â  Â  Â  Â  Â  const maxSGX = Math.min(this.gridWidth - 1, Math.floor((maxX - 1) / spatialSize));
Â  Â  Â  Â  Â  Â  Â  Â  const minSGY = Math.max(0, Math.floor(minY / spatialSize));
Â  Â  Â  Â  Â  Â  Â  Â  const maxSGY = Math.min(this.gridHeight - 1, Math.floor((maxY - 1) / spatialSize));

Â  Â  Â  Â  Â  Â  Â  Â  for (let sgx = minSGX; sgx <= maxSGX; sgx++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  for (let sgy = minSGY; sgy <= maxSGY; sgy++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Safety check (redundant due to Math.max/min above, but robust)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (sgx >= 0 && sgx < this.gridWidth && sgy >= 0 && sgy < this.gridHeight) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const cellBlades = this.spatialGrid[sgx][sgy];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  for (const blade of cellBlades) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Crucial: Double check the blade is actually within the specific pathGrid cell bounds
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (blade.isAlien && blade.x >= minX && blade.x < maxX && blade.y >= minY && blade.y < maxY) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â blade.isAlien = false;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }


Â  Â  Â  Â  Â  Â  // --- UFO/ALIEN TERRAFORMING ---
Â  Â  Â  Â  Â  Â  // UPDATED: Must maintain spatial grid when removing blades.
Â  Â  Â  Â  Â  Â  alterGround(x, y) {
Â  Â  Â  Â  Â  Â  Â  Â  const centerX = Math.floor(x / Config.GRID_CELL_SIZE);
Â  Â  Â  Â  Â  Â  Â  Â  const centerY = Math.floor(y / Config.GRID_CELL_SIZE);
Â  Â  Â  Â  Â  Â  Â  Â  const alterRadius = 3;
Â  Â  Â  Â  Â  Â  Â  Â  const alterationPixelRadius = alterRadius * Config.GRID_CELL_SIZE;

Â  Â  Â  Â  Â  Â  Â  Â  // 1. Update the underlying Path Grid
Â  Â  Â  Â  Â  Â  Â  Â  for(let i = -alterRadius; i <= alterRadius; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  for (let j = -alterRadius; j <= alterRadius; j++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const distSq = i*i + j*j;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (distSq > alterRadius * alterRadius) continue;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const gridX = centerX + i;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const gridY = centerY + j;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.isValidCell(gridX, gridY)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const cell = this.pathGrid[gridX][gridY];

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const isGrass = cell.wear < Config.GRASS_REMOVAL_THRESHOLD;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const targetType = isGrass ? TerrainType.ALIEN_BLUE : TerrainType.ALIEN_CLAY;


Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (targetType === TerrainType.ALIEN_BLUE) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const distance = Math.sqrt(distSq);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const falloff = 1 - (distance / alterRadius);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const newOpacity = Utils.clamp(falloff * Utils.randomRange(0.2, 0.5), 0.1, 0.5);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  cell.mistOpacity = Math.max(cell.mistOpacity, newOpacity);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (cell.terrainType !== targetType) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  cell.terrainType = targetType;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.drawPathCell(gridX, gridY);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Spawn Mushrooms
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if(targetType === TerrainType.ALIEN_BLUE && Math.random() < Config.UFO_MUSHROOM_CHANCE) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.spawnMushroom(gridX, gridY);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // 2. Update Grass Blades based on new terrain
Â  Â  Â  Â  Â  Â  Â  Â  const radiusSq = alterationPixelRadius * alterationPixelRadius;
Â  Â  Â  Â  Â  Â  Â  Â  Â // Iterate backwards through the master list for safe removal.
Â  Â  Â  Â  Â  Â  Â  Â  for (let i = this.grassBlades.length - 1; i >= 0; i--) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const blade = this.grassBlades[i];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const distSq = (blade.x - x)**2 + (blade.y - y)**2;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (distSq < radiusSq) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Check the new terrain type at the blade's specific location
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const terrainInfo = this.getTerrainInfoAtPoint(blade.x, blade.y);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (terrainInfo.type === TerrainType.ALIEN_BLUE) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Transform to alien grass (sets flag for rendering)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  blade.isAlien = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else if (terrainInfo.type === TerrainType.ALIEN_CLAY) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Remove grass on clay
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Remove from master list
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.grassBlades.splice(i, 1);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // NEW: Remove from spatial grid
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.removeBladeFromSpatialGrid(blade);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  // Note: Since we only removed items and didn't change Y positions, the master list remains sorted.
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  // ====================================================================
Â  Â  Â  Â  // 3. WANDERDOT (The Circle, Mood, and Behavior)
Â  Â  Â  Â  // ====================================================================

Â  Â  Â  Â  // (WanderDot implementation remains unchanged)
Â  Â  Â  Â  class WanderDot {
Â  Â  Â  Â  Â  Â  constructor(x, y) {
Â  Â  Â  Â  Â  Â  Â  Â  this.x = x;
Â  Â  Â  Â  Â  Â  Â  Â  this.y = y;
Â  Â  Â  Â  Â  Â  Â  Â  this.previousX = x;
Â  Â  Â  Â  Â  Â  Â  Â  this.previousY = y;

Â  Â  Â  Â  Â  Â  Â  Â  this.radius = Config.BASE_RADIUS;
Â  Â  Â  Â  Â  Â  Â  Â  this.color = Utils.lerpColor(Config.COLOR_NORMAL, Config.COLOR_NORMAL, 0);

Â  Â  Â  Â  Â  Â  Â  Â  this.speed = Config.BASE_SPEED;
Â  Â  Â  Â  Â  Â  Â  Â  this.currentSpeedMultiplier = 1.0;

Â  Â  Â  Â  Â  Â  Â  Â  // Stats
Â  Â  Â  Â  Â  Â  Â  Â  this.baseStrength = 1.0; // Base wear multiplier
Â  Â  Â  Â  Â  Â  Â  Â  this.currentStrengthMultiplier = 1.0;

Â  Â  Â  Â  Â  Â  Â  Â  this.dx = (Math.random() - 0.5) * 2;
Â  Â  Â  Â  Â  Â  Â  Â  this.dy = (Math.random() - 0.5) * 2;
Â  Â  Â  Â  Â  Â  Â  Â  this.targetX = null;
Â  Â  Â  Â  Â  Â  Â  Â  this.targetY = null;

Â  Â  Â  Â  Â  Â  Â  Â  // Mood state
Â  Â  Â  Â  Â  Â  Â  Â  this.annoyance = 0;
Â  Â  Â  Â  Â  Â  Â  Â  this.currentMoodState = 'normal';
Â  Â  Â  Â  Â  Â  Â  Â  this.isCalm = false;
Â  Â  Â  Â  Â  Â  Â  Â  this.isHangry = false;
Â  Â  Â  Â  Â  Â  Â  Â  this.isInterruptedHangry = false;

Â  Â  Â  Â  Â  Â  Â  Â  // Hunger state
Â  Â  Â  Â  Â  Â  Â  Â  this.hunger = Config.MAX_HUNGER;

Â  Â  Â  Â  Â  Â  Â  Â  // Behavior state
Â  Â  Â  Â  Â  Â  Â  Â  this.isEating = false;
Â  Â  Â  Â  Â  Â  Â  Â  this.eatingStartTime = 0;
Â  Â  Â  Â  Â  Â  Â  Â  this.eatingTarget = null;

Â  Â  Â  Â  Â  Â  Â  Â  // Bounce state
Â  Â  Â  Â  Â  Â  Â  Â  this.distanceTraveledOnCurrentBounce = 0;
Â  Â  Â  Â  Â  Â  Â  Â  this.jiggleEndTime = 0;
Â  Â  Â  Â  Â  Â  Â  Â  this.verticalOffset = 0;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // Returns the Y coordinate of the bottom of the dot for sorting purposes.
Â  Â  Â  Â  Â  Â  getBaseY() {
Â  Â  Â  Â  Â  Â  Â  Â  return this.y - this.verticalOffset + this.radius;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // Method to apply immediate mood boost
Â  Â  Â  Â  Â  Â  applyMoodBoost(amount) {
Â  Â  Â  Â  Â  Â  Â  Â  // Amount is positive, representing a decrease in annoyance
Â  Â  Â  Â  Â  Â  Â  Â  this.annoyance = Math.max(0, this.annoyance - amount);
Â  Â  Â  Â  Â  Â  }


Â  Â  Â  Â  Â  Â  setTarget(x, y) {
Â  Â  Â  Â  Â  Â  Â  Â  if (this.isHangry) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return false;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // If the dot is currently chewing (eatingStartTime > 0), interrupting it triggers Hangry
Â  Â  Â  Â  Â  Â  Â  Â  if (this.isEating && this.eatingStartTime > 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Specify interruption cause
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.triggerHangry(true);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return false;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  this.targetX = x;
Â  Â  Â  Â  Â  Â  Â  Â  this.targetY = y;
Â  Â  Â  Â  Â  Â  Â  Â  return true;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  triggerHangry(causedByInterruption = false) {
Â  Â  Â  Â  Â  Â  Â  Â  this.isHangry = true;

Â  Â  Â  Â  Â  Â  Â  Â  // Set specific Hangry type based on cause
Â  Â  Â  Â  Â  Â  Â  Â  if (causedByInterruption) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.isInterruptedHangry = true;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  Â // If triggered by low hunger, annoyance might not be high yet.
Â  Â  Â  Â  Â  Â  Â  Â  if (this.hunger < Config.HANGRY_HUNGER_THRESHOLD && !causedByInterruption) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Ensure annoyance is high enough to look significantly annoyed/mad.
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.annoyance = Math.max(this.annoyance, Config.ANNOYANCE_THRESHOLD + 5);
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // If triggered by interruption (or already very mad), ensure annoyance is very high (MAD)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.annoyance = Math.max(this.annoyance, Config.MAD_THRESHOLD + 1);
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // Reset eating state
Â  Â  Â  Â  Â  Â  Â  Â  this.isEating = false;
Â  Â  Â  Â  Â  Â  Â  Â  this.eatingTarget = null;
Â  Â  Â  Â  Â  Â  Â  Â  this.eatingStartTime = 0;
Â  Â  Â  Â  Â  Â  Â  Â  this.clearTarget();
Â  Â  Â  Â  Â  Â  Â  Â  // Show angry thought bubble immediately
Â  Â  Â  Â  Â  Â  Â  Â  Game.instance.uiManager.showThought(Utils.randomChoice(Config.Emojis.mad));
Â  Â  Â  Â  Â  Â  }


Â  Â  Â  Â  Â  Â  clearTarget() {
Â  Â  Â  Â  Â  Â  Â  Â  this.targetX = null;
Â  Â  Â  Â  Â  Â  Â  Â  this.targetY = null;
Â  Â  Â  Â  Â  Â  Â  Â  this.distanceTraveledOnCurrentBounce = 0;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  update(deltaTime, bounds, buffManager, worldManager, entityManager) {
Â  Â  Â  Â  Â  Â  Â  Â  this.updateMood(deltaTime, buffManager, entityManager); // Pass entityManager
Â  Â  Â  Â  Â  Â  Â  Â  this.updatePosition(deltaTime, bounds, buffManager, worldManager, entityManager);
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // --- MOOD & HUNGER LOGIC ---
Â  Â  Â  Â  Â  Â  getMoodState(annoyanceValue) {
Â  Â  Â  Â  Â  Â  Â  Â  if (annoyanceValue > Config.MAD_THRESHOLD) return 'mad';
Â  Â  Â  Â  Â  Â  Â  Â  if (annoyanceValue > Config.ANNOYANCE_THRESHOLD) return 'annoyed';
Â  Â  Â  Â  Â  Â  Â  Â  return 'normal';
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  addAnnoyance(amount, isDirectClick) {
Â  Â  Â  Â  Â  Â  Â  Â  let annoyanceToAdd = amount;

Â  Â  Â  Â  Â  Â  Â  Â  if (this.isCalm) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  annoyanceToAdd = 1.2;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.isCalm = false;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  if (isDirectClick) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  annoyanceToAdd *= 1.1;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  this.annoyance = Math.min(100, this.annoyance + annoyanceToAdd);
Â  Â  Â  Â  Â  Â  Â  Â  return this.getReactionEmoji(isDirectClick);
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  getReactionEmoji(isDirectClick) {
Â  Â  Â  Â  Â  Â  Â  Â  Â if (isDirectClick) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const levels = [20, 30, 45, 60, 75, 90];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let level = Config.Emojis.directClick.length - 1;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  for (let i = 0; i < levels.length; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.annoyance < levels[i]) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  level = i;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return Config.Emojis.directClick[level];
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.annoyance > Config.MAD_THRESHOLD) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return Utils.randomChoice(Config.Emojis.mad);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else if (this.annoyance > Config.ANNOYANCE_THRESHOLD) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return Utils.randomChoice(Config.Emojis.annoyed);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return Utils.randomChoice(Config.Emojis.commandReceived);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  updateHunger(deltaTime) {
Â  Â  Â  Â  Â  Â  Â  Â  if (this.hunger > 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let decayRate = Config.HUNGER_DECAY_PER_SECOND;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Increase decay rate if mood is bad
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.currentMoodState === 'mad' || this.currentMoodState === 'annoyed') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  decayRate *= Config.MOOD_HUNGER_DRAIN_MULTIPLIER;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.hunger = Math.max(0, this.hunger - decayRate * deltaTime);
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // Check if hunger triggers Hangry state
Â  Â  Â  Â  Â  Â  Â  Â  if (this.hunger < Config.HANGRY_HUNGER_THRESHOLD && !this.isHangry) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Triggered by hunger, not interruption
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.triggerHangry(false);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // UPDATED: Includes natural decay and flower restoration.
Â  Â  Â  Â  Â  Â  updateMood(deltaTime, buffManager, entityManager) {
Â  Â  Â  Â  Â  Â  Â  Â  // 1. Hunger decay
Â  Â  Â  Â  Â  Â  Â  Â  this.updateHunger(deltaTime);

Â  Â  Â  Â  Â  Â  Â  Â  // 2. Natural Mood Decay (Annoyance Increase) (NEW)
Â  Â  Â  Â  Â  Â  Â  Â  // Mood decays unless the dot is currently eating (chewing phase)
Â  Â  Â  Â  Â  Â  Â  Â  if (!(this.isEating && this.eatingStartTime > 0)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â this.annoyance = Math.min(100, this.annoyance + Config.MOOD_DECAY_PER_SECOND * deltaTime);
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // 3. Mood Restoration (Annoyance Decrease)
Â  Â  Â  Â  Â  Â  Â  Â  let restorationRate = 0;

Â  Â  Â  Â  Â  Â  Â  Â  // 3a. Check for nearby flowers (NEW)
Â  Â  Â  Â  Â  Â  Â  Â  const nearbyFlowers = entityManager.getNearbyDynamicEntities('flower', this.x, this.y, Config.MOOD_BOOST_FLOWER_RADIUS);
Â  Â  Â  Â  Â  Â  Â  Â  if (nearbyFlowers.length > 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Apply boost based on the rate
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  restorationRate += Config.MOOD_BOOST_FLOWER_RATE;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // Apply the calculated restoration rate
Â  Â  Â  Â  Â  Â  Â  Â  if (restorationRate > 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Apply hunger penalty to restoration rate
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.hunger < Config.HANGRY_HUNGER_THRESHOLD) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â restorationRate *= Config.HUNGER_MOOD_DRAIN_MULTIPLIER;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.annoyance = Math.max(0, this.annoyance - restorationRate * deltaTime);
Â  Â  Â  Â  Â  Â  Â  Â  }


Â  Â  Â  Â  Â  Â  Â  Â  // 4. State Change Detection
Â  Â  Â  Â  Â  Â  Â  Â  const previousState = this.currentMoodState;
Â  Â  Â  Â  Â  Â  Â  Â  this.currentMoodState = this.getMoodState(this.annoyance);

Â  Â  Â  Â  Â  Â  Â  Â  let transitionEmoji = null;
Â  Â  Â  Â  Â  Â  Â  Â  if (this.currentMoodState !== previousState) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (previousState === 'mad' && this.currentMoodState === 'annoyed') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  transitionEmoji = Config.Emojis.cooldownToAnnoyed[0];

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Exit Hangry state ONLY IF hunger is sufficient AND annoyance cooled down
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.isHangry && this.hunger >= Config.HANGRY_HUNGER_THRESHOLD) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.isHangry = false;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.isInterruptedHangry = false; // Clear interruption flag
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else if (previousState === 'annoyed' && this.currentMoodState === 'normal') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â this.isCalm = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â transitionEmoji = Config.Emojis.cooldownToNormal[0];

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â // Exit Hangry state if returning to normal (should be covered above but safe check)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â if (this.isHangry && this.hunger >= Config.HANGRY_HUNGER_THRESHOLD) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.isHangry = false;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.isInterruptedHangry = false; // Clear interruption flag
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // 5. Ensure Hangry state persists if hunger is low, even if annoyance cools slightly
Â  Â  Â  Â  Â  Â  Â  Â  if (this.hunger < Config.HANGRY_HUNGER_THRESHOLD && !this.isHangry) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.triggerHangry(false); // Caused by hunger
Â  Â  Â  Â  Â  Â  Â  Â  }


Â  Â  Â  Â  Â  Â  Â  Â  // 6. Appearance and Speed Update
Â  Â  Â  Â  Â  Â  Â  Â  this.updateAppearance(buffManager);

Â  Â  Â  Â  Â  Â  Â  Â  return transitionEmoji;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // UPDATED: Added Kangaroo color override
Â  Â  Â  Â  Â  Â  updateAppearance(buffManager) {
Â  Â  Â  Â  Â  Â  Â  Â  const buffs = buffManager.getActiveBuffs();

Â  Â  Â  Â  Â  Â  Â  Â  let speed = Config.BASE_SPEED;
Â  Â  Â  Â  Â  Â  Â  Â  let radius = Config.BASE_RADIUS;
Â  Â  Â  Â  Â  Â  Â  Â  let strength = this.baseStrength; // Start with base strength

Â  Â  Â  Â  Â  Â  Â  Â  // --- Apply Buffs ---
Â  Â  Â  Â  Â  Â  Â  Â  if (buffs.coffee) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  speed *= (1 + 0.3 * buffs.coffee.potency);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  strength *= (1 + 1.0 * buffs.coffee.potency); // Coffee increases strength (wear)
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  if (buffs.pizza) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  radius *= (1 + 0.3 * buffs.pizza.potency);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  if (buffs.mushroom) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  radius *= (1 + 0.3 * buffs.mushroom.potency);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  strength *= (1 + 1.0 * buffs.mushroom.potency); // Mushroom increases strength (wear)
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  Â if (buffs.kangaroo) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Reflect the potential impact strength in the UI
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  strength *= (1 + 0.3 * buffs.kangaroo.potency);
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // --- Apply Mood/Color/Speed Multiplier ---
Â  Â  Â  Â  Â  Â  Â  Â  Â if (this.annoyance > Config.MAD_THRESHOLD) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.color = Utils.lerpColor(Config.COLOR_MAD, Config.COLOR_MAD, 0);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.currentSpeedMultiplier = 0.3;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  strength *= 1.7; // Mad increases strength significantly
Â  Â  Â  Â  Â  Â  Â  Â  } else if (this.annoyance > Config.ANNOYANCE_THRESHOLD) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const t = (this.annoyance - Config.ANNOYANCE_THRESHOLD) / (Config.MAD_THRESHOLD - Config.ANNOYANCE_THRESHOLD);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.color = Utils.lerpColor(Config.COLOR_ANNOYED, Config.COLOR_MAD, t);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.currentSpeedMultiplier = Utils.lerp(0.5, 0.3, t);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  strength *= Utils.lerp(1.1, 1.7, t); // Annoyed slightly increases strength
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Normal State
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const t = this.annoyance / Config.ANNOYANCE_THRESHOLD;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // this.color = Utils.lerpColor(Config.COLOR_NORMAL, Config.COLOR_ANNOYED, t); // Old implementation
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.currentSpeedMultiplier = Utils.lerp(1.0, 0.5, t);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // NEW: Kangaroo Happy Mood Override
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (buffs.kangaroo) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Use the HAPPY color as the base when kangaroo is active, still interpolating towards annoyed if annoyance rises.
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.color = Utils.lerpColor(Config.COLOR_HAPPY, Config.COLOR_ANNOYED, t);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.color = Utils.lerpColor(Config.COLOR_NORMAL, Config.COLOR_ANNOYED, t);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  Â // Assign final stats
Â  Â  Â  Â  Â  Â  Â  Â  this.speed = speed;
Â  Â  Â  Â  Â  Â  Â  Â  this.radius = radius;
Â  Â  Â  Â  Â  Â  Â  Â  this.currentStrengthMultiplier = strength;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // --- MOVEMENT & BEHAVIOR LOGIC ---
Â  Â  Â  Â  Â  Â  // (updatePosition, handleEatingBehavior, moveToTarget, wander, handleBounce, land, handleBoundaries remain unchanged)
Â  Â  Â  Â  Â  Â  updatePosition(deltaTime, bounds, buffManager, worldManager, entityManager) {
Â  Â  Â  Â  Â  Â  Â  Â  this.previousX = this.x;
Â  Â  Â  Â  Â  Â  Â  Â  this.previousY = this.y;

Â  Â  Â  Â  Â  Â  Â  Â  // 1. Determine behavior and direction
Â  Â  Â  Â  Â  Â  Â  Â  let movementAllowed = true;

Â  Â  Â  Â  Â  Â  Â  Â  // Check if eating target still exists
Â  Â  Â  Â  Â  Â  Â  Â  if (this.isEating && this.eatingStartTime === 0 && this.eatingTarget && !entityManager.mushrooms.includes(this.eatingTarget)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.eatingTarget = null;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.isEating = false;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.clearTarget();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Hide the seeking thought if it was active
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (Game.instance.uiManager.getCurrentThought() === Config.Emojis.EATING_SEEKING) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Game.instance.uiManager.hideThought();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  if (this.isEating) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  movementAllowed = this.handleEatingBehavior(entityManager, buffManager);
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  if (movementAllowed) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.targetX !== null) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.moveToTarget();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.wander(entityManager, buffManager);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Force stop when chewing
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.dx = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.dy = 0;
Â  Â  Â  Â  Â  Â  Â  Â  }


Â  Â  Â  Â  Â  Â  Â  Â  // 2. Calculate movement distance
Â  Â  Â  Â  Â  Â  Â  Â  const buffs = buffManager.getActiveBuffs();
Â  Â  Â  Â  Â  Â  Â  Â  let effectiveSpeed = this.speed * this.currentSpeedMultiplier;

Â  Â  Â  Â  Â  Â  Â  Â  if (buffs.kangaroo) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  effectiveSpeed = Config.BASE_SPEED * (buffs.kangaroo.isEureka ? 1.3 : 1.0);
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  const distanceMoved = effectiveSpeed * deltaTime;

Â  Â  Â  Â  Â  Â  Â  Â  // 3. Apply movement
Â  Â  Â  Â  Â  Â  Â  Â  this.x += this.dx * distanceMoved;
Â  Â  Â  Â  Â  Â  Â  Â  this.y += this.dy * distanceMoved;

Â  Â  Â  Â  Â  Â  Â  Â  // 4. Handle World Interaction
Â  Â  Â  Â  Â  Â  Â  Â  if (buffs.kangaroo) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.handleBounce(distanceMoved, buffManager, worldManager);
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.verticalOffset = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (movementAllowed) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â // This uses the centralized strength stat now
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â worldManager.applyMovementWear(this.previousX, this.previousY, this.x, this.y, buffManager);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // 5. Boundary Collision
Â  Â  Â  Â  Â  Â  Â  Â  if (movementAllowed) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.handleBoundaries(bounds);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  handleEatingBehavior(entityManager, buffManager) {
Â  Â  Â  Â  Â  Â  Â  Â  const uiManager = Game.instance.uiManager;

Â  Â  Â  Â  Â  Â  Â  Â  // Stage 1: Moving towards the mushroom (Seeking)
Â  Â  Â  Â  Â  Â  Â  Â  if (this.targetX !== null) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (uiManager.getCurrentThought() !== Config.Emojis.EATING_SEEKING) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  uiManager.showThought(Config.Emojis.EATING_SEEKING, 60000);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return true; // Allow movement
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // Stage 2: Reached the mushroom, start chewing animation
Â  Â  Â  Â  Â  Â  Â  Â  if (this.eatingStartTime === 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.eatingStartTime = Date.now();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Consume the mushroom from the world
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.eatingTarget) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  entityManager.removeMushroomByObject(this.eatingTarget);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.eatingTarget = null; // Target is now consumed/held
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  uiManager.showThought(Config.Emojis.EATING_CONSUMING, Config.EAT_DURATION + 500);
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  const elapsed = Date.now() - this.eatingStartTime;
Â  Â  Â  Â  Â  Â  Â  Â  const remaining = Config.EAT_DURATION - elapsed;

Â  Â  Â  Â  Â  Â  Â  Â  // Stage 3: Check if chewing is done
Â  Â  Â  Â  Â  Â  Â  Â  if (remaining <= 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.isEating = false;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.eatingStartTime = 0;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Restore Hunger
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.hunger = Math.min(Config.MAX_HUNGER, this.hunger + Config.MUSHROOM_HUNGER_RESTORE);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Apply the buff
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  buffManager.addBuffTime('mushroom', Config.MUSHROOM_BUFF_DURATION);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Show satisfied thought bubble
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  uiManager.showThought(Config.Emojis.EATING_SATISFIED, 2000);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return true; // Allow movement again
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // Update thought bubble with timer during chewing
Â  Â  Â  Â  Â  Â  Â  Â  const remainingSeconds = Math.ceil(remaining / 1000);
Â  Â  Â  Â  Â  Â  Â  Â  uiManager.updateThoughtContent(`${Config.Emojis.EATING_CONSUMING} ${remainingSeconds}s`, true);

Â  Â  Â  Â  Â  Â  Â  Â  return false; // Prevent movement while chewing
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  moveToTarget() {
Â  Â  Â  Â  Â  Â  Â  Â  const targetX = this.targetX;
Â  Â  Â  Â  Â  Â  Â  Â  const targetY = this.targetY;

Â  Â  Â  Â  Â  Â  Â  Â  const vecX = targetX - this.x;
Â  Â  Â  Â  Â  Â  Â  Â  const vecY = targetY - this.y;
Â  Â  Â  Â  Â  Â  Â  Â  const distanceToTarget = Math.sqrt(vecX * vecX + vecY * vecY);

Â  Â  Â  Â  Â  Â  Â  Â  // Stop slightly before the target if eating, otherwise stop at the usual radius
Â  Â  Â  Â  Â  Â  Â  Â  const stopDistance = this.isEating ? 5 : this.radius;

Â  Â  Â  Â  Â  Â  Â  Â  if (distanceToTarget < stopDistance) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.clearTarget();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // If not starting the eating process, randomize direction
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (!this.isEating || this.eatingStartTime > 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.dx = (Math.random() - 0.5) * 2;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.dy = (Math.random() - 0.5) * 2;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.dx = vecX / distanceToTarget;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.dy = vecY / distanceToTarget;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  wander(entityManager, buffManager) {
Â  Â  Â  Â  Â  Â  Â  Â  if (this.isEating || this.isHangry) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // Don't seek new mushrooms if the mushroom buff is already active
Â  Â  Â  Â  Â  Â  Â  Â  if (!buffManager.getActiveBuffs().mushroom) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const nearbyMushroom = entityManager.getNearbyMushroom(this.x, this.y, Config.EAT_DETECTION_RADIUS);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (nearbyMushroom && Math.random() < Config.EAT_MUSHROOM_CHANCE) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.isEating = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.eatingTarget = nearbyMushroom;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.targetX = nearbyMushroom.x;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.targetY = nearbyMushroom.y;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // Standard wander behavior
Â  Â  Â  Â  Â  Â  Â  Â  if (Math.random() < 0.015) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.dx = (Math.random() - 0.5) * 2;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.dy = (Math.random() - 0.5) * 2;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  handleBounce(distanceMoved, buffManager, worldManager) {
Â  Â  Â  Â  Â  Â  Â  Â  this.distanceTraveledOnCurrentBounce += distanceMoved;

Â  Â  Â  Â  Â  Â  Â  Â  let currentBounceHeight = Config.BOUNCE_HEIGHT;
Â  Â  Â  Â  Â  Â  Â  Â  if (this.currentMoodState === 'mad') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  currentBounceHeight /= 2;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  const bounceProgress = Math.min(Math.PI, (this.distanceTraveledOnCurrentBounce / Config.BOUNCE_DISTANCE) * Math.PI);
Â  Â  Â  Â  Â  Â  Â  Â  this.verticalOffset = Math.sin(bounceProgress) * currentBounceHeight;

Â  Â  Â  Â  Â  Â  Â  Â  if (this.distanceTraveledOnCurrentBounce >= Config.BOUNCE_DISTANCE) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.land(buffManager, worldManager);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  land(buffManager, worldManager) {
Â  Â  Â  Â  Â  Â  Â  Â  // This uses the centralized strength stat now
Â  Â  Â  Â  Â  Â  Â  Â  worldManager.applyLandingImpact(this.x, this.y, this.currentMoodState, buffManager);

Â  Â  Â  Â  Â  Â  Â  Â  this.jiggleEndTime = Date.now();
Â  Â  Â  Â  Â  Â  Â  Â  this.verticalOffset = 0;
Â  Â  Â  Â  Â  Â  Â  Â  this.distanceTraveledOnCurrentBounce = 0;

Â  Â  Â  Â  Â  Â  Â  Â  if (buffManager.isKangarooEnding()) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  buffManager.deactivateBuff('kangaroo', true);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  handleBoundaries(bounds) {
Â  Â  Â  Â  Â  Â  Â  Â  let hitBoundary = false;
Â  Â  Â  Â  Â  Â  Â  Â  if (this.x + this.radius > bounds.width || this.x - this.radius < 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.dx *= -1;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.x = Utils.clamp(this.x, this.radius, bounds.width - this.radius);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  hitBoundary = true;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  if (this.y + this.radius > bounds.height || this.y - this.radius < 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.dy *= -1;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.y = Utils.clamp(this.y, this.radius, bounds.height - this.radius);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  hitBoundary = true;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  if (hitBoundary && this.targetX !== null) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.clearTarget();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â // If boundary collision interrupted eating seeking, cancel it without penalty
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.isEating && this.eatingStartTime === 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.isEating = false;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.eatingTarget = null;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const uiManager = Game.instance.uiManager;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (uiManager.getCurrentThought() === Config.Emojis.EATING_SEEKING) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  uiManager.hideThought();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // --- RENDERING ---
Â  Â  Â  Â  Â  Â  draw(ctx) {
Â  Â  Â  Â  Â  Â  Â  Â  let scaleFactor = 1;
Â  Â  Â  Â  Â  Â  Â  Â  const buffs = Game.instance.buffManager.getActiveBuffs();

Â  Â  Â  Â  Â  Â  Â  Â  if (buffs.kangaroo) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const bounceProgress = Math.min(Math.PI, (this.distanceTraveledOnCurrentBounce / Config.BOUNCE_DISTANCE) * Math.PI);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  scaleFactor = 1 - Math.sin(bounceProgress) * 0.2;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  const currentRadius = this.radius * scaleFactor;

Â  Â  Â  Â  Â  Â  Â  Â  // Draw Shadow
Â  Â  Â  Â  Â  Â  Â  Â  // Show shadow if moving or bouncing, hide only if stationary chewing
Â  Â  Â  Â  Â  Â  Â  Â  if (!(this.isEating && this.eatingStartTime > 0)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.beginPath();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.fillStyle = 'rgba(0, 0, 0, 0.35)';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Shadow Y is based on ground position (this.y)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const shadowY = this.y + this.radius;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const shadowScale = 1 - (this.verticalOffset / (Config.BOUNCE_HEIGHT * 3));
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const shadowRadiusX = currentRadius * shadowScale;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const shadowRadiusY = (currentRadius / 3) * shadowScale;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.ellipse(this.x, shadowY, shadowRadiusX, shadowRadiusY, 0, 0, Math.PI * 2);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.fill();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.closePath();
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // Draw Circle
Â  Â  Â  Â  Â  Â  Â  Â  ctx.save();

Â  Â  Â  Â  Â  Â  Â  Â  let drawY = this.y - this.verticalOffset;

Â  Â  Â  Â  Â  Â  Â  Â  ctx.translate(this.x, drawY);

Â  Â  Â  Â  Â  Â  Â  Â  // Landing Jiggle Effect
Â  Â  Â  Â  Â  Â  Â  Â  const jiggleDuration = 300;
Â  Â  Â  Â  Â  Â  Â  Â  const timeSinceJiggle = Date.now() - this.jiggleEndTime;
Â  Â  Â  Â  Â  Â  Â  Â  if (timeSinceJiggle < jiggleDuration) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const jiggleProgress = timeSinceJiggle / jiggleDuration;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let jiggleAmountMultiplier = (this.currentMoodState === 'mad') ? 0.4 : 0.2;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const jiggleAmount = Math.sin(jiggleProgress * Math.PI * 2) * (1 - jiggleProgress) * jiggleAmountMultiplier;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.scale(1 + jiggleAmount, 1 - jiggleAmount);
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // Draw Hangry Glow (Only if interrupted)
Â  Â  Â  Â  Â  Â  Â  Â  if (this.isInterruptedHangry) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.shadowBlur = 25;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.shadowColor = Config.COLOR_HANGRY_GLOW;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  ctx.beginPath();
Â  Â  Â  Â  Â  Â  Â  Â  ctx.arc(0, 0, currentRadius, 0, Math.PI * 2);
Â  Â  Â  Â  Â  Â  Â  Â  ctx.fillStyle = this.color;
Â  Â  Â  Â  Â  Â  Â  Â  ctx.fill();
Â  Â  Â  Â  Â  Â  Â  Â  ctx.closePath();

Â  Â  Â  Â  Â  Â  Â  Â  // Draw held item (Mushroom) during chewing phase
Â  Â  Â  Â  Â  Â  Â  Â  if (this.isEating && this.eatingStartTime > 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const elapsed = Date.now() - this.eatingStartTime;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Calculate wiggle for the mushroom (up and down motion)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const mushroomWiggleY = Math.sin(elapsed / 100) * 5;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.shadowBlur = 0; // Don't glow the mushroom itself
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.font = `${this.radius * 0.8}px monospace`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.textAlign = 'center';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.textBaseline = 'middle';

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Draw offset to the side
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const mushroomX = this.radius * 0.7;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const mushroomY = this.radius * 0.2 + mushroomWiggleY;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.fillText('ğŸ„', mushroomX, mushroomY);
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  ctx.restore();
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  // ====================================================================
Â  Â  Â  Â  // 4. BUFF AND ITEM MANAGERS
Â  Â  Â  Â  // ====================================================================

Â  Â  Â  Â  // (BuffManager and ItemManager implementations remain unchanged)
Â  Â  Â  Â  class BuffManager {
Â  Â  Â  Â  Â  Â  constructor(entityManager) {
Â  Â  Â  Â  Â  Â  Â  Â  this.entityManager = entityManager;
Â  Â  Â  Â  Â  Â  Â  Â  this.buffs = {};
Â  Â  Â  Â  Â  Â  Â  Â  this.initializeDefinitions();
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  initializeDefinitions() {
Â  Â  Â  Â  Â  Â  Â  Â  Object.entries(Config.Items).forEach(([name, data]) => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (data.type === 'buff') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.buffs[name] = {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  endTime: 0,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  blinkTimer: null,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  duration: data.duration || 0,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  isEureka: false,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  isEnding: false,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  emoji: data.emoji,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  indicator: null,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  hideTimer: data.hideTimer || false,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  hungerRestore: data.hungerRestore || 0,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  remainingTimeOnPause: 0 // NEW: Store remaining time when paused
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // NEW: Pause all active buffs
Â  Â  Â  Â  Â  Â  pauseAllBuffs() {
Â  Â  Â  Â  Â  Â  Â  Â  const currentTime = Date.now();
Â  Â  Â  Â  Â  Â  Â  Â  Object.values(this.buffs).forEach(buff => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (buff.endTime > currentTime) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Calculate remaining time and store it
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  buff.remainingTimeOnPause = buff.endTime - currentTime;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Set endTime to 0 to signify it's paused/inactive in the update loop
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  buff.endTime = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â buff.remainingTimeOnPause = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Clear any running timeouts (like the blink timer)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  clearTimeout(buff.blinkTimer);
Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // NEW: Resume all paused buffs
Â  Â  Â  Â  Â  Â  resumeAllBuffs() {
Â  Â  Â  Â  Â  Â  Â  Â  const currentTime = Date.now();
Â  Â  Â  Â  Â  Â  Â  Â  Object.values(this.buffs).forEach(buff => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (buff.remainingTimeOnPause > 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Restore endTime based on the current time + stored remaining time
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  buff.endTime = currentTime + buff.remainingTimeOnPause;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  buff.remainingTimeOnPause = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Re-setup the blink timer for the new duration
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.setupBlinkTimer(buff);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  initializeUI() {
Â  Â  Â  Â  Â  Â  Â  Â  const container = document.getElementById('buff-container');
Â  Â  Â  Â  Â  Â  Â  Â  const sortedKeys = Object.keys(this.buffs).sort((a, b) => a.localeCompare(b));

Â  Â  Â  Â  Â  Â  Â  Â  sortedKeys.forEach(name => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const buff = this.buffs[name];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const indicator = document.createElement('div');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  indicator.className = 'buff-indicator';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  indicator.id = `buff-indicator-${name}`;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const timerHTML = buff.hideTimer ? '' : '<div class="buff-timer"></div>';

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  indicator.innerHTML = `
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <span class="buff-icon">${buff.emoji}</span>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ${timerHTML}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  `;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  container.appendChild(indicator);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  buff.indicator = indicator;
Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  update() {
Â  Â  Â  Â  Â  Â  Â  Â  const currentTime = Date.now();
Â  Â  Â  Â  Â  Â  Â  Â  Object.entries(this.buffs).forEach(([name, buff]) => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Check if endTime > currentTime (only true if active and not paused)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (buff.endTime > currentTime) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.updateTimerDisplay(buff, currentTime);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Deactivate only if it expired naturally (remainingTimeOnPause is 0)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else if (buff.indicator && buff.indicator.style.display === 'flex' && !buff.isEnding && buff.remainingTimeOnPause === 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.deactivateBuff(name);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  updateTimerDisplay(buff, currentTime) {
Â  Â  Â  Â  Â  Â  Â  Â  if (buff.hideTimer || !buff.indicator) return;

Â  Â  Â  Â  Â  Â  Â  Â  const remainingSeconds = Math.ceil((buff.endTime - currentTime) / 1000);
Â  Â  Â  Â  Â  Â  Â  Â  const minutes = Math.floor(remainingSeconds / 60);
Â  Â  Â  Â  Â  Â  Â  Â  const seconds = remainingSeconds % 60;
Â  Â  Â  Â  Â  Â  Â  Â  const timerText = `${minutes}:${seconds.toString().padStart(2, '0')}`;

Â  Â  Â  Â  Â  Â  Â  Â  const timerEl = buff.indicator.querySelector('.buff-timer');
Â  Â  Â  Â  Â  Â  Â  Â  if (timerEl) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  timerEl.textContent = timerText;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // UPDATED: Handles adding time correctly even if a buff is paused.
Â  Â  Â  Â  Â  Â  addBuffTime(name, duration) {
Â  Â  Â  Â  Â  Â  Â  Â  const buff = this.buffs[name];
Â  Â  Â  Â  Â  Â  Â  Â  if (!buff) return;

Â  Â  Â  Â  Â  Â  Â  Â  const wanderDot = Game.instance.wanderDot; // Get reference early
Â  Â  Â  Â  Â  Â  Â  Â  const currentTime = Date.now();

Â  Â  Â  Â  Â  Â  Â  Â  // Determine if this is the first activation or a stack/refresh
Â  Â  Â  Â  Â  Â  Â  Â  // A buff is considered inactive if endTime is past AND it was NOT paused (remainingTimeOnPause is 0)
Â  Â  Â  Â  Â  Â  Â  Â  const isCurrentlyInactive = buff.endTime <= currentTime && buff.remainingTimeOnPause === 0;

Â  Â  Â  Â  Â  Â  Â  Â  // Calculate new end time
Â  Â  Â  Â  Â  Â  Â  Â  // If paused, add duration to the remaining time
Â  Â  Â  Â  Â  Â  Â  Â  if (buff.remainingTimeOnPause > 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  buff.remainingTimeOnPause += duration;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // If the game is running (which it must be to add a buff via click/eat), resume this specific buff
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  buff.endTime = currentTime + buff.remainingTimeOnPause;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  buff.remainingTimeOnPause = 0;
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // If active or expired, calculate base time normally
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const baseTime = Math.max(currentTime, buff.endTime);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  buff.endTime = baseTime + duration;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  buff.isEnding = false;

Â  Â  Â  Â  Â  Â  Â  Â  if (isCurrentlyInactive) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Apply hunger restoration (only on initial activation)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (buff.hungerRestore > 0 && wanderDot) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â wanderDot.hunger = Math.min(Config.MAX_HUNGER, wanderDot.hunger + buff.hungerRestore);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Apply Coffee mood boost (only on initial activation)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (name === 'coffee' && wanderDot) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Reduce annoyance significantly when coffee is used
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  wanderDot.applyMoodBoost(30);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }


Â  Â  Â  Â  Â  Â  Â  Â  this.setupBuffIndicator(buff);
Â  Â  Â  Â  Â  Â  Â  Â  this.setupBlinkTimer(buff);
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  setupBuffIndicator(buff) {
Â  Â  Â  Â  Â  Â  Â  Â  if (!buff.indicator) return;
Â  Â  Â  Â  Â  Â  Â  Â  buff.indicator.style.display = 'flex';
Â  Â  Â  Â  Â  Â  Â  Â  buff.indicator.classList.remove('blinking', 'blip-out');
Â  Â  Â  Â  Â  Â  Â  Â  if (buff.isEureka) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  buff.indicator.classList.add('eureka-state');
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  setupBlinkTimer(buff) {
Â  Â  Â  Â  Â  Â  Â  Â  clearTimeout(buff.blinkTimer);
Â  Â  Â  Â  Â  Â  Â  Â  const remainingTime = buff.endTime - Date.now();
Â  Â  Â  Â  Â  Â  Â  Â  const BLINK_THRESHOLD = 3000;

Â  Â  Â  Â  Â  Â  Â  Â  if (remainingTime > BLINK_THRESHOLD) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  buff.blinkTimer = setTimeout(() => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Check again before blinking, ensuring it's still active (endTime > Date.now()) and not paused
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (buff.endTime > Date.now() && buff.indicator) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  buff.indicator.classList.add('blinking');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }, remainingTime - BLINK_THRESHOLD);
Â  Â  Â  Â  Â  Â  Â  Â  } else if (remainingTime > 0 && buff.indicator) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  buff.indicator.classList.add('blinking');
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  deactivateBuff(name, force = false) {
Â  Â  Â  Â  Â  Â  Â  Â  const buff = this.buffs[name];

Â  Â  Â  Â  Â  Â  Â  Â  // Check if already inactive (endTime is 0 and not currently ending)
Â  Â  Â  Â  Â  Â  Â  Â  if ((buff.endTime === 0 && !buff.isEnding)) return;

Â  Â  Â  Â  Â  Â  Â  Â  if (name === 'kangaroo' && !force) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (Game.instance.wanderDot.verticalOffset > 0.1) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  buff.isEnding = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  buff.endTime = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  if (name === 'mushroom') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const dot = Game.instance.wanderDot;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.entityManager.addEntity('seed', dot.x, dot.y);
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  buff.endTime = 0;
Â  Â  Â  Â  Â  Â  Â  Â  buff.isEureka = false;
Â  Â  Â  Â  Â  Â  Â  Â  buff.isEnding = false;
Â  Â  Â  Â  Â  Â  Â  Â  buff.remainingTimeOnPause = 0; // Ensure pause time is cleared
Â  Â  Â  Â  Â  Â  Â  Â  clearTimeout(buff.blinkTimer);

Â  Â  Â  Â  Â  Â  Â  Â  if (buff.indicator) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  buff.indicator.classList.add('blip-out');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  buff.indicator.addEventListener('animationend', () => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (buff.indicator) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  buff.indicator.style.display = 'none';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  buff.indicator.className = 'buff-indicator';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }, { once: true });
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  getActiveBuffs() {
Â  Â  Â  Â  Â  Â  Â  Â  const currentTime = Date.now();
Â  Â  Â  Â  Â  Â  Â  Â  const active = {};
Â  Â  Â  Â  Â  Â  Â  Â  Object.entries(this.buffs).forEach(([name, buff]) => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // A buff is active if endTime is in the future OR if it's currently ending (like kangaroo landing)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // If the game is paused, buffs might have remainingTimeOnPause > 0, but we still consider them "active" conceptually for game logic
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (buff.endTime > currentTime || buff.isEnding || buff.remainingTimeOnPause > 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  active[name] = {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  isEureka: buff.isEureka,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  potency: buff.isEureka ? 2.0 : 1.0
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  Â  Â  return active;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  isKangarooEnding() {
Â  Â  Â  Â  Â  Â  Â  Â  return this.buffs.kangaroo?.isEnding;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  applyWatchExtension() {
Â  Â  Â  Â  Â  Â  Â  Â  Object.keys(this.buffs).forEach(name => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â // Check if the buff is active (endTime > now OR paused with remaining time)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (name !== 'mushroom' && (this.buffs[name].endTime > Date.now() || this.buffs[name].remainingTimeOnPause > 0)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.addBuffTime(name, Config.WATCH_TIME_EXTENSION);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  applyEureka() {
Â  Â  Â  Â  Â  Â  Â  Â  Object.entries(this.buffs).forEach(([name, buff]) => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â // Check if the buff is active (endTime > now OR paused with remaining time)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (name !== 'mushroom' && (buff.endTime > Date.now() || buff.remainingTimeOnPause > 0)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  buff.isEureka = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (buff.indicator) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  buff.indicator.classList.add('eureka-state');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  class ItemManager {
Â  Â  Â  Â  Â  Â  constructor(buffManager) {
Â  Â  Â  Â  Â  Â  Â  Â  this.buffManager = buffManager;
Â  Â  Â  Â  Â  Â  Â  Â  this.items = {};
Â  Â  Â  Â  Â  Â  Â  Â  this.initializeDefinitions();
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  initializeDefinitions() {
Â  Â  Â  Â  Â  Â  Â  Â  Object.entries(Config.Items).forEach(([name, data]) => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (name !== 'mushroom') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.items[name] = {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  count: 0,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  button: null,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  emoji: data.emoji,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  type: data.type
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  initializeUI() {
Â  Â  Â  Â  Â  Â  Â  Â  const itemBar = document.getElementById('item-bar');
Â  Â  Â  Â  Â  Â  Â  Â  // Event listener handled by UIManager's chest button now, but we still need listeners on the buttons themselves
Â  Â  Â  Â  Â  Â  Â  Â  itemBar.addEventListener('click', (event) => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const button = event.target.closest('.item-button');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (button && button.dataset.itemName) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.useItem(button.dataset.itemName);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  });

Â  Â  Â  Â  Â  Â  Â  Â  Object.entries(this.items).forEach(([name, item]) => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const button = document.createElement('button');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  button.className = 'item-button';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  button.dataset.itemName = name;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  itemBar.appendChild(button);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  item.button = button;
Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  Â  Â  this.updateItemBar();
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  addItem(emoji) {
Â  Â  Â  Â  Â  Â  Â  Â  const itemName = Object.keys(this.items).find(name => this.items[name].emoji === emoji);
Â  Â  Â  Â  Â  Â  Â  Â  if (itemName) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.items[itemName].count++;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.updateItemBar();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return true;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  return false;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  useItem(name) {
Â  Â  Â  Â  Â  Â  Â  Â  const item = this.items[name];
Â  Â  Â  Â  Â  Â  Â  Â  if (item.count > 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  item.count--;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.updateItemBar();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.animateButton(item.button);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (item.type === 'buff') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Pass the duration stored in the BuffManager definition
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.buffManager.addBuffTime(name, this.buffManager.buffs[name].duration);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else if (name === 'watch') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.buffManager.applyWatchExtension();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else if (name === 'lightbulb') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.buffManager.applyEureka();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  animateButton(button) {
Â  Â  Â  Â  Â  Â  Â  Â  if (!button) return;
Â  Â  Â  Â  Â  Â  Â  Â  button.classList.add('clicked');
Â  Â  Â  Â  Â  Â  Â  Â  button.addEventListener('animationend', () => button.classList.remove('clicked'), { once: true });
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  updateItemBar() {
Â  Â  Â  Â  Â  Â  Â  Â  // Removed logic to toggle the main item bar visibility here, handled by UIManager/Chest button
Â  Â  Â  Â  Â  Â  Â  Â  Object.values(this.items).forEach(item => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (item.button) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (item.count > 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  item.button.classList.add('visible');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  item.button.textContent = `${item.emoji}x${item.count}`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  item.button.classList.remove('visible');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  // ====================================================================
Â  Â  Â  Â  // 5. PARTICLE SYSTEM & UFO
Â  Â  Â  Â  // ====================================================================

Â  Â  Â  Â  // (ParticleSystem and UFO implementations remain unchanged)
Â  Â  Â  Â  class ParticleSystem {
Â  Â  Â  Â  Â  Â  constructor(ctx) {
Â  Â  Â  Â  Â  Â  Â  Â  this.ctx = ctx;
Â  Â  Â  Â  Â  Â  Â  Â  this.particles = [];
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  spawnLandingParticles(x, y) {
Â  Â  Â  Â  Â  Â  Â  Â  const count = 10;
Â  Â  Â  Â  Â  Â  Â  Â  for(let i=0; i < count; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const angle = Math.random() * Math.PI * 2;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const speed = Math.random() * 50 + 20;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.particles.push({
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  type: 'pebble', x: x, y: y,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  dx: Math.cos(angle) * speed, dy: Math.sin(angle) * speed,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  life: 1, maxLife: 1
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  spawnUFOMist(x, y) {
Â  Â  Â  Â  Â  Â  Â  Â  if (Math.random() < 0.5) return;

Â  Â  Â  Â  Â  Â  Â  Â  this.particles.push({
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  type: 'mist',
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  x: x + (Math.random() - 0.5) * 80,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  y: y + (Math.random() - 0.5) * 40,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  dx: (Math.random() - 0.5) * 20,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  dy: (Math.random() - 0.5) * 10,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  life: 2, maxLife: 2
Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  updateAndDraw(deltaTime) {
Â  Â  Â  Â  Â  Â  Â  Â  for (let i = this.particles.length - 1; i >= 0; i--) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const p = this.particles[i];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  p.x += p.dx * deltaTime;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  p.y += p.dy * deltaTime;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  p.life -= deltaTime;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if(p.life <= 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.particles.splice(i, 1);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.drawParticle(p);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  drawParticle(p) {
Â  Â  Â  Â  Â  Â  Â  Â  const opacity = p.life / p.maxLife;
Â  Â  Â  Â  Â  Â  Â  Â  this.ctx.beginPath();
Â  Â  Â  Â  Â  Â  Â  Â  if(p.type === 'pebble') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.ctx.fillStyle = `rgba(30, 30, 30, ${0.5 * opacity})`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.ctx.arc(p.x, p.y, 2, 0, Math.PI * 2);
Â  Â  Â  Â  Â  Â  Â  Â  } else if (p.type === 'mist') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.ctx.fillStyle = `rgba(200, 220, 255, ${0.2 * opacity})`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.ctx.arc(p.x, p.y, 10, 0, Math.PI * 2);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  this.ctx.fill();
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  class UFO {
Â  Â  Â  Â  Â  Â  constructor(ctx, bounds) {
Â  Â  Â  Â  Â  Â  Â  Â  this.ctx = ctx;
Â  Â  Â  Â  Â  Â  Â  Â  this.bounds = bounds;
Â  Â  Â  Â  Â  Â  Â  Â  this.active = false;
Â  Â  Â  Â  Â  Â  Â  Â  this.x = 0;
Â  Â  Â  Â  Â  Â  Â  Â  this.y = 0;
Â  Â  Â  Â  Â  Â  Â  Â  this.speed = 300;
Â  Â  Â  Â  Â  Â  Â  Â  this.direction = 1;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  activate() {
Â  Â  Â  Â  Â  Â  Â  Â  if (this.active) return;
Â  Â  Â  Â  Â  Â  Â  Â  this.active = true;
Â  Â  Â  Â  Â  Â  Â  Â  // Ensure UFO stays within the visible bounds (accounting for new bottom bar)
Â  Â  Â  Â  Â  Â  Â  Â  this.y = Math.random() * (this.bounds.height * 0.6) + (this.bounds.height * 0.1);

Â  Â  Â  Â  Â  Â  Â  Â  if(Math.random() < 0.5) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.direction = 1;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.x = -50;
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.direction = -1;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.x = this.bounds.width + 50;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  update(deltaTime, particleManager, worldManager) {
Â  Â  Â  Â  Â  Â  Â  Â  if (!this.active) return;

Â  Â  Â  Â  Â  Â  Â  Â  this.x += this.speed * this.direction * deltaTime;

Â  Â  Â  Â  Â  Â  Â  Â  particleManager.spawnUFOMist(this.x, this.y);

Â  Â  Â  Â  Â  Â  Â  Â  if(Math.random() < 0.1) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  worldManager.alterGround(this.x + (Math.random() - 0.5) * 50, this.y + (Math.random() - 0.5) * 50);
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  if(this.x < -100 || this.x > this.bounds.width + 100) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.active = false;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  draw() {
Â  Â  Â  Â  Â  Â  Â  Â  if (!this.active) return;
Â  Â  Â  Â  Â  Â  Â  Â  this.ctx.font = '4rem monospace';
Â  Â  Â  Â  Â  Â  Â  Â  this.ctx.textAlign = 'center';
Â  Â  Â  Â  Â  Â  Â  Â  this.ctx.textBaseline = 'middle';
Â  Â  Â  Â  Â  Â  Â  Â  this.ctx.fillText('ğŸ›¸', this.x, this.y);
Â  Â  Â  Â  Â  Â  Â  Â  this.ctx.textAlign = 'start';
Â  Â  Â  Â  Â  Â  Â  Â  this.ctx.textBaseline = 'alphabetic';
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  // ====================================================================
Â  Â  Â  Â  // 6. UI MANAGER (Thoughts, Timers, Interaction)
Â  Â  Â  Â  // ====================================================================

Â  Â  Â  Â  // (UIManager implementation remains unchanged)
Â  Â  Â  Â  class UIManager {
Â  Â  Â  Â  Â  Â  constructor(wanderDot) {
Â  Â  Â  Â  Â  Â  Â  Â  this.wanderDot = wanderDot;
Â  Â  Â  Â  Â  Â  Â  Â  this.thoughtBubble = document.getElementById('thought-bubble');
Â  Â  Â  Â  Â  Â  Â  Â  this.worldTimerElement = document.getElementById('world-timer-display');

Â  Â  Â  Â  Â  Â  Â  Â  // Stat Elements
Â  Â  Â  Â  Â  Â  Â  Â  this.statStrength = document.getElementById('stat-strength').querySelector('span');
Â  Â  Â  Â  Â  Â  Â  Â  this.statRadius = document.getElementById('stat-radius').querySelector('span');
Â  Â  Â  Â  Â  Â  Â  Â  this.statSpeed = document.getElementById('stat-speed').querySelector('span');

Â  Â  Â  Â  Â  Â  Â  Â  // Bar Graphs
Â  Â  Â  Â  Â  Â  Â  Â  this.moodBarFill = document.getElementById('mood-bar-fill');
Â  Â  Â  Â  Â  Â  Â  Â  this.moodBarBg = document.getElementById('mood-bar-bg'); // Need background to add/remove class
Â  Â  Â  Â  Â  Â  Â  Â  this.hungerBarFill = document.getElementById('hunger-bar-fill');
Â  Â  Â  Â  Â  Â  Â  Â  this.hungerBarBg = document.getElementById('hunger-bar-bg'); // Need background to add/remove class

Â  Â  Â  Â  Â  Â  Â  Â  this.idleThoughtTimer = null;
Â  Â  Â  Â  Â  Â  Â  Â  this.madThoughtTimer = null;
Â  Â  Â  Â  Â  Â  Â  Â  this.thoughtTimeout = null;
Â  Â  Â  Â  Â  Â  Â  Â  this.fadeTimeout = null;
Â  Â  Â  Â  Â  Â  Â  Â  this.idleEmojiHistory = [];

Â  Â  Â  Â  Â  Â  Â  Â  this.bubbleAngle = -Math.PI / 2;
Â  Â  Â  Â  Â  Â  Â  Â  this.targetBubbleAngle = -Math.PI / 2;
Â  Â  Â  Â  Â  Â  Â  Â  this.riseStartTime = 0;
Â  Â  Â  Â  Â  Â  Â  Â  this.bounceEndTime = 0;

Â  Â  Â  Â  Â  Â  Â  Â  this.isMouseOverBubble = false;
Â  Â  Â  Â  Â  Â  Â  Â  this.thoughtTimeoutStartTime = 0;
Â  Â  Â  Â  Â  Â  Â  Â  this.thoughtTimeoutDuration = 0;
Â  Â  Â  Â  Â  Â  Â  Â  this.thoughtTimeoutRemaining = 0;
Â  Â  Â  Â  Â  Â  Â  Â  this.mousePos = { x: 0, y: 0 };

Â  Â  Â  Â  Â  Â  Â  Â  this.setupEventListeners();
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â setupEventListeners() {
Â  Â  Â  Â  Â  Â  Â  Â  window.addEventListener('mousemove', (event) => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.mousePos.x = event.clientX;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.mousePos.y = event.clientY;
Â  Â  Â  Â  Â  Â  Â  Â  });

Â  Â  Â  Â  Â  Â  Â  Â  this.thoughtBubble.addEventListener('click', (event) => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  event.stopPropagation();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.handleThoughtClick();
Â  Â  Â  Â  Â  Â  Â  Â  });

Â  Â  Â  Â  Â  Â  Â  Â  this.thoughtBubble.addEventListener('mouseenter', () => this.handleBubbleEnter());
Â  Â  Â  Â  Â  Â  Â  Â  this.thoughtBubble.addEventListener('mouseleave', () => this.handleBubbleLeave());

Â  Â  Â  Â  Â  Â  Â  Â  // Chest button listener
Â  Â  Â  Â  Â  Â  Â  Â  const chestButton = document.getElementById('chest-button');
Â  Â  Â  Â  Â  Â  Â  Â  if (chestButton) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  chestButton.addEventListener('click', () => this.toggleItemBar());
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  toggleItemBar() {
Â  Â  Â  Â  Â  Â  Â  Â  const itemBar = document.getElementById('item-bar');
Â  Â  Â  Â  Â  Â  Â  Â  if (itemBar) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  itemBar.classList.toggle('visible');
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  getCurrentThought() {
Â  Â  Â  Â  Â  Â  Â  Â  if (this.thoughtBubble.style.display === 'block') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const span = this.thoughtBubble.querySelector('span');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Return the base emoji if it's a timer thought
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (span) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const text = span.textContent;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const match = text.match(/^(\p{Emoji})/u);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return match ? match[1] : text;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  return null;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  updateThoughtContent(content, isCompact = false) {
Â  Â  Â  Â  Â  Â  Â  Â  if (this.thoughtBubble.style.display === 'block') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const span = this.thoughtBubble.querySelector('span');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (span) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â if (span.textContent !== content) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â span.textContent = content;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Adjust font size if needed for compact display
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const targetFontSize = isCompact ? '1.5rem' : '2.5rem';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.thoughtBubble.style.fontSize !== targetFontSize) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â this.thoughtBubble.style.fontSize = targetFontSize;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  hideThought() {
Â  Â  Â  Â  Â  Â  Â  Â  if (!this.isMouseOverBubble) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.thoughtBubble.style.opacity = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.fadeTimeout = setTimeout(() => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.thoughtBubble.style.display = 'none';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }, 300);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â getNextIdleEmoji() {
Â  Â  Â  Â  Â  Â  Â  Â  const candidateEmojis = Config.Emojis.idle.filter(e => !this.idleEmojiHistory.includes(e));
Â  Â  Â  Â  Â  Â  Â  Â  const emojiPool = candidateEmojis.length > 0 ? candidateEmojis : Config.Emojis.idle;
Â  Â  Â  Â  Â  Â  Â  Â  const nextEmoji = Utils.randomChoice(emojiPool);

Â  Â  Â  Â  Â  Â  Â  Â  this.idleEmojiHistory.push(nextEmoji);
Â  Â  Â  Â  Â  Â  Â  Â  if (this.idleEmojiHistory.length > 3) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.idleEmojiHistory.shift();
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  return nextEmoji;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  startMadTimer() {
Â  Â  Â  Â  Â  Â  Â  Â  this.stopMadTimer();
Â  Â  Â  Â  Â  Â  Â  Â  this.madThoughtTimer = setInterval(() => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Don't show mad thoughts if Hangry
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.wanderDot.currentMoodState === 'mad' && !this.wanderDot.isHangry) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.showThought(Utils.randomChoice(Config.Emojis.madZone));
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else if (this.wanderDot.currentMoodState !== 'mad') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.stopMadTimer();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }, 3000);
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  stopMadTimer() {
Â  Â  Â  Â  Â  Â  Â  Â  clearInterval(this.madThoughtTimer);
Â  Â  Â  Â  Â  Â  Â  Â  this.madThoughtTimer = null;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // UPDATED: Apply mood boost on click for specific thoughts.
Â  Â  Â  Â  Â  Â  handleThoughtClick() {
Â  Â  Â  Â  Â  Â  Â  Â  const emoji = this.getCurrentThought();

Â  Â  Â  Â  Â  Â  Â  Â  // NEW: Check for clickable mood boosting emojis (ğŸ®, ğŸ¥)
Â  Â  Â  Â  Â  Â  Â  Â  if (emoji === 'ğŸ®' || emoji === 'ğŸ¥') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â this.wanderDot.applyMoodBoost(Config.MOOD_BOOST_CLICKABLE_THOUGHT);
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  const collected = Game.instance.itemManager.addItem(emoji);

Â  Â  Â  Â  Â  Â  Â  Â  if (!collected) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (emoji === 'ğŸ‘½') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Game.instance.ufo.activate();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  clearTimeout(this.thoughtTimeout);
Â  Â  Â  Â  Â  Â  Â  Â  clearTimeout(this.fadeTimeout);
Â  Â  Â  Â  Â  Â  Â  Â  this.thoughtBubble.style.display = 'none';
Â  Â  Â  Â  Â  Â  Â  Â  this.isMouseOverBubble = false;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  handleBubbleEnter() {
Â  Â  Â  Â  Â  Â  Â  Â  this.isMouseOverBubble = true;
Â  Â  Â  Â  Â  Â  Â  Â  this.thoughtTimeoutRemaining = this.thoughtTimeoutDuration - (Date.now() - this.thoughtTimeoutStartTime);
Â  Â  Â  Â  Â  Â  Â  Â  clearTimeout(this.thoughtTimeout);
Â  Â  Â  Â  Â  Â  Â  Â  clearTimeout(this.fadeTimeout);
Â  Â  Â  Â  Â  Â  Â  Â  this.thoughtBubble.style.opacity = 1;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  handleBubbleLeave() {
Â  Â  Â  Â  Â  Â  Â  Â  this.isMouseOverBubble = false;
Â  Â  Â  Â  Â  Â  Â  Â  this.thoughtTimeout = setTimeout(() => this.hideThought(), Math.max(500, this.thoughtTimeoutRemaining));
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // UPDATED: Accepts accumulatedGameTime instead of worldCreationTime
Â  Â  Â  Â  Â  Â  update(accumulatedGameTime) {
Â  Â  Â  Â  Â  Â  Â  Â  this.updateTimer(accumulatedGameTime);
Â  Â  Â  Â  Â  Â  Â  Â  this.updateStats();
Â  Â  Â  Â  Â  Â  Â  Â  this.updateBarGraphs();
Â  Â  Â  Â  Â  Â  Â  Â  if (this.thoughtBubble.style.display === 'block') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.updateBubblePosition();
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // UPDATED: Uses the provided elapsedTime (from accumulatedGameTime)
Â  Â  Â  Â  Â  Â  updateTimer(elapsedTime) {
Â  Â  Â  Â  Â  Â  Â  Â  // const elapsedTime = Date.now() - worldCreationTime; // Old implementation
Â  Â  Â  Â  Â  Â  Â  Â  // elapsedTime is provided in milliseconds
Â  Â  Â  Â  Â  Â  Â  Â  const elapsedSeconds = Math.floor(elapsedTime / 1000);
Â  Â  Â  Â  Â  Â  Â  Â  const minutes = Math.floor(elapsedSeconds / 60);
Â  Â  Â  Â  Â  Â  Â  Â  const seconds = elapsedSeconds % 60;

Â  Â  Â  Â  Â  Â  Â  Â  const timerText = `[${minutes}m:${seconds.toString().padStart(2, '0')}s]`;
Â  Â  Â  Â  Â  Â  Â  Â  this.worldTimerElement.textContent = timerText;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  updateStats() {
Â  Â  Â  Â  Â  Â  Â  Â  // Strength is the multiplier
Â  Â  Â  Â  Â  Â  Â  Â  this.statStrength.textContent = this.wanderDot.currentStrengthMultiplier.toFixed(2) + 'x';
Â  Â  Â  Â  Â  Â  Â  Â  // Radius is the pixel radius
Â  Â  Â  Â  Â  Â  Â  Â  this.statRadius.textContent = this.wanderDot.radius.toFixed(1) + 'px';
Â  Â  Â  Â  Â  Â  Â  Â  // Speed is the base speed multiplied by the current speed multiplier (ignoring kangaroo boost for UI stability)
Â  Â  Â  Â  Â  Â  Â  Â  const effectiveSpeed = this.wanderDot.speed * this.wanderDot.currentSpeedMultiplier;
Â  Â  Â  Â  Â  Â  Â  Â  this.statSpeed.textContent = effectiveSpeed.toFixed(1);
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  updateBarGraphs() {
Â  Â  Â  Â  Â  Â  Â  Â  // Mood Bar (Annoyance 0 = 100% Green, Annoyance 100 = 0% Red)
Â  Â  Â  Â  Â  Â  Â  Â  const moodRatio = 1 - (this.wanderDot.annoyance / 100);
Â  Â  Â  Â  Â  Â  Â  Â  this.moodBarFill.style.width = `${moodRatio * 100}%`;
Â  Â  Â  Â  Â  Â  Â  Â  // Lerp color from Red (0) to Green (1)
Â  Â  Â  Â  Â  Â  Â  Â  const moodColor = Utils.lerpColor({r: 220, g: 50, b: 40}, {r: 50, g: 205, b: 50}, moodRatio);
Â  Â  Â  Â  Â  Â  Â  Â  this.moodBarFill.style.backgroundColor = moodColor;

Â  Â  Â  Â  Â  Â  Â  Â  // Manage Mood Text Visibility
Â  Â  Â  Â  Â  Â  Â  Â  if (this.wanderDot.currentMoodState === 'mad' || this.wanderDot.currentMoodState === 'annoyed') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.moodBarBg.classList.add('active-state');
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.moodBarBg.classList.remove('active-state');
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // Hunger Bar (Hunger 100 = 100% Green, Hunger 0 = 0% Red)
Â  Â  Â  Â  Â  Â  Â  Â  const hungerRatio = this.wanderDot.hunger / Config.MAX_HUNGER;
Â  Â  Â  Â  Â  Â  Â  Â  this.hungerBarFill.style.width = `${hungerRatio * 100}%`;
Â  Â  Â  Â  Â  Â  Â  Â  const hungerColor = Utils.lerpColor({r: 220, g: 50, b: 40}, {r: 154, g: 205, b: 50}, hungerRatio); // Different green for hunger
Â  Â  Â  Â  Â  Â  Â  Â  this.hungerBarFill.style.backgroundColor = hungerColor;

Â  Â  Â  Â  Â  Â  Â  Â  // Manage Hunger Text Visibility
Â  Â  Â  Â  Â  Â  Â  Â  if (this.wanderDot.hunger < Config.HANGRY_HUNGER_THRESHOLD) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.hungerBarBg.classList.add('active-state');
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.hungerBarBg.classList.remove('active-state');
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // UPDATED: Removed automatic mood boost application.
Â  Â  Â  Â  Â  Â  showThought(emoji, duration = 2000) {
Â  Â  Â  Â  Â  Â  Â  Â  if (!emoji) return;

Â  Â  Â  Â  Â  Â  Â  Â  // Mood boosts (ğŸ®, ğŸ¥) are now handled in handleThoughtClick()

Â  Â  Â  Â  Â  Â  Â  Â  clearTimeout(this.thoughtTimeout);
Â  Â  Â  Â  Â  Â  Â  Â  clearTimeout(this.fadeTimeout);

Â  Â  Â  Â  Â  Â  Â  Â  this.prepareBubbleAnimation();

Â  Â  Â  Â  Â  Â  Â  Â  this.thoughtBubble.innerHTML = `<span>${emoji}</span>`;
Â  Â  Â  Â  Â  Â  Â  Â  this.thoughtBubble.style.fontSize = '2.5rem'; // Ensure font size is reset to default
Â  Â  Â  Â  Â  Â  Â  Â  this.thoughtBubble.style.opacity = 1;
Â  Â  Â  Â  Â  Â  Â  Â  this.thoughtBubble.style.display = 'block';

Â  Â  Â  Â  Â  Â  Â  Â  this.thoughtTimeoutStartTime = Date.now();
Â  Â  Â  Â  Â  Â  Â  Â  this.thoughtTimeoutDuration = duration;
Â  Â  Â  Â  Â  Â  Â  Â  this.thoughtTimeout = setTimeout(() => this.hideThought(), duration);
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  prepareBubbleAnimation() {
Â  Â  Â  Â  Â  Â  Â  Â  if (this.thoughtBubble.style.display === 'block') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.bounceEndTime = Date.now() + 300;
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const initialOrbitRadius = this.wanderDot.radius;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const initialX = this.wanderDot.x + Math.cos(this.bubbleAngle) * initialOrbitRadius;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const initialY = this.wanderDot.y + Math.sin(this.bubbleAngle) * initialOrbitRadius;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.thoughtBubble.style.left = `${initialX}px`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.thoughtBubble.style.top = `${initialY}px`;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  this.thoughtBubble.classList.remove('is-rising');
Â  Â  Â  Â  Â  Â  Â  Â  void this.thoughtBubble.offsetWidth;
Â  Â  Â  Â  Â  Â  Â  Â  this.thoughtBubble.classList.add('is-rising');
Â  Â  Â  Â  Â  Â  Â  Â  this.riseStartTime = Date.now();
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // --- IDLE THOUGHT SCHEDULING (Unchanged) ---
Â  Â  Â  Â  Â  Â  scheduleNextIdleThought(delay = 7000) {
Â  Â  Â  Â  Â  Â  Â  Â  const IDLE_THOUGHT_DURATION = 4000;
Â  Â  Â  Â  Â  Â  Â  Â  const BREAK_DURATION = 7000;

Â  Â  Â  Â  Â  Â  Â  Â  clearTimeout(this.idleThoughtTimer);
Â  Â  Â  Â  Â  Â  Â  Â  this.idleThoughtTimer = setTimeout(() => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Only show if idle AND not annoyed AND not Hangry
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.wanderDot.targetX === null &&
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  !this.wanderDot.isEating &&
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  !this.wanderDot.isHangry &&
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.wanderDot.annoyance < Config.WARNING_ANNOYANCE_THRESHOLD) {

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const nextEmoji = this.getNextIdleEmoji();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.showThought(nextEmoji, IDLE_THOUGHT_DURATION);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.scheduleNextIdleThought(IDLE_THOUGHT_DURATION + 300 + BREAK_DURATION);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // If busy, check again later
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.scheduleNextIdleThought(BREAK_DURATION);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }, delay);
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // (updateBubblePosition, findBestBubbleAngle, calculateBubbleAnimations remain unchanged)
Â  Â  Â  Â  Â  Â  updateBubblePosition() {
Â  Â  Â  Â  Â  Â  Â  Â  const bubbleWidth = this.thoughtBubble.offsetWidth;
Â  Â  Â  Â  Â  Â  Â  Â  const bubbleHeight = this.thoughtBubble.offsetHeight;
Â  Â  Â  Â  Â  Â  Â  Â  const finalOrbitRadius = this.wanderDot.radius + bubbleHeight / 2 + 5;

Â  Â  Â  Â  Â  Â  Â  Â  this.targetBubbleAngle = this.findBestBubbleAngle(finalOrbitRadius, bubbleWidth, bubbleHeight);
Â  Â  Â  Â  Â  Â  Â  Â  this.bubbleAngle = Utils.lerp(this.bubbleAngle, this.targetBubbleAngle, 0.1);

Â  Â  Â  Â  Â  Â  Â  Â  const { radius, verticalBob } = this.calculateBubbleAnimations(finalOrbitRadius);

Â  Â  Â  Â  Â  Â  Â  Â  let bubbleTargetX = this.wanderDot.x + Math.cos(this.bubbleAngle) * radius;
Â  Â  Â  Â  Â  Â  Â  Â  let bubbleTargetY = this.wanderDot.y - this.wanderDot.verticalOffset + Math.sin(this.bubbleAngle) * radius + verticalBob;

Â  Â  Â  Â  Â  Â  Â  Â  if(this.isMouseOverBubble) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const currentX = parseFloat(this.thoughtBubble.style.left) || bubbleTargetX;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const currentY = parseFloat(this.thoughtBubble.style.top) || bubbleTargetY;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  bubbleTargetX = Utils.lerp(currentX, this.mousePos.x, 0.2);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  bubbleTargetY = Utils.lerp(currentY, this.mousePos.y, 0.2);
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  this.thoughtBubble.style.left = `${bubbleTargetX}px`;
Â  Â  Â  Â  Â  Â  Â  Â  this.thoughtBubble.style.top = `${bubbleTargetY}px`;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  findBestBubbleAngle(radius, width, height) {
Â  Â  Â  Â  Â  Â  Â  Â  const SAFE_MARGIN = 10;
Â  Â  Â  Â  Â  Â  Â  Â  const bounds = Game.instance.bounds;
Â  Â  Â  Â  Â  Â  Â  Â  const startAngle = -Math.PI / 2;

Â  Â  Â  Â  Â  Â  Â  Â  for (let offset = 0; offset < Math.PI; offset += 0.1) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  for (const sign of [1, -1]) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const angle = startAngle + offset * sign;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const testX = this.wanderDot.x + Math.cos(angle) * radius;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const testY = this.wanderDot.y + Math.sin(angle) * radius;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (testX - width / 2 > SAFE_MARGIN && testX + width / 2 < bounds.width - SAFE_MARGIN &&
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  testY - height / 2 > SAFE_MARGIN && testY + height / 2 < bounds.height - SAFE_MARGIN) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return angle;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  return this.targetBubbleAngle;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  calculateBubbleAnimations(finalOrbitRadius) {
Â  Â  Â  Â  Â  Â  Â  Â  let radius = finalOrbitRadius;
Â  Â  Â  Â  Â  Â  Â  Â  let verticalBob = 0;
Â  Â  Â  Â  Â  Â  Â  Â  const animTime = Date.now();

Â  Â  Â  Â  Â  Â  Â  Â  if (this.riseStartTime > 0 && animTime - this.riseStartTime < 400) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const riseProgress = (animTime - this.riseStartTime) / 400;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  radius = Utils.lerp(this.wanderDot.radius, finalOrbitRadius, riseProgress);
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.riseStartTime = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.bounceEndTime > 0 && animTime < this.bounceEndTime) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const bounceProgress = (animTime - (this.bounceEndTime - 300)) / 300;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  verticalBob = Math.sin(bounceProgress * Math.PI) * -15;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.bounceEndTime = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  verticalBob = Math.sin(animTime / 400) * -3;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  return { radius, verticalBob };
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  // ====================================================================
Â  Â  Â  Â  // 7. GAME (Main Loop, Initialization)
Â  Â  Â  Â  // ====================================================================

Â  Â  Â  Â  // UPDATED: Optimized draw loop using pre-sorted grass list.
Â  Â  Â  Â  class Game {
Â  Â  Â  Â  Â  Â  static instance = null;

Â  Â  Â  Â  Â  Â  constructor() {
Â  Â  Â  Â  Â  Â  Â  Â  if (Game.instance) return Game.instance;
Â  Â  Â  Â  Â  Â  Â  Â  Game.instance = this;

Â  Â  Â  Â  Â  Â  Â  Â  this.assetManager = new AssetManager();
Â  Â  Â  Â  Â  Â  Â  Â  this.isInitialized = false;

Â  Â  Â  Â  Â  Â  Â  Â  this.initializeCanvases();
Â  Â  Â  Â  Â  Â  Â  Â  this.bounds = { width: this.mainCanvas.width, height: this.mainCanvas.height };

Â  Â  Â  Â  Â  Â  Â  Â  this.worldCreationTime = Date.now();
Â  Â  Â  Â  Â  Â  Â  Â  this.accumulatedGameTime = 0; // NEW: Tracks actual time the game has been active (in ms)
Â  Â  Â  Â  Â  Â  Â  Â  this.lastFrameTime = 0;
Â  Â  Â  Â  Â  Â  Â  Â  this.lastClickTime = 0;
Â  Â  Â  Â  Â  Â  Â  Â  // Game state
Â  Â  Â  Â  Â  Â  Â  Â  this.isRunning = false;
Â  Â  Â  Â  Â  Â  Â  Â  this.isPaused = false; // Differentiate between stopped (game over) and paused
Â  Â  Â  Â  Â  Â  Â  Â  this.animationFrameId = null;

Â  Â  Â  Â  Â  Â  Â  Â  // Load assets first, then proceed with initialization
Â  Â  Â  Â  Â  Â  Â  Â  this.assetManager.loadAll(() => this.initializeAfterLoading());
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  initializeCanvases() {
Â  Â  Â  Â  Â  Â  Â  Â  this.worldContainer = document.getElementById('world-container');
Â  Â  Â  Â  Â  Â  Â  Â  this.mainCanvas = document.getElementById('mainCanvas');
Â  Â  Â  Â  Â  Â  Â  Â  this.ctx = this.mainCanvas.getContext('2d');
Â  Â  Â  Â  Â  Â  Â  Â  this.pathCanvas = document.getElementById('pathCanvas');
Â  Â  Â  Â  Â  Â  Â  Â  this.pathCtx = this.pathCanvas.getContext('2d');
Â  Â  Â  Â  Â  Â  Â  Â  this.entityCanvas = document.getElementById('entityCanvas');
Â  Â  Â  Â  Â  Â  Â  Â  this.entityCtx = this.entityCanvas.getContext('2d');

Â  Â  Â  Â  Â  Â  Â  Â  this.resizeCanvases();
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  resizeCanvases() {
Â  Â  Â  Â  Â  Â  Â  Â  const width = window.innerWidth;

Â  Â  Â  Â  Â  Â  Â  Â  // Calculate height based on the bottom bar's actual rendered height
Â  Â  Â  Â  Â  Â  Â  Â  const bottomBar = document.getElementById('bottom-bar');
Â  Â  Â  Â  Â  Â  Â  Â  // Use offsetHeight to get the dynamic height (important for mobile responsiveness)
Â  Â  Â  Â  Â  Â  Â  Â  const bottomBarHeight = bottomBar ? bottomBar.offsetHeight : 80;
Â  Â  Â  Â  Â  Â  Â  Â  const height = window.innerHeight - bottomBarHeight;

Â  Â  Â  Â  Â  Â  Â  Â  this.worldContainer.style.width = `${width}px`;
Â  Â  Â  Â  Â  Â  Â  Â  this.worldContainer.style.height = `${height}px`;

Â  Â  Â  Â  Â  Â  Â  Â  this.mainCanvas.width = this.pathCanvas.width = this.entityCanvas.width = width;
Â  Â  Â  Â  Â  Â  Â  Â  this.mainCanvas.height = this.pathCanvas.height = this.entityCanvas.height = height;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  initializeAfterLoading() {
Â  Â  Â  Â  Â  Â  Â  Â  // Ensure sizes are correct after assets might have affected layout (e.g., chest image loading)
Â  Â  Â  Â  Â  Â  Â  Â  this.resizeCanvases();
Â  Â  Â  Â  Â  Â  Â  Â  this.bounds = { width: this.mainCanvas.width, height: this.mainCanvas.height };

Â  Â  Â  Â  Â  Â  Â  Â  this.initializeGameObjects();

Â  Â  Â  Â  Â  Â  Â  Â  // Initialize UIs
Â  Â  Â  Â  Â  Â  Â  Â  this.buffManager.initializeUI();
Â  Â  Â  Â  Â  Â  Â  Â  this.itemManager.initializeUI();

Â  Â  Â  Â  Â  Â  Â  Â  this.finalizeInitialization();
Â  Â  Â  Â  Â  Â  Â  Â  this.setupEventListeners();
Â  Â  Â  Â  Â  Â  Â  Â  this.isInitialized = true;
Â  Â  Â  Â  Â  Â  Â  Â  this.start();
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  initializeGameObjects() {
Â  Â  Â  Â  Â  Â  Â  Â  this.entityManager = new EntityManager(this.entityCtx);
Â  Â  Â  Â  Â  Â  Â  Â  this.worldManager = new WorldManager(this.bounds.width, this.bounds.height, this.pathCtx, this.entityManager, this.assetManager);
Â  Â  Â  Â  Â  Â  Â  Â  this.wanderDot = new WanderDot(this.bounds.width / 2, this.bounds.height / 2);
Â  Â  Â  Â  Â  Â  Â  Â  this.uiManager = new UIManager(this.wanderDot);
Â  Â  Â  Â  Â  Â  Â  Â  this.buffManager = new BuffManager(this.entityManager);
Â  Â  Â  Â  Â  Â  Â  Â  this.itemManager = new ItemManager(this.buffManager);

Â  Â  Â  Â  Â  Â  Â  Â  this.particleManager = new ParticleSystem(this.ctx);
Â  Â  Â  Â  Â  Â  Â  Â  this.ufo = new UFO(this.ctx, this.bounds);
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  finalizeInitialization() {
Â  Â  Â  Â  Â  Â  Â  Â  // Generate the world fresh
Â  Â  Â  Â  Â  Â  Â  Â  this.worldManager.generateGrassField();
Â  Â  Â  Â  Â  Â  Â  Â  this.worldManager.redrawWorld();

Â  Â  Â  Â  Â  Â  Â  Â  // Ensure WanderDot starts within the new boundaries
Â  Â  Â  Â  Â  Â  Â  Â  this.wanderDot.x = Utils.clamp(this.wanderDot.x, Config.BASE_RADIUS, this.bounds.width - Config.BASE_RADIUS);
Â  Â  Â  Â  Â  Â  Â  Â  this.wanderDot.y = Utils.clamp(this.wanderDot.y, Config.BASE_RADIUS, this.bounds.height - Config.BASE_RADIUS);
Â  Â  Â  Â  Â  Â  Â  Â  this.wanderDot.previousX = this.wanderDot.x;
Â  Â  Â  Â  Â  Â  Â  Â  this.wanderDot.previousY = this.wanderDot.y;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // --- EVENTS ---
Â  Â  Â  Â  Â  Â  setupEventListeners() {
Â  Â  Â  Â  Â  Â  Â  Â  window.addEventListener('resize', () => this.handleResize());
Â  Â  Â  Â  Â  Â  Â  Â  this.mainCanvas.addEventListener('pointerdown', (event) => this.handleClick(event));

Â  Â  Â  Â  Â  Â  Â  Â  // Restart button listener
Â  Â  Â  Â  Â  Â  Â  Â  const restartButton = document.getElementById('restart-button');
Â  Â  Â  Â  Â  Â  Â  Â  if (restartButton) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  restartButton.addEventListener('click', () => this.restartGame());
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // Pause/Resume listeners
Â  Â  Â  Â  Â  Â  Â  Â  document.addEventListener('visibilitychange', () => this.handleVisibilityChange());
Â  Â  Â  Â  Â  Â  Â  Â  const resumeButton = document.getElementById('resume-button');
Â  Â  Â  Â  Â  Â  Â  Â  if (resumeButton) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  resumeButton.addEventListener('click', () => this.resumeGame());
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // Handle Visibility Change
Â  Â  Â  Â  Â  Â  handleVisibilityChange() {
Â  Â  Â  Â  Â  Â  Â  Â  if (!this.isInitialized || !this.isRunning) return;

Â  Â  Â  Â  Â  Â  Â  Â  if (document.hidden) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.pauseGame();
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  // We do not auto-resume, waiting for the button click.
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // UPDATED: Pause Game (includes pausing buffs)
Â  Â  Â  Â  Â  Â  pauseGame() {
Â  Â  Â  Â  Â  Â  Â  Â  if (this.isPaused) return;
Â  Â  Â  Â  Â  Â  Â  Â  this.isPaused = true;

Â  Â  Â  Â  Â  Â  Â  Â  // NEW: Pause Buff timers
Â  Â  Â  Â  Â  Â  Â  Â  this.buffManager.pauseAllBuffs();

Â  Â  Â  Â  Â  Â  Â  Â  // Stop the animation loop
Â  Â  Â  Â  Â  Â  Â  Â  if (this.animationFrameId) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  cancelAnimationFrame(this.animationFrameId);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.animationFrameId = null;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // Show the pause overlay
Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('pause-overlay').style.display = 'flex';

Â  Â  Â  Â  Â  Â  Â  Â  // Crucial: Reset lastFrameTime so deltaTime doesn't jump when resuming
Â  Â  Â  Â  Â  Â  Â  Â  this.lastFrameTime = 0;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // UPDATED: Resume Game (includes resuming buffs)
Â  Â  Â  Â  Â  Â  resumeGame() {
Â  Â  Â  Â  Â  Â  Â  Â  if (!this.isPaused) return;
Â  Â  Â  Â  Â  Â  Â  Â  this.isPaused = false;

Â  Â  Â  Â  Â  Â  Â  Â  // NEW: Resume Buff timers
Â  Â  Â  Â  Â  Â  Â  Â  this.buffManager.resumeAllBuffs();

Â  Â  Â  Â  Â  Â  Â  Â  // Hide the pause overlay
Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('pause-overlay').style.display = 'none';

Â  Â  Â  Â  Â  Â  Â  Â  // Restart the animation loop if the game is still running (not game over)
Â  Â  Â  Â  Â  Â  Â  Â  if (this.isRunning) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.animationFrameId = requestAnimationFrame((time) => this.animate(time));
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }


Â  Â  Â  Â  Â  Â  handleResize() {
Â  Â  Â  Â  Â  Â  Â  Â  Â if (!this.isInitialized) return;

Â  Â  Â  Â  Â  Â  Â  Â  // Resize canvases and the world container
Â  Â  Â  Â  Â  Â  Â  Â  this.resizeCanvases();

Â  Â  Â  Â  Â  Â  Â  Â  // Update bounds based on the new canvas size
Â  Â  Â  Â  Â  Â  Â  Â  this.bounds.width = this.mainCanvas.width;
Â  Â  Â  Â  Â  Â  Â  Â  this.bounds.height = this.mainCanvas.height;

Â  Â  Â  Â  Â  Â  Â  Â  // Notify managers to adapt to the new size
Â  Â  Â  Â  Â  Â  Â  Â  this.worldManager.handleResize(this.bounds.width, this.bounds.height);
Â  Â  Â  Â  Â  Â  Â  Â  this.entityManager.needsRedraw = true;
Â  Â  Â  Â  Â  Â  Â  Â  // Update UFO bounds reference
Â  Â  Â  Â  Â  Â  Â  Â  this.ufo.bounds = this.bounds;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  handleClick(event) {
Â  Â  Â  Â  Â  Â  Â  Â  // UPDATED: Prevent clicks if the game is over or paused
Â  Â  Â  Â  Â  Â  Â  Â  if (!this.isRunning || this.isPaused) return;

Â  Â  Â  Â  Â  Â  Â  Â  // Prevent default browser behavior
Â  Â  Â  Â  Â  Â  Â  Â  event.preventDefault();

Â  Â  Â  Â  Â  Â  Â  Â  const clickX = event.clientX;
Â  Â  Â  Â  Â  Â  Â  Â  const clickY = event.clientY;

Â  Â  Â  Â  Â  Â  Â  Â  // Check if click is on the thought bubble
Â  Â  Â  Â  Â  Â  Â  Â  if (this.uiManager.thoughtBubble.style.display === 'block') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const bubbleRect = this.uiManager.thoughtBubble.getBoundingClientRect();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (clickX >= bubbleRect.left && clickX <= bubbleRect.right &&
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  clickY >= bubbleRect.top && clickY <= bubbleRect.bottom) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  const currentTime = Date.now();
Â  Â  Â  Â  Â  Â  Â  Â  const timeDiff = currentTime - this.lastClickTime;

Â  Â  Â  Â  Â  Â  Â  Â  const distanceToCenter = Utils.distance(clickX, clickY, this.wanderDot.x, this.wanderDot.y - this.wanderDot.verticalOffset);
Â  Â  Â  Â  Â  Â  Â  Â  const isDirectClick = distanceToCenter <= this.wanderDot.radius;

Â  Â  Â  Â  Â  Â  Â  Â  let commandAccepted = false;

Â  Â  Â  Â  Â  Â  Â  Â  // Try to issue command
Â  Â  Â  Â  Â  Â  Â  Â  if (!isDirectClick) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â commandAccepted = this.wanderDot.setTarget(clickX, clickY);
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Direct click always registers as interaction (unless Hangry)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  commandAccepted = !this.wanderDot.isHangry;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (commandAccepted) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.wanderDot.clearTarget();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Cancel eating on direct click.
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.wanderDot.isEating) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.wanderDot.eatingStartTime > 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.wanderDot.triggerHangry(true); // Interrupted
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  commandAccepted = false;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Cancel seeking without penalty
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.wanderDot.isEating = false;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.wanderDot.eatingTarget = null;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.uiManager.getCurrentThought() === Config.Emojis.EATING_SEEKING) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.uiManager.hideThought();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // Calculate and apply annoyance from the click itself
Â  Â  Â  Â  Â  Â  Â  Â  if (commandAccepted || this.wanderDot.isHangry) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Annoyance from clicks is still applied on top of the natural decay/restoration
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const annoyanceToAdd = Math.min(35, 10 + (2500 / timeDiff));
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const reactionEmoji = this.wanderDot.addAnnoyance(annoyanceToAdd, isDirectClick);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Show reaction thought, unless chewing
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (!(this.wanderDot.isEating && this.wanderDot.eatingStartTime > 0)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â this.uiManager.showThought(reactionEmoji);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // Manage Mad Timer
Â  Â  Â  Â  Â  Â  Â  Â  const currentMood = this.wanderDot.currentMoodState;
Â  Â  Â  Â  Â  Â  Â  Â  if (currentMood === 'mad' && !this.uiManager.madThoughtTimer) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â this.uiManager.startMadTimer();
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  this.lastClickTime = currentTime;
Â  Â  Â  Â  Â  Â  Â  Â  this.uiManager.scheduleNextIdleThought();
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  checkGameOver() {
Â  Â  Â  Â  Â  Â  Â  Â  // Game over if annoyance hits 100 AND hunger hits 0
Â  Â  Â  Â  Â  Â  Â  Â  if (this.wanderDot.annoyance >= 100 && this.wanderDot.hunger <= 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.gameOver();
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // UPDATED: Use accumulatedGameTime for the final score.
Â  Â  Â  Â  Â  Â  gameOver() {
Â  Â  Â  Â  Â  Â  Â  Â  this.isRunning = false;
Â  Â  Â  Â  Â  Â  Â  Â  this.isPaused = false; // Ensure pause state is cleared
Â  Â  Â  Â  Â  Â  Â  Â  if (this.animationFrameId) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  cancelAnimationFrame(this.animationFrameId);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.animationFrameId = null;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // Calculate survival time using the accumulated active game time
Â  Â  Â  Â  Â  Â  Â  Â  const elapsedTime = this.accumulatedGameTime;
Â  Â  Â  Â  Â  Â  Â  Â  // const elapsedTime = Date.now() - this.worldCreationTime; // Old implementation
Â  Â  Â  Â  Â  Â  Â  Â  const elapsedSeconds = Math.floor(elapsedTime / 1000);
Â  Â  Â  Â  Â  Â  Â  Â  const minutes = Math.floor(elapsedSeconds / 60);
Â  Â  Â  Â  Â  Â  Â  Â  const seconds = elapsedSeconds % 60;
Â  Â  Â  Â  Â  Â  Â  Â  const survivalTimeText = `[${minutes}m:${seconds.toString().padStart(2, '0')}s]`;

Â  Â  Â  Â  Â  Â  Â  Â  // Show the modal
Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('survival-time').textContent = survivalTimeText;
Â  Â  Â  Â  Â  Â  Â  Â  const gameOverOverlay = document.getElementById('game-over-overlay');
Â  Â  Â  Â  Â  Â  Â  Â  gameOverOverlay.style.display = 'flex';
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  restartGame() {
Â  Â  Â  Â  Â  Â  Â  Â  // Easiest way to reset the entire state
Â  Â  Â  Â  Â  Â  Â  Â  location.reload();
Â  Â  Â  Â  Â  Â  }


Â  Â  Â  Â  Â  Â  // Main game loop
Â  Â  Â  Â  Â  Â  animate(currentTime) {
Â  Â  Â  Â  Â  Â  Â  Â  // UPDATED: Check if running
Â  Â  Â  Â  Â  Â  Â  Â  if (!this.isRunning) return;
Â  Â  Â  Â  Â  Â  Â  Â  this.animationFrameId = requestAnimationFrame((time) => this.animate(time));

Â  Â  Â  Â  Â  Â  Â  Â  // If paused, we skip the update/draw logic but keep the RAF loop going (or rely on cancel/restart in pause/resume)
Â  Â  Â  Â  Â  Â  Â  Â  // We rely on cancel/restart in pause/resume, so if we are here, we assume we are not paused.

Â  Â  Â  Â  Â  Â  Â  Â  if (!this.isInitialized) return;

Â  Â  Â  Â  Â  Â  Â  Â  if (!this.lastFrameTime) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.lastFrameTime = currentTime;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  const deltaTime = (currentTime - this.lastFrameTime) / 1000;

Â  Â  Â  Â  Â  Â  Â  Â  // Handle large deltaTime spikes (often happens after resuming from a long pause)
Â  Â  Â  Â  Â  Â  Â  Â  if (deltaTime > 0.1) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â this.lastFrameTime = currentTime;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â this.updateTimeBasedSystems();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â return;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  this.lastFrameTime = currentTime;

Â  Â  Â  Â  Â  Â  Â  Â  this.update(deltaTime);
Â  Â  Â  Â  Â  Â  Â  Â  this.draw(deltaTime);
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // UPDATED: Pass accumulatedGameTime to UIManager
Â  Â  Â  Â  Â  Â  updateTimeBasedSystems() {
Â  Â  Â  Â  Â  Â  Â  Â  this.entityManager.update(this.worldManager);
Â  Â  Â  Â  Â  Â  Â  Â  this.buffManager.update();
Â  Â  Â  Â  Â  Â  Â  Â  // Pass the accumulated game time instead of worldCreationTime
Â  Â  Â  Â  Â  Â  Â  Â  this.uiManager.update(this.accumulatedGameTime);
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  update(deltaTime) {
Â  Â  Â  Â  Â  Â  Â  Â  // NEW: Accumulate active game time
Â  Â  Â  Â  Â  Â  Â  Â  this.accumulatedGameTime += deltaTime * 1000; // deltaTime is in seconds, store in ms

Â  Â  Â  Â  Â  Â  Â  Â  // Update WanderDot
Â  Â  Â  Â  Â  Â  Â  Â  // Pass entityManager to WanderDot update for flower detection
Â  Â  Â  Â  Â  Â  Â  Â  const transitionEmoji = this.wanderDot.update(deltaTime, this.bounds, this.buffManager, this.worldManager, this.entityManager);

Â  Â  Â  Â  Â  Â  Â  Â  // Check for game over after WanderDot updates its state
Â  Â  Â  Â  Â  Â  Â  Â  this.checkGameOver();
Â  Â  Â  Â  Â  Â  Â  Â  if (!this.isRunning) return;

Â  Â  Â  Â  Â  Â  Â  Â  if (transitionEmoji) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.uiManager.showThought(transitionEmoji);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (transitionEmoji === Config.Emojis.cooldownToAnnoyed[0]) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.uiManager.stopMadTimer();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  this.updateTimeBasedSystems();

Â  Â  Â  Â  Â  Â  Â  Â  // Update grass animations and health
Â  Â  Â  Â  Â  Â  Â  Â  this.worldManager.updateGrass(deltaTime);

Â  Â  Â  Â  Â  Â  Â  Â  // NEW: Update mist decay
Â  Â  Â  Â  Â  Â  Â  Â  this.worldManager.updateMistDecay(deltaTime);

Â  Â  Â  Â  Â  Â  Â  Â  // Update UFO
Â  Â  Â  Â  Â  Â  Â  Â  this.ufo.update(deltaTime, this.particleManager, this.worldManager);
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // Implements dynamic sorting (Painter's Algorithm) for grass and WanderDot.
Â  Â  Â  Â  Â  Â  // UPDATED: Uses the pre-sorted grass array for massive performance improvement.
Â  Â  Â  Â  Â  Â  draw(deltaTime) {
Â  Â  Â  Â  Â  Â  Â  Â  // Clear main canvas
Â  Â  Â  Â  Â  Â  Â  Â  this.ctx.clearRect(0, 0, this.bounds.width, this.bounds.height);

Â  Â  Â  Â  Â  Â  Â  Â  // Draw environment/entities (on their respective canvases)
Â  Â  Â  Â  Â  Â  Â  Â  this.entityManager.draw(this.bounds);

Â  Â  Â  Â  Â  Â  Â  Â  // --- Optimized Z-sorting (using pre-sorted list) ---

Â  Â  Â  Â  Â  Â  Â  Â  const wanderDotY = this.wanderDot.getBaseY();
Â  Â  Â  Â  Â  Â  Â  Â  // The list is already sorted by Y in WorldManager.
Â  Â  Â  Â  Â  Â  Â  Â  const blades = this.worldManager.grassBlades;
Â  Â  Â  Â  Â  Â  Â  Â  let wanderDotDrawn = false;

Â  Â  Â  Â  Â  Â  Â  Â  // Iterate through the pre-sorted list
Â  Â  Â  Â  Â  Â  Â  Â  for (let i = 0; i < blades.length; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const blade = blades[i];

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Check if it's time to draw WanderDot (when we encounter the first blade in front of the dot)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (!wanderDotDrawn && blade.y > wanderDotY) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.wanderDot.draw(this.ctx);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  wanderDotDrawn = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Draw the blade
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Future Optimization: Viewport culling could be added here to skip drawBlade if blade is offscreen.
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.worldManager.drawBlade(this.ctx, blade);
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // If WanderDot is in front of all grass (or if there is no grass)
Â  Â  Â  Â  Â  Â  Â  Â  if (!wanderDotDrawn) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.wanderDot.draw(this.ctx);
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // Draw actors always on top (UFO)
Â  Â  Â  Â  Â  Â  Â  Â  this.ufo.draw();

Â  Â  Â  Â  Â  Â  Â  Â  // Draw particles (always on top)
Â  Â  Â  Â  Â  Â  Â  Â  this.particleManager.updateAndDraw(deltaTime);
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  start() {
Â  Â  Â  Â  Â  Â  Â  Â  // Start is called after assets load in initializeAfterLoading
Â  Â  Â  Â  Â  Â  Â  Â  this.isRunning = true;
Â  Â  Â  Â  Â  Â  Â  Â  this.isPaused = false;
Â  Â  Â  Â  Â  Â  Â  Â  this.uiManager.scheduleNextIdleThought();
Â  Â  Â  Â  Â  Â  Â  Â  this.animationFrameId = requestAnimationFrame((time) => this.animate(time));
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  // ====================================================================
Â  Â  Â  Â  // 8. STARTUP
Â  Â  Â  Â  // ====================================================================
Â  Â  Â  Â  document.addEventListener('DOMContentLoaded', () => {
Â  Â  Â  Â  Â  Â  // Check for Brown Mushroom emoji support
Â  Â  Â  Â  Â  Â  if (!Utils.checkEmojiSupport(Config.Emojis.BROWN_MUSHROOM)) {
Â  Â  Â  Â  Â  Â  Â  Â  Config.Emojis.BROWN_MUSHROOM = 'ğŸ¥€';
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // Initialization starts here.
Â  Â  Â  Â  Â  Â  const game = new Game();
Â  Â  Â  Â  });

Â  Â  </script>
</body>
</html>
