<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>WanderDot's World</title>
    <style>
        /* --- 1. CSS VARIABLES & SETUP --- */
        :root {
            --color-field-bg: #013220;
            --color-ui-border: #ccc;
            --color-text: white;
            --color-eureka-glow: gold;
            --color-thought-bg: rgba(25, 25, 112, 0.5);
            --font-main: monospace;
        }

        /* Strict overflow hidden to prevent mobile scrolling/OOB viewing */
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            width: 100%;
            height: 100%;
        }

        body {
            background-color: var(--color-field-bg);
            font-family: var(--font-main);
            cursor: default;
            user-select: none;
            /* Ensure pixel art scales cleanly */
            image-rendering: crisp-edges; /* Fallback */
            image-rendering: pixelated;   /* Preferred */
        }

        /* --- 2. WORLD CONTAINERS & LAYERS --- */
        #world-container {
            position: relative;
            /* Dimensions are set explicitly by JS (Game.resizeCanvases) */
            overflow: hidden;
        }

        canvas {
            display: block;
            position: absolute;
            top: 0; left: 0;
        }

        /* Z-Index layering */
        #pathCanvas { z-index: 1; }
        #entityCanvas { z-index: 2; }
        #mainCanvas { z-index: 3; } /* Handles Grass, WanderDot, UFO, Particles */

        /* --- 3. UI ELEMENTS --- */

        /* Pause Modal (NEW) */
        #pause-overlay {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: none; /* Hidden by default */
            align-items: center;
            justify-content: center;
            z-index: 99;
            color: var(--color-text);
            text-align: center;
        }

        #pause-modal {
            background-color: rgba(30, 30, 30, 0.9);
            padding: 20px 40px;
            border-radius: 10px;
            border: 2px solid var(--color-ui-border);
        }
        #pause-modal h2 {
             font-size: 1.5rem;
             margin-bottom: 15px;
        }

        #resume-button {
            padding: 8px 16px;
            font-size: 1rem;
            background-color: #008CBA;
            border: none;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        #resume-button:hover {
            background-color: #007B9A;
        }


        /* Game Over Modal (NEW) */
        #game-over-overlay {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: none; /* Hidden by default */
            align-items: center;
            justify-content: center;
            z-index: 100;
            color: var(--color-text);
            text-align: center;
        }

        #game-over-modal {
            background-color: #333;
            padding: 30px 50px;
            border-radius: 15px;
            border: 3px solid var(--color-ui-border);
            box-shadow: 0 0 30px rgba(255, 50, 50, 0.5);
        }

        #game-over-modal h1 {
            font-size: 2.5rem;
            color: #FF6347; /* Tomato Red */
            margin-bottom: 20px;
        }

        #game-over-modal p {
            font-size: 1.2rem;
            margin-bottom: 30px;
        }

        #restart-button {
            padding: 10px 20px;
            font-size: 1.1rem;
            background-color: #4CAF50;
            border: none;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        #restart-button:hover {
            background-color: #45a049;
        }


        /* Thought Bubble */
        #thought-bubble {
            position: absolute;
            display: none;
            font-size: 2.5rem; /* Default font size, can be changed dynamically by UIManager */
            padding: 0.6rem;
            background-color: var(--color-thought-bg);
            border: 2px solid var(--color-ui-border);
            border-radius: 50%;
            backdrop-filter: blur(3px);
            transition: opacity 0.3s ease-in-out, left 0.1s linear, top 0.1s linear;
            z-index: 4;
            cursor: pointer;
            transform: translate(-50%, -50%);
            white-space: nowrap;
        }

        .is-rising {
            animation: rise-up 0.4s cubic-bezier(0.18, 0.89, 0.32, 1.28);
        }

        #thought-bubble > span {
            pointer-events: none;
        }

        /* Buff Container */
        #buff-container {
            position: absolute;
            top: 20px; right: 20px;
            display: flex;
            flex-direction: row-reverse;
            gap: 15px;
            z-index: 5;
        }

        .buff-indicator {
            display: none;
            flex-direction: column;
            align-items: center;
            text-shadow: 0 0 5px black;
        }

        .buff-icon {
            font-size: 1.5rem;
            transition: box-shadow 0.3s ease-in-out;
        }

        .eureka-state .buff-icon {
            border-radius: 5px;
            box-shadow: 0 0 8px 3px var(--color-eureka-glow);
        }

        .buff-timer {
            font-size: 0.8rem;
            color: var(--color-text);
            margin-top: 2px;
        }

        /* Bottom Bar (NEW) */
        #bottom-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            /* Define a height for the bar */
            height: 80px;
            background-color: rgba(30, 30, 30, 0.9);
            border-top: 2px solid var(--color-ui-border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 15px;
            box-sizing: border-box;
            z-index: 10; /* Highest Z-index */
        }

        /* Stats Container (NEW) */
        #stats-container {
            display: flex;
            gap: 25px;
            color: var(--color-text);
            font-size: 1.1rem;
        }

        .stat-item {
            white-space: nowrap;
        }

        /* Bar Graphs (NEW) */
        #bar-graphs-container {
            display: flex;
            flex-direction: column;
            gap: 8px;
            flex-grow: 1;
            max-width: 350px;
            margin: 0 30px;
        }

        .graph-wrapper {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .graph-label {
            color: var(--color-text);
            font-size: 0.9rem;
            width: 60px;
            text-align: right;
        }

        .graph-bar {
            flex-grow: 1;
            height: 22px;
            background-color: #444;
            border-radius: 5px;
            overflow: hidden;
            position: relative;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.3);
        }

        .graph-bar-fill {
            height: 100%;
            width: 100%;
            transition: width 0.5s ease-in-out, background-color 0.5s ease-in-out;
        }

        .graph-bar-text {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            /* Start hidden (UPDATED) */
            color: rgba(255, 255, 255, 1);
            opacity: 0;
            font-size: 0.75rem;
            pointer-events: none;
            transition: opacity 0.5s ease-in-out;
            text-shadow: 0 0 5px black;
        }

        /* Show text when state is active (NEW) */
        .graph-bar.active-state .graph-bar-text {
            opacity: 1;
        }


        /* World Timer Display (NEW) */
        #world-timer-display {
            color: var(--color-text);
            font-size: 1.1rem;
            margin-right: 25px;
        }

        /* Chest Container & Button (NEW) */
        #chest-container {
            position: relative; /* Anchor point for the item bar */
        }

        #chest-button {
            width: 64px;
            height: 64px;
            /* Background image set by AssetManager */
            background-repeat: no-repeat;
            background-position: center center;
            background-size: contain;
            background-color: transparent;
            border: none;
            cursor: pointer;
            padding: 0;
            transition: transform 0.1s ease-out;
        }

        #chest-button:active {
            transform: scale(0.9);
        }

        /* Item Bar (UPDATED) */
        #item-bar {
            position: absolute;
            /* Repositioned to align vertically above the chest */
            bottom: 75px; /* Above the chest button */
            right: 0;
            transform: none; /* Removed translateX */
            background-color: rgba(30, 30, 30, 0.85);
            border: 2px solid var(--color-ui-border);
            border-bottom: none;
            border-radius: 10px 10px 0 0;
            padding: 5px;
            display: flex;
            flex-direction: column-reverse; /* Items stack upwards */
            gap: 5px;
            z-index: 5;
            /* Updated transition for sliding up */
            transition: max-height 0.4s ease-in-out, opacity 0.3s ease-in-out;
            max-height: 0;
            opacity: 0;
            overflow: hidden;
        }

        #item-bar.visible {
            /* Set a max-height large enough for several items */
            max-height: 500px;
            opacity: 1;
        }

        .item-button {
            background-color: #333;
            border: 2px solid #888;
            border-radius: 5px;
            color: var(--color-text);
            font-size: 1rem;
            width: 60px; height: 60px;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .item-button.visible {
            display: flex;
        }

        .item-button.clicked {
            animation: use-item-anim 0.2s ease-out;
        }

        /* --- 3.5. MOBILE RESPONSIVENESS (UPDATED) --- */
        @media (max-width: 768px) {
             #bottom-bar {
                 height: 110px; /* Taller on mobile */
                 flex-wrap: wrap;
                 padding: 5px 10px;
            }
            #stats-container {
                font-size: 0.9rem;
                gap: 15px;
            }
            #world-timer-display {
                font-size: 0.9rem;
                margin-right: 15px;
            }
            #bar-graphs-container {
                width: 100%;
                order: 2; /* Move graphs below stats/chest */
                margin: 5px 0 0 0;
                max-width: none;
            }
             .graph-label {
                 font-size: 0.8rem;
                 width: 50px;
            }
            .graph-bar {
                height: 18px;
            }
        }


        /* --- 4. KEYFRAME ANIMATIONS (Unchanged) --- */
        @keyframes rise-up {
            from { opacity: 0; transform: translate(-50%, -50%) scale(0.4); }
            to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }

        @keyframes blink {
            50% { opacity: 0.2; }
        }
        .blinking {
            animation: blink 0.5s infinite;
        }

        @keyframes blip-out {
            to { transform: scale(0); opacity: 0; }
        }
        .blip-out {
            animation: blip-out 0.3s forwards;
        }

        @keyframes use-item-anim {
            50% { transform: scale(0.85); }
        }

    </style>
</head>
<body>
    <div id="world-container">
        <canvas id="pathCanvas"></canvas>
        <canvas id="entityCanvas"></canvas>
        <canvas id="mainCanvas"></canvas>

        <div id="thought-bubble"></div>
        <div id="buff-container"></div>
    </div>

    <div id="pause-overlay">
        <div id="pause-modal">
            <h2>Game Paused</h2>
            <button id="resume-button">Resume</button>
        </div>
    </div>

    <div id="game-over-overlay">
        <div id="game-over-modal">
            <h1>GAME OVER</h1>
            <p>Under your watchful eye, WanderDot survived for <span id="survival-time">[00m:00s]</span>.</p>
            <button id="restart-button">Restart Game</button>
        </div>
    </div>

   <div id="bottom-bar">
        <div id="stats-container">
            <div class="stat-item" id="stat-strength">💪: <span></span></div>
            <div class="stat-item" id="stat-radius">⭕: <span></span></div>
            <div class="stat-item" id="stat-speed">🏁: <span></span></div>
        </div>
        <div id="bar-graphs-container">
            <div class="graph-wrapper">
                <div class="graph-label">Mood</div>
                <div class="graph-bar" id="mood-bar-bg">
                    <div class="graph-bar-fill" id="mood-bar-fill"></div>
                    <span class="graph-bar-text">Mad</span>
                </div>
            </div>
            <div class="graph-wrapper">
                <div class="graph-label">Hunger</div>
                <div class="graph-bar" id="hunger-bar-bg">
                    <div class="graph-bar-fill" id="hunger-bar-fill"></div>
                    <span class="graph-bar-text">Hangry</span>
                </div>
            </div>
        </div>
        <div id="world-timer-display">[00m:00s]</div>
        <div id="chest-container">
             <div id="item-bar"></div>
             <button id="chest-button"></button>
        </div>
    </div>

    <script>
        // ====================================================================
        // 0. CONFIGURATION & UTILITIES
        // ====================================================================

        const Config = {
            // Mood Thresholds
            WARNING_ANNOYANCE_THRESHOLD: 45,
            ANNOYANCE_THRESHOLD: 55,
            MAD_THRESHOLD: 75,

            // Mood/Hunger Interaction
            MOOD_HUNGER_DRAIN_MULTIPLIER: 2.0, // Hunger drains 2x faster when mad/annoyed
            HUNGER_MOOD_DRAIN_MULTIPLIER: 0.5, // Mood restoration is 50% slower when hungry

            // Mood Mechanics
            MOOD_DECAY_PER_SECOND: 0.3,     // Baseline annoyance increase (Mood decrease). Takes ~5.5 mins to reach max if idle.
            MOOD_BOOST_FLOWER_RADIUS: 100,    // Radius to gain mood boost from flowers
            MOOD_BOOST_FLOWER_RATE: 3.5,     // Annoyance decrease per second near a flower
            // MOOD_BOOST_IDLE_THOUGHT: 10,  // Removed: Replaced by click-based boost
            MOOD_BOOST_CLICKABLE_THOUGHT: 5, // NEW: Annoyance decrease when a positive thought (🎮, 🎥) is clicked


            // Colors
            COLOR_NORMAL: { r: 255, g: 255, b: 224 },
            COLOR_HAPPY: { r: 144, g: 238, b: 144 }, // NEW: LightGreen for happy/kangaroo mood
            COLOR_ANNOYED: { r: 255, g: 165, b: 0 },
            COLOR_MAD: { r: 152, g: 14, b: 11 },
            COLOR_HANGRY_GLOW: 'rgba(255, 100, 100, 0.7)',

            // Terrain Colors
            COLOR_FIELD: { r: 1, g: 50, b: 32 },
            COLOR_DIRT: { r: 101, g: 67, b: 33 },
            COLOR_ALIEN_BLUE: { r: 100, g: 149, b: 237 },
            COLOR_ALIEN_CLAY: { r: 205, g: 133, b: 63 },

            // World Grid
            GRID_CELL_SIZE: 10,
            MAX_WEAR: 100,
            WEAR_PER_PIXEL: 0.05, // Wear applied to the dirt path

            // Grass Configuration
            GRASS_CLUMP_COUNT: 300,
            GRASS_CLUMP_MIN_SIZE: 3,
            GRASS_CLUMP_MAX_SIZE: 6,
            GRASS_CLUMP_RADIUS: 15,

            GRASS_DEATH_THRESHOLD: 0.05,
            GRASS_SLIDE_DISTANCE: 10,
            GRASS_BEND_ANGLE: 45 * (Math.PI / 180),

            // Legacy thresholds
            GRASS_REMOVAL_THRESHOLD: 50,
            PEBBLE_SPAWN_THRESHOLD: 70,

            UFO_MUSHROOM_CHANCE: 0.015,

            // WanderDot Base Stats
            BASE_SPEED: 120,
            BASE_RADIUS: 20,
            EAT_MUSHROOM_CHANCE: 0.02,
            EAT_DETECTION_RADIUS: 100,
            EAT_DURATION: 4000,

            // Hunger Mechanics (NEW)
            MAX_HUNGER: 100,
            HUNGER_DECAY_PER_SECOND: 0.5, // Takes 200 seconds (3.3 mins) to get very hungry
            HANGRY_HUNGER_THRESHOLD: 20,
            MUSHROOM_HUNGER_RESTORE: 50,
            // PIZZA_HUNGER_RESTORE is defined in Buffs/Items

            // Kangaroo Mechanics
            BOUNCE_DISTANCE: 120,
            BOUNCE_HEIGHT: 60,
            BASE_IMPACT_WEAR: 15,

            // Buffs & Items Configuration
            WATCH_TIME_EXTENSION: 20000,
            MUSHROOM_BUFF_DURATION: 20000,
            SEED_MATURATION_TIME: 60000,

            Items: {
                watch: { emoji: '⌚', type: 'utility' },
                coffee: { emoji: '☕', type: 'buff', duration: 20000 },
                pizza: { emoji: '🍕', type: 'buff', duration: 30000, hungerRestore: 100 }, // NEW: Pizza restores hunger
                kangaroo: { emoji: '🦘', type: 'buff', duration: 30000 },
                lightbulb: { emoji: '💡', type: 'utility' },
                mushroom: { emoji: '🍄', type: 'buff', hideTimer: true }
            },

            // Emojis
            Emojis: {
                // Note: Using 🎥 (Film Frames) as it was in the original code list, matching the user request for 📽️ (Projector) functionality.
                idle: ['💡', '😴', '🎮', '🎶', '☕', '⌚', '🍕', '👽', '🦘','🎥'],
                commandReceived: ['🤔','👀'],
                annoyed: ['😒', '🙄', '😑', '🤨'],
                mad: ['😫', '🤡', '👺', '😡', '🤬'],
                madZone: ['👿', '☠️', '👎', '🤬'],
                cooldownToAnnoyed: ['😤'],
                cooldownToNormal: ['🥰'],
                directClick: ['😘', '🤭', '😛', '😳', '🥵', '🍆', '💦'],
                EATING_SEEKING: '👅',
                EATING_CONSUMING: '🤤',
                EATING_SATISFIED: '😋',
                // Entities
                SEED: '🥔',
                FLOWER: '🌼',
                BROWN_MUSHROOM: '🍄‍🟫',
                DIAMOND: '🔸',
            },

            // Asset Paths
            Assets: {
                grass: [
                    '../images/grass/grass_blade_01.png',
                    '../images/grass/grass_blade_02.png',
                    '../images/grass/grass_blade_03.png',
                    '../images/grass/grass_blade_04.png',
                    '../images/grass/grass_blade_05.png',
                    '../images/grass/grass_blade_06.png',
                ],
                alienGrass: [
                     // Assuming these paths exist for blue grass visualization
                    '../images/grass/alien_grass_blade_01.png',
                    '../images/grass/alien_grass_blade_02.png',
                    '../images/grass/alien_grass_blade_03.png',
                    '../images/grass/alien_grass_blade_04.png',
                    '../images/grass/alien_grass_blade_05.png',
                    '../images/grass/alien_grass_blade_06.png',
                ],
                chest: '../images/textures/chest.png' // NEW
            }
        };

        // Terrain Types Enum
        const TerrainType = {
            NORMAL: 'normal',
            ALIEN_BLUE: 'alienBlue',
            ALIEN_CLAY: 'alienClay'
        };

        const Utils = {
            lerp(start, end, amount) {
                return start * (1 - amount) + end * amount;
            },
            lerpColor(colorA, colorB, amount) {
                const r = Math.round(Utils.lerp(colorA.r, colorB.r, amount));
                const g = Math.round(Utils.lerp(colorA.g, colorB.g, amount));
                const b = Math.round(Utils.lerp(colorA.b, colorB.b, amount));
                return `rgb(${r}, ${g}, ${b})`;
            },
            randomChoice(arr) {
                return arr[Math.floor(Math.random() * arr.length)];
            },
            distance(x1, y1, x2, y2) {
                return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
            },
            clamp(num, min, max) {
                return Math.max(min, Math.min(max, num));
            },
            randomRange(min, max) {
                return Math.random() * (max - min) + min;
            },
            checkEmojiSupport(emoji) {
                try {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    if (!ctx) return true;

                    ctx.font = '20px sans-serif';
                    const metrics = ctx.measureText(emoji);
                    const baselineMetrics = ctx.measureText('🍄');

                    return metrics.width <= baselineMetrics.width * 1.5;
                } catch (e) {
                    console.warn("Emoji support check failed, assuming support:", e);
                    return true;
                }
            }
        };

        // ====================================================================
        // 0.5. ASSET MANAGER
        // ====================================================================

        // (AssetManager implementation remains unchanged)
        class AssetManager {
            constructor() {
                this.images = {
                    grass: [],
                    alienGrass: [],
                    chest: null
                };
                this.loadedCount = 0;
                this.totalCount = 0;
            }

            loadAll(onComplete) {
                const grassPaths = Config.Assets.grass;
                const alienGrassPaths = Config.Assets.alienGrass;
                const chestPath = Config.Assets.chest;

                // Count total assets
                this.totalCount = grassPaths.length + alienGrassPaths.length + (chestPath ? 1 : 0);

                if (this.totalCount === 0) {
                    onComplete();
                    return;
                }

                // Unified load/error handling
                const onLoad = () => {
                    this.loadedCount++;
                    if (this.loadedCount === this.totalCount) {
                        onComplete();
                    }
                };

                const onError = (path) => {
                    console.error(`Failed to load asset: ${path}. Ensure the path is correct.`);
                    onLoad(); // Proceed even if an asset fails
                };

                 // Load Chest
                if (chestPath) {
                    const img = new Image();
                    img.src = chestPath;
                    img.onload = () => {
                        this.images.chest = img;
                        // Apply the loaded image to the button background
                        const chestButton = document.getElementById('chest-button');
                        if (chestButton) {
                            chestButton.style.backgroundImage = `url('${chestPath}')`;
                        }
                        onLoad();
                    };
                    img.onerror = () => {
                         console.error(`Failed to load chest asset: ${chestPath}. Using fallback.`);
                         // Fallback if image fails
                         const chestButton = document.getElementById('chest-button');
                         if (chestButton) {
                             chestButton.textContent = '📦';
                             chestButton.style.fontSize = '2.5rem';
                         }
                         onError(chestPath);
                    };
                }

                // Load standard grass
                grassPaths.forEach((path, index) => {
                    const img = new Image();
                    img.src = path;
                    img.onload = () => {
                        this.images.grass[index] = img;
                        onLoad();
                    };
                    img.onerror = () => onError(path);
                });

                // Load alien grass
                alienGrassPaths.forEach((path, index) => {
                    const img = new Image();
                    img.src = path;
                    img.onload = () => {
                        this.images.alienGrass[index] = img;
                        onLoad();
                    };
                    img.onerror = () => onError(path);
                });
            }
        }

        // ====================================================================
        // 1. ENTITY MANAGER (Seeds, Diamonds, Pebbles, Mushrooms)
        // ====================================================================

        // UPDATED: Added helper for finding nearby dynamic entities.
        class EntityManager {
            constructor(ctx) {
                this.ctx = ctx;
                this.pebbles = [];
                this.mushrooms = [];
                this.dynamicEntities = [];
                this.needsRedraw = true;
            }

            // --- Dynamic Entities ---
            addEntity(type, x, y, data = {}) {
                const entity = {
                    type: type,
                    x: x, y: y,
                    createdAt: Date.now(),
                    ...data
                };
                this.dynamicEntities.push(entity);
                this.needsRedraw = true;
            }

            // NEW: Helper to find nearby dynamic entities of a specific type
            getNearbyDynamicEntities(type, x, y, radius) {
                const nearby = [];
                const radiusSq = radius * radius;

                for (const entity of this.dynamicEntities) {
                    if (entity.type === type) {
                        const distSq = (entity.x - x)**2 + (entity.y - y)**2;
                        if (distSq < radiusSq) {
                            nearby.push(entity);
                        }
                    }
                }
                return nearby;
            }

            removeDynamicEntitiesInArea(x, y, radius) {
                let removed = false;
                const radiusSq = radius * radius;
                const destructibleTypes = ['flower', 'brownMushroom'];

                for (let i = this.dynamicEntities.length - 1; i >= 0; i--) {
                    const entity = this.dynamicEntities[i];

                    if (destructibleTypes.includes(entity.type)) {
                        const distSq = (entity.x - x)**2 + (entity.y - y)**2;
                        // Check if the entity center is within the radius
                        if (distSq < radiusSq) {
                            this.dynamicEntities.splice(i, 1);
                            removed = true;
                        }
                    }
                }

                if (removed) {
                    this.needsRedraw = true;
                }
                return removed;
            }


            update(worldManager) {
                const now = Date.now();
                for (let i = this.dynamicEntities.length - 1; i >= 0; i--) {
                    const entity = this.dynamicEntities[i];

                    if (entity.type === 'seed') {
                        if (now - entity.createdAt > Config.SEED_MATURATION_TIME) {
                            this.matureSeed(entity, i, worldManager);
                        }
                    }
                }
            }

            matureSeed(seed, index, worldManager) {
                const terrainInfo = worldManager.getTerrainInfoAtPoint(seed.x, seed.y);
                let newType = null;

                // Maturation still relies on the underlying dirt path wear level
                if (terrainInfo.wear < Config.GRASS_REMOVAL_THRESHOLD) {
                    if (terrainInfo.type === TerrainType.NORMAL) {
                        newType = 'flower';
                    } else if (terrainInfo.type === TerrainType.ALIEN_BLUE) {
                        newType = 'brownMushroom';
                    }
                }

                if (newType) {
                    seed.type = newType;
                } else {
                    this.dynamicEntities.splice(index, 1);
                }
                this.needsRedraw = true;
            }

            // --- Static Entities (Pebbles, Mushrooms) (Unchanged) ---
            addPebble(pebble) {
                this.pebbles.push(pebble);
                this.needsRedraw = true;
            }

            addMushroom(mushroom) {
                if(!this.mushrooms.some(m => m.gridX === mushroom.gridX && m.gridY === mushroom.gridY)) {
                    this.mushrooms.push(mushroom);
                    this.needsRedraw = true;
                    return true;
                }
                return false;
            }

            removeMushroomByObject(mushroomObject) {
                const index = this.mushrooms.indexOf(mushroomObject);
                if (index > -1) {
                    this.mushrooms.splice(index, 1);
                    this.needsRedraw = true;
                    return true;
                }
                return false;
            }

            removeMushroomInArea(x, y, radius) {
                let removed = false;
                for(let i = this.mushrooms.length - 1; i >= 0; i--) {
                    const m = this.mushrooms[i];
                    if (Utils.distance(m.x, m.y, x, y) < radius) {
                        this.mushrooms.splice(i, 1);
                        removed = true;
                    }
                }
                if (removed) this.needsRedraw = true;
                return removed;
            }

            getNearbyMushroom(x, y, radius) {
                let closest = null;
                let minDistSq = radius * radius;

                for (const m of this.mushrooms) {
                    const distSq = (m.x - x)**2 + (m.y - y)**2;
                    if (distSq < minDistSq) {
                        minDistSq = distSq;
                        closest = m;
                    }
                }
                return closest;
            }

            // --- Rendering (Unchanged) ---
            draw(bounds) {
                if (!this.needsRedraw) return;

                this.ctx.clearRect(0, 0, bounds.width, bounds.height);

                this.drawPebbles();
                this.drawDynamicEntities();
                this.drawMushrooms();

                this.needsRedraw = false;
            }

            drawPebbles() {
                this.ctx.font = 'bold 0.7rem monospace';
                this.pebbles.forEach(p => {
                    this.ctx.fillStyle = p.color;
                    this.ctx.globalAlpha = p.type === 'spaceRock' ? 1.0 : 0.8;
                    this.ctx.fillText(p.char, p.x, p.y);
                });
            }

            drawMushrooms() {
                this.ctx.font = '1rem monospace';
                this.ctx.globalAlpha = 1.0;
                this.mushrooms.forEach(m => {
                    this.ctx.fillText('🍄', m.x, m.y);
                });
            }

            drawDynamicEntities() {
                this.ctx.globalAlpha = 1.0;
                this.dynamicEntities.forEach(e => {
                    let emoji = '';
                    let fontSize = '1rem';
                    let textShadow = 'none';

                    if (e.type === 'seed') {
                        emoji = Config.Emojis.SEED;
                        fontSize = '0.5rem'; // Tiny
                        // Use text shadow to make the emoji appear dark/black
                        textShadow = '0 0 2px black, 0 0 2px black, 0 0 2px black';
                    }
                    else if (e.type === 'brownMushroom') emoji = Config.Emojis.BROWN_MUSHROOM;
                    else if (e.type === 'flower') emoji = Config.Emojis.FLOWER;
                    else if (e.type === 'diamond') emoji = Config.Emojis.DIAMOND;

                    if (emoji) {
                        this.ctx.font = `${fontSize} monospace`;
                        this.ctx.shadowColor = textShadow === 'none' ? 'transparent' : 'black';
                        this.ctx.shadowBlur = textShadow === 'none' ? 0 : 2;
                        this.ctx.fillText(emoji, e.x, e.y);
                        this.ctx.shadowBlur = 0; // Reset shadow
                    }
                });
            }
        }

        // ====================================================================
        // 2. WORLD MANAGER (Environment, Paths, Grass)
        // ====================================================================

        // (WorldManager implementation remains largely unchanged)
        class WorldManager {
            constructor(width, height, pathCtx, entityManager, assetManager) {
                this.width = width;
                this.height = height;
                this.pathCtx = pathCtx;
                this.entityManager = entityManager;
                this.assetManager = assetManager;

                this.pathGrid = [];
                this.grassBlades = [];

                this.initializeGrid();
            }

            initializeGrid() {
                const gridWidth = Math.ceil(this.width / Config.GRID_CELL_SIZE);
                const gridHeight = Math.ceil(this.height / Config.GRID_CELL_SIZE);

                const newPathGrid = [];

                // Initialize fresh grid or handle resize (preserving existing data if resizing)
                for (let i = 0; i < gridWidth; i++) {
                    newPathGrid[i] = [];
                    for (let j = 0; j < gridHeight; j++) {
                        // Check if cell already exists (from previous size during a resize event)
                        if (this.pathGrid[i] && this.pathGrid[i][j]) {
                             newPathGrid[i][j] = this.pathGrid[i][j];
                        } else {
                            // Initialize new cell
                            newPathGrid[i][j] = { wear: 0, hasPebble: false, terrainType: TerrainType.NORMAL, mistOpacity: 0 };
                        }
                    }
                }
                this.pathGrid = newPathGrid;
            }

            handleResize(width, height) {
                this.width = width;
                this.height = height;
                this.initializeGrid();
                // Regenerate grass field on resize to fill the new area correctly.
                this.grassBlades = [];
                this.generateGrassField();
                this.redrawWorld();
            }

            redrawWorld() {
                // Redraw Paths (Only paths are drawn here now)
                this.pathCtx.clearRect(0, 0, this.width, this.height);
                for (let i = 0; i < this.pathGrid.length; i++) {
                    for (let j = 0; j < (this.pathGrid[i]?.length || 0); j++) {
                        const cell = this.pathGrid[i][j];
                        if (cell.wear > 0 || cell.terrainType !== TerrainType.NORMAL) {
                            this.drawPathCell(i, j);
                        }
                    }
                }
            }

            // --- Utility Functions ---
            isValidCell(gridX, gridY) {
                return gridX >= 0 && gridX < this.pathGrid.length && gridY >= 0 && this.pathGrid[0] && gridY < this.pathGrid[0].length;
            }

            getTerrainInfoAtPoint(x, y) {
                const gridX = Math.floor(x / Config.GRID_CELL_SIZE);
                const gridY = Math.floor(y / Config.GRID_CELL_SIZE);
                if (this.isValidCell(gridX, gridY)) {
                    const cell = this.pathGrid[gridX][gridY];
                    return { type: cell.terrainType, wear: cell.wear };
                }
                return { type: TerrainType.NORMAL, wear: 0 };
            }

            // --- GRASS MANAGEMENT ---

            // Generates grass in clumps.
            generateGrassField() {
                // If blades already exist, don't regenerate yet.
                if (this.grassBlades.length > 0) {
                    return;
                }

                this.grassBlades = [];
                const grassImageCount = this.assetManager.images.grass.length;

                if (grassImageCount === 0) {
                    console.warn("No grass assets loaded. Skipping grass generation.");
                    return;
                }

                // Iterate through the desired number of clumps
                for (let i = 0; i < Config.GRASS_CLUMP_COUNT; i++) {
                    // 1. Choose clump center point
                    const centerX = Math.random() * this.width;
                    const centerY = Math.random() * this.height;

                    // 2. Choose clump size
                    const clumpSize = Math.floor(Utils.randomRange(Config.GRASS_CLUMP_MIN_SIZE, Config.GRASS_CLUMP_MAX_SIZE + 1));

                    // 3. Generate blades within the clump radius
                    for (let j = 0; j < clumpSize; j++) {
                        const angle = Math.random() * Math.PI * 2;
                        const distance = Math.random() * Config.GRASS_CLUMP_RADIUS;
                        const xPx = centerX + Math.cos(angle) * distance;
                        const yPx = centerY + Math.sin(angle) * distance;

                        // Basic bounds check
                        if (xPx < 0 || xPx >= this.width || yPx < 0 || yPx >= this.height) continue;

                        const blade = {
                            x: xPx,
                            y: yPx,
                            imageIndex: Math.floor(Math.random() * grassImageCount),
                            // Scale reduced by half
                            scale: Utils.randomRange(0.4, 0.8),
                            // Initial health (opacity) set to 50%
                            health: 0.5,
                            offsetX: 0,
                            offsetY: 0,
                            angle: 0,
                            isAlien: false
                        };

                        this.grassBlades.push(blade);
                    }
                }
            }

            // Handles interaction (sliding, bending) for animation ONLY.
            interactWithGrass(impactX, impactY, radius) {
                const radiusSq = radius * radius;

                for (let i = this.grassBlades.length - 1; i >= 0; i--) {
                    const blade = this.grassBlades[i];
                    const distSq = (blade.x - impactX)**2 + (blade.y - impactY)**2;

                    if (distSq < radiusSq) {

                        // Apply Slide and Bend Animation
                        const distance = Math.sqrt(distSq);
                        if (distance > 0.1) {
                            // Calculate vector from impact point to the blade
                            const dx = blade.x - impactX;
                            const dy = blade.y - impactY;

                            // Normalize the vector
                            const nx = dx / distance;
                            const ny = dy / distance;

                            // Calculate intensity (stronger when closer)
                            const intensity = (1 - (distance / radius));

                            // Slide
                            const slideAmount = intensity * Config.GRASS_SLIDE_DISTANCE;
                            blade.offsetX = nx * slideAmount;
                            blade.offsetY = ny * slideAmount;

                            // Bend
                            blade.angle = nx * intensity * Config.GRASS_BEND_ANGLE;
                        }
                    }
                }
            }

            // Updates grass health based on the wear level of the dirt underneath.
            updateGrassHealthFromDirt() {
                for (let i = this.grassBlades.length - 1; i >= 0; i--) {
                    const blade = this.grassBlades[i];

                    // Find the grid cell the blade occupies
                    const gridX = Math.floor(blade.x / Config.GRID_CELL_SIZE);
                    const gridY = Math.floor(blade.y / Config.GRID_CELL_SIZE);

                    if (this.isValidCell(gridX, gridY)) {
                        const cell = this.pathGrid[gridX][gridY];
                        const wearRatio = cell.wear / Config.MAX_WEAR;

                        // Health = Base Opacity (0.5) * (1 - WearRatio)
                        blade.health = 0.5 * (1 - wearRatio);

                    } else {
                        blade.health = 0.5;
                    }

                    // Check for Death
                    if (blade.health <= Config.GRASS_DEATH_THRESHOLD) {
                        this.grassBlades.splice(i, 1);
                    }
                }
            }


            // Update loop for grass (handles animation decay AND health updates)
            updateGrass(deltaTime) {
                // 1. Update health based on underlying dirt wear
                this.updateGrassHealthFromDirt();

                // 2. Handle animation decay (springing back)
                const decayRate = 5;

                for (const blade of this.grassBlades) {
                    const needsUpdate = Math.abs(blade.offsetX) > 0.1 || Math.abs(blade.offsetY) > 0.1 || Math.abs(blade.angle) > 0.01;

                    if (needsUpdate) {
                        // Lerp offsets and angle back towards 0
                        blade.offsetX = Utils.lerp(blade.offsetX, 0, decayRate * deltaTime);
                        blade.offsetY = Utils.lerp(blade.offsetY, 0, decayRate * deltaTime);
                        blade.angle = Utils.lerp(blade.angle, 0, decayRate * deltaTime);
                    } else if (blade.offsetX !== 0 || blade.offsetY !== 0 || blade.angle !== 0) {
                        // Snap to 0 when very close
                        blade.offsetX = 0;
                        blade.offsetY = 0;
                        blade.angle = 0;
                    }
                }
            }

            // Draws a single blade of grass. Called by the main Game loop during sorted rendering.
            drawBlade(ctx, blade) {
                // Determine which asset set to use (Standard or Alien)
                const assetSet = blade.isAlien ? this.assetManager.images.alienGrass : this.assetManager.images.grass;

                // Ensure the index is valid for the selected set
                if (!assetSet || blade.imageIndex >= assetSet.length) return;

                const img = assetSet[blade.imageIndex];

                if (!img || !img.complete) return; // Ensure image is valid and loaded

                const width = img.width * blade.scale;
                const height = img.height * blade.scale;

                // Calculate the position of the base of the blade (pivot point)
                const baseX = blade.x + blade.offsetX;
                const baseY = blade.y + blade.offsetY;

                // Set opacity based on health
                ctx.globalAlpha = Math.max(0, blade.health);

                // Apply rotation around the base of the blade
                if (blade.angle !== 0) {
                    ctx.save();
                    ctx.translate(baseX, baseY);
                    ctx.rotate(blade.angle);
                    // Draw the image relative to the translated/rotated origin
                    ctx.drawImage(img, -width / 2, -height, width, height);
                    ctx.restore();
                } else {
                    // Optimized drawing for non-rotated blades
                    const drawX = baseX - width / 2;
                    const drawY = baseY - height;
                    ctx.drawImage(img, drawX, drawY, width, height);
                }

                // Reset alpha for subsequent draws
                ctx.globalAlpha = 1.0;
            }


            // --- WEAR AND TEAR (Dirt Paths) ---
            applyMovementWear(startX, startY, endX, endY, buffManager) {
                const distance = Utils.distance(startX, startY, endX, endY);
                const steps = Math.ceil(distance / 5);
                if (steps === 0) return;

                const wanderDot = Game.instance.wanderDot; // Get reference to the dot

                // Use the dot's calculated strength multiplier
                let dirtWearMultiplier = Config.WEAR_PER_PIXEL * wanderDot.currentStrengthMultiplier;


                // Determine wear radius (this logic remains here as it's about the area of effect)
                const buffs = buffManager.getActiveBuffs();
                let dirtWearRadius = 1;
                if (buffs.pizza || buffs.mushroom) {
                    dirtWearRadius = 2;
                }
                if (buffs.pizza && buffs.mushroom) {
                    dirtWearRadius = 3;
                }

                const isHeavy = buffs.pizza || buffs.mushroom;
                const currentDotRadius = wanderDot.radius;

                // Define interaction radius for the animation effect
                const interactionRadius = 35;

                for (let i = 0; i <= steps; i++) {
                    const t = i / steps;
                    const currentX = Utils.lerp(startX, endX, t);
                    const currentY = Utils.lerp(startY, endY, t);

                    // 1. Apply Wear to Dirt Path
                    this.applyWearToArea(currentX, currentY, dirtWearRadius, (distance/steps) * dirtWearMultiplier);

                    // 2. Interact with Grass (Animation only)
                    this.interactWithGrass(currentX, currentY, interactionRadius);

                    // 3. Entity Destruction while rolling
                    if (isHeavy) {
                        this.entityManager.removeDynamicEntitiesInArea(currentX, currentY, currentDotRadius);
                    }
                }
            }

            applyLandingImpact(x, y, moodState, buffManager) {
                const wanderDot = Game.instance.wanderDot;

                // Base impact wear multiplied by the dot's current strength (which includes mood/buffs)
                let impactWear = Config.BASE_IMPACT_WEAR * wanderDot.currentStrengthMultiplier;


                const buffs = buffManager.getActiveBuffs();
                const isHeavy = buffs.pizza || buffs.mushroom;


                if (moodState === 'mad') {
                    // Strength already includes the mad multiplier, so we just spawn particles.
                    Game.instance.particleManager.spawnLandingParticles(x, y);
                }

                const impactRadius = 2.5;

                // 1. Apply Wear to Dirt Path
                this.applyWearToArea(x, y, impactRadius, impactWear, true);

                // 2. Interact with Grass (Animation only)
                const landingInteractionRadius = 60;
                this.interactWithGrass(x, y, landingInteractionRadius);

                // 3. Entity Destruction on impact
                this.entityManager.removeMushroomInArea(x, y, Config.BASE_RADIUS * 2);

                if (isHeavy) {
                    const currentDotRadius = wanderDot.radius;
                    this.entityManager.removeDynamicEntitiesInArea(x, y, currentDotRadius);
                }
            }

            // (applyWearToArea remains unchanged)
            applyWearToArea(x, y, radius, wearAmount, useFalloff = false) {
                const centerX = Math.floor(x / Config.GRID_CELL_SIZE);
                const centerY = Math.floor(y / Config.GRID_CELL_SIZE);
                const radiusSq = radius * radius;

                for (let i = -Math.ceil(radius); i <= Math.ceil(radius); i++) {
                    for (let j = -Math.ceil(radius); j <= Math.ceil(radius); j++) {
                        const distSq = i * i + j * j;

                        if (!useFalloff && distSq > radiusSq) continue;

                        const distance = Math.sqrt(distSq);
                        if (useFalloff && distance > radius) continue;

                        const gridX = centerX + i;
                        const gridY = centerY + j;

                        if (this.isValidCell(gridX, gridY)) {
                            const cell = this.pathGrid[gridX][gridY];
                            const oldWear = cell.wear;

                            let effectiveWear = wearAmount;
                            if (useFalloff) {
                                const falloff = 1 - (distance / radius);
                                effectiveWear *= falloff;
                            }

                            cell.wear = Math.min(Config.MAX_WEAR, cell.wear + effectiveWear);

                            if (Math.floor(cell.wear) > Math.floor(oldWear)) {
                                this.drawPathCell(gridX, gridY);
                                this.trySpawnEntity(gridX, gridY, cell);
                            }
                        }
                    }
                }
            }

            // --- RENDERING & SPAWNING (Unchanged) ---
            // (drawPathCell, trySpawnEntity, spawnPebble, spawnMushroom remain unchanged)
            drawPathCell(gridX, gridY) {
                const cell = this.pathGrid[gridX][gridY];
                const wearRatio = cell.wear / Config.MAX_WEAR;
                let baseColor, targetColor;
                let baseOpacity = 0;

                switch (cell.terrainType) {
                    case TerrainType.ALIEN_BLUE:
                        baseColor = Config.COLOR_ALIEN_BLUE;
                        targetColor = Config.COLOR_DIRT;
                        baseOpacity = cell.mistOpacity ?? 0;
                        break;
                    case TerrainType.ALIEN_CLAY:
                        baseColor = Config.COLOR_DIRT;
                        targetColor = Config.COLOR_ALIEN_CLAY;
                        baseOpacity = 0.2;
                        break;
                    case TerrainType.NORMAL:
                    default:
                        baseColor = Config.COLOR_FIELD;
                        targetColor = Config.COLOR_DIRT;
                        break;
                }

                const pathColor = Utils.lerpColor(baseColor, targetColor, wearRatio);
                const pathOpacity = Math.max(wearRatio * 0.8, baseOpacity);

                this.pathCtx.fillStyle = pathColor;
                this.pathCtx.globalAlpha = pathOpacity;
                this.pathCtx.clearRect(gridX * Config.GRID_CELL_SIZE, gridY * Config.GRID_CELL_SIZE, Config.GRID_CELL_SIZE, Config.GRID_CELL_SIZE);
                this.pathCtx.fillRect(gridX * Config.GRID_CELL_SIZE, gridY * Config.GRID_CELL_SIZE, Config.GRID_CELL_SIZE, Config.GRID_CELL_SIZE);
                this.pathCtx.globalAlpha = 1.0;
            }

            trySpawnEntity(gridX, gridY, cell) {
                if (cell.hasPebble) return;

                if (cell.terrainType === TerrainType.ALIEN_CLAY && Math.random() < 0.005) {
                    const x = gridX * Config.GRID_CELL_SIZE + Utils.randomRange(2, Config.GRID_CELL_SIZE - 2);
                    const y = gridY * Config.GRID_CELL_SIZE + Utils.randomRange(2, Config.GRID_CELL_SIZE - 2);
                    this.entityManager.addEntity('diamond', x, y);
                }

                if (cell.wear > Config.PEBBLE_SPAWN_THRESHOLD) {
                    let spawnChance = 0.01;
                    let pebbleType = 'normal';

                    if (cell.terrainType === TerrainType.ALIEN_BLUE) {
                        spawnChance = 0.03;
                        pebbleType = 'spaceRock';
                    } else if (cell.terrainType === TerrainType.ALIEN_CLAY) {
                        spawnChance = 0.008;
                    }

                    if (Math.random() < spawnChance) {
                        this.spawnPebble(gridX, gridY, pebbleType);
                        cell.hasPebble = true;
                    }
                }
            }

            spawnPebble(gridX, gridY, type) {
                let colors, chars;

                if (type === 'spaceRock') {
                    colors = ['#4B0082', '#6A0DAD', '#551A8B'];
                    chars = ['*', 'o', 'O', '.:', '.:.'];
                } else {
                    colors = ['#000000', '#1C1C1C', '#2A1A10', '#3D2B1F'];
                    chars = ['..', '.-.', ".;'", '-_,`', ':'];
                }

                const pebble = {
                    x: gridX * Config.GRID_CELL_SIZE + Math.random() * Config.GRID_CELL_SIZE,
                    y: gridY * Config.GRID_CELL_SIZE + Math.random() * Config.GRID_CELL_SIZE,
                    char: Utils.randomChoice(chars),
                    color: Utils.randomChoice(colors),
                    type: type
                };
                this.entityManager.addPebble(pebble);
            }

            spawnMushroom(gridX, gridY) {
                const mushroom = {
                    x: gridX * Config.GRID_CELL_SIZE + (Config.GRID_CELL_SIZE / 2),
                    y: gridY * Config.GRID_CELL_SIZE + (Config.GRID_CELL_SIZE / 2),
                    gridX, gridY
                };
                return this.entityManager.addMushroom(mushroom);
            }

            // --- UFO/ALIEN TERRAFORMING ---
            alterGround(x, y) {
                const centerX = Math.floor(x / Config.GRID_CELL_SIZE);
                const centerY = Math.floor(y / Config.GRID_CELL_SIZE);
                const alterRadius = 3;
                const alterationPixelRadius = alterRadius * Config.GRID_CELL_SIZE;

                // 1. Update the underlying Path Grid
                for(let i = -alterRadius; i <= alterRadius; i++) {
                    for (let j = -alterRadius; j <= alterRadius; j++) {
                        const distSq = i*i + j*j;
                        if (distSq > alterRadius * alterRadius) continue;

                        const gridX = centerX + i;
                        const gridY = centerY + j;

                        if (this.isValidCell(gridX, gridY)) {
                            const cell = this.pathGrid[gridX][gridY];

                            const isGrass = cell.wear < Config.GRASS_REMOVAL_THRESHOLD;
                            const targetType = isGrass ? TerrainType.ALIEN_BLUE : TerrainType.ALIEN_CLAY;


                            if (targetType === TerrainType.ALIEN_BLUE) {
                                const distance = Math.sqrt(distSq);
                                const falloff = 1 - (distance / alterRadius);
                                const newOpacity = Utils.clamp(falloff * Utils.randomRange(0.2, 0.5), 0.1, 0.5);
                                cell.mistOpacity = Math.max(cell.mistOpacity, newOpacity);
                            }

                            if (cell.terrainType !== targetType) {
                                cell.terrainType = targetType;
                            }

                            this.drawPathCell(gridX, gridY);

                            // Spawn Mushrooms
                            if(targetType === TerrainType.ALIEN_BLUE && Math.random() < Config.UFO_MUSHROOM_CHANCE) {
                                this.spawnMushroom(gridX, gridY);
                            }
                        }
                    }
                }

                // 2. Update Grass Blades based on new terrain
                const radiusSq = alterationPixelRadius * alterationPixelRadius;
                for (let i = this.grassBlades.length - 1; i >= 0; i--) {
                    const blade = this.grassBlades[i];
                    const distSq = (blade.x - x)**2 + (blade.y - y)**2;

                    if (distSq < radiusSq) {
                        // Check the new terrain type at the blade's specific location
                        const terrainInfo = this.getTerrainInfoAtPoint(blade.x, blade.y);

                        if (terrainInfo.type === TerrainType.ALIEN_BLUE) {
                            // Transform to alien grass
                            blade.isAlien = true;
                        } else if (terrainInfo.type === TerrainType.ALIEN_CLAY) {
                            // Remove grass on clay
                            this.grassBlades.splice(i, 1);
                        }
                    }
                }
            }
        }

        // ====================================================================
        // 3. WANDERDOT (The Circle, Mood, and Behavior)
        // ====================================================================

        // UPDATED: Incorporates Kangaroo mood color.
        class WanderDot {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.previousX = x;
                this.previousY = y;

                this.radius = Config.BASE_RADIUS;
                this.color = Utils.lerpColor(Config.COLOR_NORMAL, Config.COLOR_NORMAL, 0);

                this.speed = Config.BASE_SPEED;
                this.currentSpeedMultiplier = 1.0;

                // Stats
                this.baseStrength = 1.0; // Base wear multiplier
                this.currentStrengthMultiplier = 1.0;

                this.dx = (Math.random() - 0.5) * 2;
                this.dy = (Math.random() - 0.5) * 2;
                this.targetX = null;
                this.targetY = null;

                // Mood state
                this.annoyance = 0;
                this.currentMoodState = 'normal';
                this.isCalm = false;
                this.isHangry = false;
                this.isInterruptedHangry = false;

                // Hunger state
                this.hunger = Config.MAX_HUNGER;

                // Behavior state
                this.isEating = false;
                this.eatingStartTime = 0;
                this.eatingTarget = null;

                // Bounce state
                this.distanceTraveledOnCurrentBounce = 0;
                this.jiggleEndTime = 0;
                this.verticalOffset = 0;
            }

            // Returns the Y coordinate of the bottom of the dot for sorting purposes.
            getBaseY() {
                return this.y + this.radius;
            }

            // Method to apply immediate mood boost
            applyMoodBoost(amount) {
                // Amount is positive, representing a decrease in annoyance
                this.annoyance = Math.max(0, this.annoyance - amount);
            }


            setTarget(x, y) {
                if (this.isHangry) {
                    return false;
                }

                // If the dot is currently chewing (eatingStartTime > 0), interrupting it triggers Hangry
                if (this.isEating && this.eatingStartTime > 0) {
                    // Specify interruption cause
                    this.triggerHangry(true);
                    return false;
                }

                this.targetX = x;
                this.targetY = y;
                return true;
            }

            triggerHangry(causedByInterruption = false) {
                this.isHangry = true;

                // Set specific Hangry type based on cause
                if (causedByInterruption) {
                    this.isInterruptedHangry = true;
                }

                 // If triggered by low hunger, annoyance might not be high yet.
                if (this.hunger < Config.HANGRY_HUNGER_THRESHOLD && !causedByInterruption) {
                    // Ensure annoyance is high enough to look significantly annoyed/mad.
                    this.annoyance = Math.max(this.annoyance, Config.ANNOYANCE_THRESHOLD + 5);
                } else {
                    // If triggered by interruption (or already very mad), ensure annoyance is very high (MAD)
                    this.annoyance = Math.max(this.annoyance, Config.MAD_THRESHOLD + 1);
                }

                // Reset eating state
                this.isEating = false;
                this.eatingTarget = null;
                this.eatingStartTime = 0;
                this.clearTarget();
                // Show angry thought bubble immediately
                Game.instance.uiManager.showThought(Utils.randomChoice(Config.Emojis.mad));
            }


            clearTarget() {
                this.targetX = null;
                this.targetY = null;
                this.distanceTraveledOnCurrentBounce = 0;
            }

            update(deltaTime, bounds, buffManager, worldManager, entityManager) {
                this.updateMood(deltaTime, buffManager, entityManager); // Pass entityManager
                this.updatePosition(deltaTime, bounds, buffManager, worldManager, entityManager);
            }

            // --- MOOD & HUNGER LOGIC ---
            getMoodState(annoyanceValue) {
                if (annoyanceValue > Config.MAD_THRESHOLD) return 'mad';
                if (annoyanceValue > Config.ANNOYANCE_THRESHOLD) return 'annoyed';
                return 'normal';
            }

            addAnnoyance(amount, isDirectClick) {
                let annoyanceToAdd = amount;

                if (this.isCalm) {
                    annoyanceToAdd = 1.2;
                    this.isCalm = false;
                }

                if (isDirectClick) {
                    annoyanceToAdd *= 1.1;
                }

                this.annoyance = Math.min(100, this.annoyance + annoyanceToAdd);
                return this.getReactionEmoji(isDirectClick);
            }

            getReactionEmoji(isDirectClick) {
                 if (isDirectClick) {
                    const levels = [20, 30, 45, 60, 75, 90];
                    let level = Config.Emojis.directClick.length - 1;
                    for (let i = 0; i < levels.length; i++) {
                        if (this.annoyance < levels[i]) {
                            level = i;
                            break;
                        }
                    }
                    return Config.Emojis.directClick[level];
                } else {
                    if (this.annoyance > Config.MAD_THRESHOLD) {
                        return Utils.randomChoice(Config.Emojis.mad);
                    } else if (this.annoyance > Config.ANNOYANCE_THRESHOLD) {
                        return Utils.randomChoice(Config.Emojis.annoyed);
                    } else {
                        return Utils.randomChoice(Config.Emojis.commandReceived);
                    }
                }
            }

            updateHunger(deltaTime) {
                if (this.hunger > 0) {
                    let decayRate = Config.HUNGER_DECAY_PER_SECOND;

                    // Increase decay rate if mood is bad
                    if (this.currentMoodState === 'mad' || this.currentMoodState === 'annoyed') {
                        decayRate *= Config.MOOD_HUNGER_DRAIN_MULTIPLIER;
                    }

                    this.hunger = Math.max(0, this.hunger - decayRate * deltaTime);
                }

                // Check if hunger triggers Hangry state
                if (this.hunger < Config.HANGRY_HUNGER_THRESHOLD && !this.isHangry) {
                    // Triggered by hunger, not interruption
                    this.triggerHangry(false);
                }
            }

            // UPDATED: Includes natural decay and flower restoration.
            updateMood(deltaTime, buffManager, entityManager) {
                // 1. Hunger decay
                this.updateHunger(deltaTime);

                // 2. Natural Mood Decay (Annoyance Increase) (NEW)
                // Mood decays unless the dot is currently eating (chewing phase)
                if (!(this.isEating && this.eatingStartTime > 0)) {
                     this.annoyance = Math.min(100, this.annoyance + Config.MOOD_DECAY_PER_SECOND * deltaTime);
                }

                // 3. Mood Restoration (Annoyance Decrease)
                let restorationRate = 0;

                // 3a. Check for nearby flowers (NEW)
                const nearbyFlowers = entityManager.getNearbyDynamicEntities('flower', this.x, this.y, Config.MOOD_BOOST_FLOWER_RADIUS);
                if (nearbyFlowers.length > 0) {
                    // Apply boost based on the rate
                    restorationRate += Config.MOOD_BOOST_FLOWER_RATE;
                }

                // Apply the calculated restoration rate
                if (restorationRate > 0) {
                    // Apply hunger penalty to restoration rate
                    if (this.hunger < Config.HANGRY_HUNGER_THRESHOLD) {
                         restorationRate *= Config.HUNGER_MOOD_DRAIN_MULTIPLIER;
                    }
                    this.annoyance = Math.max(0, this.annoyance - restorationRate * deltaTime);
                }


                // 4. State Change Detection
                const previousState = this.currentMoodState;
                this.currentMoodState = this.getMoodState(this.annoyance);

                let transitionEmoji = null;
                if (this.currentMoodState !== previousState) {
                    if (previousState === 'mad' && this.currentMoodState === 'annoyed') {
                        transitionEmoji = Config.Emojis.cooldownToAnnoyed[0];

                        // Exit Hangry state ONLY IF hunger is sufficient AND annoyance cooled down
                        if (this.isHangry && this.hunger >= Config.HANGRY_HUNGER_THRESHOLD) {
                            this.isHangry = false;
                            this.isInterruptedHangry = false; // Clear interruption flag
                        }

                    } else if (previousState === 'annoyed' && this.currentMoodState === 'normal') {
                         this.isCalm = true;
                         transitionEmoji = Config.Emojis.cooldownToNormal[0];

                         // Exit Hangry state if returning to normal (should be covered above but safe check)
                         if (this.isHangry && this.hunger >= Config.HANGRY_HUNGER_THRESHOLD) {
                            this.isHangry = false;
                            this.isInterruptedHangry = false; // Clear interruption flag
                        }
                    }
                }

                // 5. Ensure Hangry state persists if hunger is low, even if annoyance cools slightly
                if (this.hunger < Config.HANGRY_HUNGER_THRESHOLD && !this.isHangry) {
                    this.triggerHangry(false); // Caused by hunger
                }


                // 6. Appearance and Speed Update
                this.updateAppearance(buffManager);

                return transitionEmoji;
            }

            // UPDATED: Added Kangaroo color override
            updateAppearance(buffManager) {
                const buffs = buffManager.getActiveBuffs();

                let speed = Config.BASE_SPEED;
                let radius = Config.BASE_RADIUS;
                let strength = this.baseStrength; // Start with base strength

                // --- Apply Buffs ---
                if (buffs.coffee) {
                    speed *= (1 + 0.3 * buffs.coffee.potency);
                    strength *= (1 + 1.0 * buffs.coffee.potency); // Coffee increases strength (wear)
                }

                if (buffs.pizza) {
                    radius *= (1 + 0.3 * buffs.pizza.potency);
                }
                if (buffs.mushroom) {
                    radius *= (1 + 0.3 * buffs.mushroom.potency);
                    strength *= (1 + 1.0 * buffs.mushroom.potency); // Mushroom increases strength (wear)
                }

                 if (buffs.kangaroo) {
                    // Reflect the potential impact strength in the UI
                    strength *= (1 + 0.3 * buffs.kangaroo.potency);
                }

                // --- Apply Mood/Color/Speed Multiplier ---
                 if (this.annoyance > Config.MAD_THRESHOLD) {
                    this.color = Utils.lerpColor(Config.COLOR_MAD, Config.COLOR_MAD, 0);
                    this.currentSpeedMultiplier = 0.3;
                    strength *= 1.7; // Mad increases strength significantly
                } else if (this.annoyance > Config.ANNOYANCE_THRESHOLD) {
                    const t = (this.annoyance - Config.ANNOYANCE_THRESHOLD) / (Config.MAD_THRESHOLD - Config.ANNOYANCE_THRESHOLD);
                    this.color = Utils.lerpColor(Config.COLOR_ANNOYED, Config.COLOR_MAD, t);
                    this.currentSpeedMultiplier = Utils.lerp(0.5, 0.3, t);
                    strength *= Utils.lerp(1.1, 1.7, t); // Annoyed slightly increases strength
                } else {
                    // Normal State
                    const t = this.annoyance / Config.ANNOYANCE_THRESHOLD;
                    // this.color = Utils.lerpColor(Config.COLOR_NORMAL, Config.COLOR_ANNOYED, t); // Old implementation
                    this.currentSpeedMultiplier = Utils.lerp(1.0, 0.5, t);

                    // NEW: Kangaroo Happy Mood Override
                    if (buffs.kangaroo) {
                        // Use the HAPPY color as the base when kangaroo is active, still interpolating towards annoyed if annoyance rises.
                        this.color = Utils.lerpColor(Config.COLOR_HAPPY, Config.COLOR_ANNOYED, t);
                    } else {
                        this.color = Utils.lerpColor(Config.COLOR_NORMAL, Config.COLOR_ANNOYED, t);
                    }
                }

                 // Assign final stats
                this.speed = speed;
                this.radius = radius;
                this.currentStrengthMultiplier = strength;
            }

            // --- MOVEMENT & BEHAVIOR LOGIC ---
            // (updatePosition, handleEatingBehavior, moveToTarget, wander, handleBounce, land, handleBoundaries remain unchanged)
            updatePosition(deltaTime, bounds, buffManager, worldManager, entityManager) {
                this.previousX = this.x;
                this.previousY = this.y;

                // 1. Determine behavior and direction
                let movementAllowed = true;

                // Check if eating target still exists
                if (this.isEating && this.eatingStartTime === 0 && this.eatingTarget && !entityManager.mushrooms.includes(this.eatingTarget)) {
                    this.eatingTarget = null;
                    this.isEating = false;
                    this.clearTarget();
                    // Hide the seeking thought if it was active
                    if (Game.instance.uiManager.getCurrentThought() === Config.Emojis.EATING_SEEKING) {
                        Game.instance.uiManager.hideThought();
                    }
                }

                if (this.isEating) {
                    movementAllowed = this.handleEatingBehavior(entityManager, buffManager);
                }

                if (movementAllowed) {
                    if (this.targetX !== null) {
                        this.moveToTarget();
                    } else {
                        this.wander(entityManager, buffManager);
                    }
                } else {
                    // Force stop when chewing
                    this.dx = 0;
                    this.dy = 0;
                }


                // 2. Calculate movement distance
                const buffs = buffManager.getActiveBuffs();
                let effectiveSpeed = this.speed * this.currentSpeedMultiplier;

                if (buffs.kangaroo) {
                    effectiveSpeed = Config.BASE_SPEED * (buffs.kangaroo.isEureka ? 1.3 : 1.0);
                }

                const distanceMoved = effectiveSpeed * deltaTime;

                // 3. Apply movement
                this.x += this.dx * distanceMoved;
                this.y += this.dy * distanceMoved;

                // 4. Handle World Interaction
                if (buffs.kangaroo) {
                    this.handleBounce(distanceMoved, buffManager, worldManager);
                } else {
                    this.verticalOffset = 0;
                    if (movementAllowed) {
                         // This uses the centralized strength stat now
                         worldManager.applyMovementWear(this.previousX, this.previousY, this.x, this.y, buffManager);
                    }
                }

                // 5. Boundary Collision
                if (movementAllowed) {
                    this.handleBoundaries(bounds);
                }
            }

            handleEatingBehavior(entityManager, buffManager) {
                const uiManager = Game.instance.uiManager;

                // Stage 1: Moving towards the mushroom (Seeking)
                if (this.targetX !== null) {
                    if (uiManager.getCurrentThought() !== Config.Emojis.EATING_SEEKING) {
                        uiManager.showThought(Config.Emojis.EATING_SEEKING, 60000);
                    }
                    return true; // Allow movement
                }

                // Stage 2: Reached the mushroom, start chewing animation
                if (this.eatingStartTime === 0) {
                    this.eatingStartTime = Date.now();
                    // Consume the mushroom from the world
                    if (this.eatingTarget) {
                        entityManager.removeMushroomByObject(this.eatingTarget);
                        this.eatingTarget = null; // Target is now consumed/held
                    }
                    uiManager.showThought(Config.Emojis.EATING_CONSUMING, Config.EAT_DURATION + 500);
                }

                const elapsed = Date.now() - this.eatingStartTime;
                const remaining = Config.EAT_DURATION - elapsed;

                // Stage 3: Check if chewing is done
                if (remaining <= 0) {
                    this.isEating = false;
                    this.eatingStartTime = 0;

                    // Restore Hunger
                    this.hunger = Math.min(Config.MAX_HUNGER, this.hunger + Config.MUSHROOM_HUNGER_RESTORE);

                    // Apply the buff
                    buffManager.addBuffTime('mushroom', Config.MUSHROOM_BUFF_DURATION);

                    // Show satisfied thought bubble
                    uiManager.showThought(Config.Emojis.EATING_SATISFIED, 2000);

                    return true; // Allow movement again
                }

                // Update thought bubble with timer during chewing
                const remainingSeconds = Math.ceil(remaining / 1000);
                uiManager.updateThoughtContent(`${Config.Emojis.EATING_CONSUMING} ${remainingSeconds}s`, true);

                return false; // Prevent movement while chewing
            }

            moveToTarget() {
                const targetX = this.targetX;
                const targetY = this.targetY;

                const vecX = targetX - this.x;
                const vecY = targetY - this.y;
                const distanceToTarget = Math.sqrt(vecX * vecX + vecY * vecY);

                // Stop slightly before the target if eating, otherwise stop at the usual radius
                const stopDistance = this.isEating ? 5 : this.radius;

                if (distanceToTarget < stopDistance) {
                    this.clearTarget();
                    // If not starting the eating process, randomize direction
                    if (!this.isEating || this.eatingStartTime > 0) {
                        this.dx = (Math.random() - 0.5) * 2;
                        this.dy = (Math.random() - 0.5) * 2;
                    }
                } else {
                    this.dx = vecX / distanceToTarget;
                    this.dy = vecY / distanceToTarget;
                }
            }

            wander(entityManager, buffManager) {
                if (this.isEating || this.isHangry) {
                    return;
                }

                // Don't seek new mushrooms if the mushroom buff is already active
                if (!buffManager.getActiveBuffs().mushroom) {
                    const nearbyMushroom = entityManager.getNearbyMushroom(this.x, this.y, Config.EAT_DETECTION_RADIUS);
                    if (nearbyMushroom && Math.random() < Config.EAT_MUSHROOM_CHANCE) {
                        this.isEating = true;
                        this.eatingTarget = nearbyMushroom;
                        this.targetX = nearbyMushroom.x;
                        this.targetY = nearbyMushroom.y;
                        return;
                    }
                }

                // Standard wander behavior
                if (Math.random() < 0.015) {
                    this.dx = (Math.random() - 0.5) * 2;
                    this.dy = (Math.random() - 0.5) * 2;
                }
            }

            handleBounce(distanceMoved, buffManager, worldManager) {
                this.distanceTraveledOnCurrentBounce += distanceMoved;

                let currentBounceHeight = Config.BOUNCE_HEIGHT;
                if (this.currentMoodState === 'mad') {
                    currentBounceHeight /= 2;
                }
                const bounceProgress = Math.min(Math.PI, (this.distanceTraveledOnCurrentBounce / Config.BOUNCE_DISTANCE) * Math.PI);
                this.verticalOffset = Math.sin(bounceProgress) * currentBounceHeight;

                if (this.distanceTraveledOnCurrentBounce >= Config.BOUNCE_DISTANCE) {
                    this.land(buffManager, worldManager);
                }
            }

            land(buffManager, worldManager) {
                // This uses the centralized strength stat now
                worldManager.applyLandingImpact(this.x, this.y, this.currentMoodState, buffManager);

                this.jiggleEndTime = Date.now();
                this.verticalOffset = 0;
                this.distanceTraveledOnCurrentBounce = 0;

                if (buffManager.isKangarooEnding()) {
                    buffManager.deactivateBuff('kangaroo', true);
                }
            }

            handleBoundaries(bounds) {
                let hitBoundary = false;
                if (this.x + this.radius > bounds.width || this.x - this.radius < 0) {
                    this.dx *= -1;
                    this.x = Utils.clamp(this.x, this.radius, bounds.width - this.radius);
                    hitBoundary = true;
                }
                if (this.y + this.radius > bounds.height || this.y - this.radius < 0) {
                    this.dy *= -1;
                    this.y = Utils.clamp(this.y, this.radius, bounds.height - this.radius);
                    hitBoundary = true;
                }

                if (hitBoundary && this.targetX !== null) {
                    this.clearTarget();
                     // If boundary collision interrupted eating seeking, cancel it without penalty
                    if (this.isEating && this.eatingStartTime === 0) {
                        this.isEating = false;
                        this.eatingTarget = null;
                        const uiManager = Game.instance.uiManager;
                        if (uiManager.getCurrentThought() === Config.Emojis.EATING_SEEKING) {
                            uiManager.hideThought();
                        }
                    }
                }
            }

            // --- RENDERING ---
            draw(ctx) {
                let scaleFactor = 1;
                const buffs = Game.instance.buffManager.getActiveBuffs();

                if (buffs.kangaroo) {
                    const bounceProgress = Math.min(Math.PI, (this.distanceTraveledOnCurrentBounce / Config.BOUNCE_DISTANCE) * Math.PI);
                    scaleFactor = 1 - Math.sin(bounceProgress) * 0.2;
                }

                const currentRadius = this.radius * scaleFactor;

                // Draw Shadow
                // Show shadow if moving or bouncing, hide only if stationary chewing
                if (!(this.isEating && this.eatingStartTime > 0)) {
                    ctx.beginPath();
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.35)';
                    // Shadow Y is based on ground position (this.y)
                    const shadowY = this.y + this.radius;
                    const shadowScale = 1 - (this.verticalOffset / (Config.BOUNCE_HEIGHT * 3));
                    const shadowRadiusX = currentRadius * shadowScale;
                    const shadowRadiusY = (currentRadius / 3) * shadowScale;
                    ctx.ellipse(this.x, shadowY, shadowRadiusX, shadowRadiusY, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.closePath();
                }

                // Draw Circle
                ctx.save();

                let drawY = this.y - this.verticalOffset;

                ctx.translate(this.x, drawY);

                // Landing Jiggle Effect
                const jiggleDuration = 300;
                const timeSinceJiggle = Date.now() - this.jiggleEndTime;
                if (timeSinceJiggle < jiggleDuration) {
                    const jiggleProgress = timeSinceJiggle / jiggleDuration;
                    let jiggleAmountMultiplier = (this.currentMoodState === 'mad') ? 0.4 : 0.2;
                    const jiggleAmount = Math.sin(jiggleProgress * Math.PI * 2) * (1 - jiggleProgress) * jiggleAmountMultiplier;
                    ctx.scale(1 + jiggleAmount, 1 - jiggleAmount);
                }

                // Draw Hangry Glow (Only if interrupted)
                if (this.isInterruptedHangry) {
                    ctx.shadowBlur = 25;
                    ctx.shadowColor = Config.COLOR_HANGRY_GLOW;
                }

                ctx.beginPath();
                ctx.arc(0, 0, currentRadius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.closePath();

                // Draw held item (Mushroom) during chewing phase
                if (this.isEating && this.eatingStartTime > 0) {
                    const elapsed = Date.now() - this.eatingStartTime;
                    // Calculate wiggle for the mushroom (up and down motion)
                    const mushroomWiggleY = Math.sin(elapsed / 100) * 5;

                    ctx.shadowBlur = 0; // Don't glow the mushroom itself
                    ctx.font = `${this.radius * 0.8}px monospace`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';

                    // Draw offset to the side
                    const mushroomX = this.radius * 0.7;
                    const mushroomY = this.radius * 0.2 + mushroomWiggleY;

                    ctx.fillText('🍄', mushroomX, mushroomY);
                }

                ctx.restore();
            }
        }

        // ====================================================================
        // 4. BUFF AND ITEM MANAGERS
        // ====================================================================

        // UPDATED: Handles pausing/resuming buff timers.
        class BuffManager {
            constructor(entityManager) {
                this.entityManager = entityManager;
                this.buffs = {};
                this.initializeDefinitions();
            }

            initializeDefinitions() {
                Object.entries(Config.Items).forEach(([name, data]) => {
                    if (data.type === 'buff') {
                        this.buffs[name] = {
                            endTime: 0,
                            blinkTimer: null,
                            duration: data.duration || 0,
                            isEureka: false,
                            isEnding: false,
                            emoji: data.emoji,
                            indicator: null,
                            hideTimer: data.hideTimer || false,
                            hungerRestore: data.hungerRestore || 0,
                            remainingTimeOnPause: 0 // NEW: Store remaining time when paused
                        };
                    }
                });
            }

            // NEW: Pause all active buffs
            pauseAllBuffs() {
                const currentTime = Date.now();
                Object.values(this.buffs).forEach(buff => {
                    if (buff.endTime > currentTime) {
                        // Calculate remaining time and store it
                        buff.remainingTimeOnPause = buff.endTime - currentTime;
                        // Set endTime to 0 to signify it's paused/inactive in the update loop
                        buff.endTime = 0;
                    } else {
                         buff.remainingTimeOnPause = 0;
                    }
                    // Clear any running timeouts (like the blink timer)
                    clearTimeout(buff.blinkTimer);
                });
            }

            // NEW: Resume all paused buffs
            resumeAllBuffs() {
                const currentTime = Date.now();
                Object.values(this.buffs).forEach(buff => {
                    if (buff.remainingTimeOnPause > 0) {
                        // Restore endTime based on the current time + stored remaining time
                        buff.endTime = currentTime + buff.remainingTimeOnPause;
                        buff.remainingTimeOnPause = 0;
                        // Re-setup the blink timer for the new duration
                        this.setupBlinkTimer(buff);
                    }
                });
            }

            initializeUI() {
                const container = document.getElementById('buff-container');
                const sortedKeys = Object.keys(this.buffs).sort((a, b) => a.localeCompare(b));

                sortedKeys.forEach(name => {
                    const buff = this.buffs[name];
                    const indicator = document.createElement('div');
                    indicator.className = 'buff-indicator';
                    indicator.id = `buff-indicator-${name}`;

                    const timerHTML = buff.hideTimer ? '' : '<div class="buff-timer"></div>';

                    indicator.innerHTML = `
                        <span class="buff-icon">${buff.emoji}</span>
                        ${timerHTML}
                    `;
                    container.appendChild(indicator);
                    buff.indicator = indicator;
                });
            }

            update() {
                const currentTime = Date.now();
                Object.entries(this.buffs).forEach(([name, buff]) => {
                    // Check if endTime > currentTime (only true if active and not paused)
                    if (buff.endTime > currentTime) {
                        this.updateTimerDisplay(buff, currentTime);
                    // Deactivate only if it expired naturally (remainingTimeOnPause is 0)
                    } else if (buff.indicator && buff.indicator.style.display === 'flex' && !buff.isEnding && buff.remainingTimeOnPause === 0) {
                        this.deactivateBuff(name);
                    }
                });
            }

            updateTimerDisplay(buff, currentTime) {
                if (buff.hideTimer || !buff.indicator) return;

                const remainingSeconds = Math.ceil((buff.endTime - currentTime) / 1000);
                const minutes = Math.floor(remainingSeconds / 60);
                const seconds = remainingSeconds % 60;
                const timerText = `${minutes}:${seconds.toString().padStart(2, '0')}`;

                const timerEl = buff.indicator.querySelector('.buff-timer');
                if (timerEl) {
                    timerEl.textContent = timerText;
                }
            }

            // UPDATED: Handles adding time correctly even if a buff is paused.
            addBuffTime(name, duration) {
                const buff = this.buffs[name];
                if (!buff) return;

                const wanderDot = Game.instance.wanderDot; // Get reference early
                const currentTime = Date.now();

                // Determine if this is the first activation or a stack/refresh
                // A buff is considered inactive if endTime is past AND it was NOT paused (remainingTimeOnPause is 0)
                const isCurrentlyInactive = buff.endTime <= currentTime && buff.remainingTimeOnPause === 0;

                // Calculate new end time
                // If paused, add duration to the remaining time
                if (buff.remainingTimeOnPause > 0) {
                    buff.remainingTimeOnPause += duration;
                    // If the game is running (which it must be to add a buff via click/eat), resume this specific buff
                    buff.endTime = currentTime + buff.remainingTimeOnPause;
                    buff.remainingTimeOnPause = 0;
                } else {
                    // If active or expired, calculate base time normally
                    const baseTime = Math.max(currentTime, buff.endTime);
                    buff.endTime = baseTime + duration;
                }

                buff.isEnding = false;

                if (isCurrentlyInactive) {
                    // Apply hunger restoration (only on initial activation)
                    if (buff.hungerRestore > 0 && wanderDot) {
                         wanderDot.hunger = Math.min(Config.MAX_HUNGER, wanderDot.hunger + buff.hungerRestore);
                    }

                    // Apply Coffee mood boost (only on initial activation)
                    if (name === 'coffee' && wanderDot) {
                        // Reduce annoyance significantly when coffee is used
                        wanderDot.applyMoodBoost(30);
                    }
                }


                this.setupBuffIndicator(buff);
                this.setupBlinkTimer(buff);
            }

            setupBuffIndicator(buff) {
                if (!buff.indicator) return;
                buff.indicator.style.display = 'flex';
                buff.indicator.classList.remove('blinking', 'blip-out');
                if (buff.isEureka) {
                    buff.indicator.classList.add('eureka-state');
                }
            }

            setupBlinkTimer(buff) {
                clearTimeout(buff.blinkTimer);
                const remainingTime = buff.endTime - Date.now();
                const BLINK_THRESHOLD = 3000;

                if (remainingTime > BLINK_THRESHOLD) {
                    buff.blinkTimer = setTimeout(() => {
                        // Check again before blinking, ensuring it's still active (endTime > Date.now()) and not paused
                        if (buff.endTime > Date.now() && buff.indicator) {
                            buff.indicator.classList.add('blinking');
                        }
                    }, remainingTime - BLINK_THRESHOLD);
                } else if (remainingTime > 0 && buff.indicator) {
                    buff.indicator.classList.add('blinking');
                }
            }

            deactivateBuff(name, force = false) {
                const buff = this.buffs[name];

                // Check if already inactive (endTime is 0 and not currently ending)
                if ((buff.endTime === 0 && !buff.isEnding)) return;

                if (name === 'kangaroo' && !force) {
                    if (Game.instance.wanderDot.verticalOffset > 0.1) {
                        buff.isEnding = true;
                        buff.endTime = 0;
                        return;
                    }
                }

                if (name === 'mushroom') {
                    const dot = Game.instance.wanderDot;
                    this.entityManager.addEntity('seed', dot.x, dot.y);
                }

                buff.endTime = 0;
                buff.isEureka = false;
                buff.isEnding = false;
                buff.remainingTimeOnPause = 0; // Ensure pause time is cleared
                clearTimeout(buff.blinkTimer);

                if (buff.indicator) {
                    buff.indicator.classList.add('blip-out');
                    buff.indicator.addEventListener('animationend', () => {
                        if (buff.indicator) {
                            buff.indicator.style.display = 'none';
                            buff.indicator.className = 'buff-indicator';
                        }
                    }, { once: true });
                }
            }

            getActiveBuffs() {
                const currentTime = Date.now();
                const active = {};
                Object.entries(this.buffs).forEach(([name, buff]) => {
                    // A buff is active if endTime is in the future OR if it's currently ending (like kangaroo landing)
                    // If the game is paused, buffs might have remainingTimeOnPause > 0, but we still consider them "active" conceptually for game logic
                    if (buff.endTime > currentTime || buff.isEnding || buff.remainingTimeOnPause > 0) {
                        active[name] = {
                            isEureka: buff.isEureka,
                            potency: buff.isEureka ? 2.0 : 1.0
                        };
                    }
                });
                return active;
            }

            isKangarooEnding() {
                return this.buffs.kangaroo?.isEnding;
            }

            applyWatchExtension() {
                Object.keys(this.buffs).forEach(name => {
                     // Check if the buff is active (endTime > now OR paused with remaining time)
                    if (name !== 'mushroom' && (this.buffs[name].endTime > Date.now() || this.buffs[name].remainingTimeOnPause > 0)) {
                        this.addBuffTime(name, Config.WATCH_TIME_EXTENSION);
                    }
                });
            }

            applyEureka() {
                Object.entries(this.buffs).forEach(([name, buff]) => {
                     // Check if the buff is active (endTime > now OR paused with remaining time)
                    if (name !== 'mushroom' && (buff.endTime > Date.now() || buff.remainingTimeOnPause > 0)) {
                        buff.isEureka = true;
                        if (buff.indicator) {
                            buff.indicator.classList.add('eureka-state');
                        }
                    }
                });
            }
        }

        class ItemManager {
            constructor(buffManager) {
                this.buffManager = buffManager;
                this.items = {};
                this.initializeDefinitions();
            }

            initializeDefinitions() {
                Object.entries(Config.Items).forEach(([name, data]) => {
                    if (name !== 'mushroom') {
                        this.items[name] = {
                            count: 0,
                            button: null,
                            emoji: data.emoji,
                            type: data.type
                        };
                    }
                });
            }

            initializeUI() {
                const itemBar = document.getElementById('item-bar');
                // Event listener handled by UIManager's chest button now, but we still need listeners on the buttons themselves
                itemBar.addEventListener('click', (event) => {
                    const button = event.target.closest('.item-button');
                    if (button && button.dataset.itemName) {
                        this.useItem(button.dataset.itemName);
                    }
                });

                Object.entries(this.items).forEach(([name, item]) => {
                    const button = document.createElement('button');
                    button.className = 'item-button';
                    button.dataset.itemName = name;
                    itemBar.appendChild(button);
                    item.button = button;
                });
                this.updateItemBar();
            }

            addItem(emoji) {
                const itemName = Object.keys(this.items).find(name => this.items[name].emoji === emoji);
                if (itemName) {
                    this.items[itemName].count++;
                    this.updateItemBar();
                    return true;
                }
                return false;
            }

            useItem(name) {
                const item = this.items[name];
                if (item.count > 0) {
                    item.count--;
                    this.updateItemBar();
                    this.animateButton(item.button);

                    if (item.type === 'buff') {
                        // Pass the duration stored in the BuffManager definition
                        this.buffManager.addBuffTime(name, this.buffManager.buffs[name].duration);
                    } else if (name === 'watch') {
                        this.buffManager.applyWatchExtension();
                    } else if (name === 'lightbulb') {
                        this.buffManager.applyEureka();
                    }
                }
            }

            animateButton(button) {
                if (!button) return;
                button.classList.add('clicked');
                button.addEventListener('animationend', () => button.classList.remove('clicked'), { once: true });
            }

            updateItemBar() {
                // Removed logic to toggle the main item bar visibility here, handled by UIManager/Chest button
                Object.values(this.items).forEach(item => {
                    if (item.button) {
                        if (item.count > 0) {
                            item.button.classList.add('visible');
                            item.button.textContent = `${item.emoji}x${item.count}`;
                        } else {
                            item.button.classList.remove('visible');
                        }
                    }
                });
            }
        }

        // ====================================================================
        // 5. PARTICLE SYSTEM & UFO
        // ====================================================================

        // (ParticleSystem and UFO implementations remain unchanged)
        class ParticleSystem {
            constructor(ctx) {
                this.ctx = ctx;
                this.particles = [];
            }

            spawnLandingParticles(x, y) {
                const count = 10;
                for(let i=0; i < count; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.random() * 50 + 20;
                    this.particles.push({
                        type: 'pebble', x: x, y: y,
                        dx: Math.cos(angle) * speed, dy: Math.sin(angle) * speed,
                        life: 1, maxLife: 1
                    });
                }
            }

            spawnUFOMist(x, y) {
                if (Math.random() < 0.5) return;

                this.particles.push({
                    type: 'mist',
                    x: x + (Math.random() - 0.5) * 80,
                    y: y + (Math.random() - 0.5) * 40,
                    dx: (Math.random() - 0.5) * 20,
                    dy: (Math.random() - 0.5) * 10,
                    life: 2, maxLife: 2
                });
            }

            updateAndDraw(deltaTime) {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const p = this.particles[i];
                    p.x += p.dx * deltaTime;
                    p.y += p.dy * deltaTime;
                    p.life -= deltaTime;

                    if(p.life <= 0) {
                        this.particles.splice(i, 1);
                    } else {
                        this.drawParticle(p);
                    }
                }
            }

            drawParticle(p) {
                const opacity = p.life / p.maxLife;
                this.ctx.beginPath();
                if(p.type === 'pebble') {
                    this.ctx.fillStyle = `rgba(30, 30, 30, ${0.5 * opacity})`;
                    this.ctx.arc(p.x, p.y, 2, 0, Math.PI * 2);
                } else if (p.type === 'mist') {
                    this.ctx.fillStyle = `rgba(200, 220, 255, ${0.2 * opacity})`;
                    this.ctx.arc(p.x, p.y, 10, 0, Math.PI * 2);
                }
                this.ctx.fill();
            }
        }

        class UFO {
            constructor(ctx, bounds) {
                this.ctx = ctx;
                this.bounds = bounds;
                this.active = false;
                this.x = 0;
                this.y = 0;
                this.speed = 300;
                this.direction = 1;
            }

            activate() {
                if (this.active) return;
                this.active = true;
                // Ensure UFO stays within the visible bounds (accounting for new bottom bar)
                this.y = Math.random() * (this.bounds.height * 0.6) + (this.bounds.height * 0.1);

                if(Math.random() < 0.5) {
                    this.direction = 1;
                    this.x = -50;
                } else {
                    this.direction = -1;
                    this.x = this.bounds.width + 50;
                }
            }

            update(deltaTime, particleManager, worldManager) {
                if (!this.active) return;

                this.x += this.speed * this.direction * deltaTime;

                particleManager.spawnUFOMist(this.x, this.y);

                if(Math.random() < 0.1) {
                    worldManager.alterGround(this.x + (Math.random() - 0.5) * 50, this.y + (Math.random() - 0.5) * 50);
                }

                if(this.x < -100 || this.x > this.bounds.width + 100) {
                    this.active = false;
                }
            }

            draw() {
                if (!this.active) return;
                this.ctx.font = '4rem monospace';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText('🛸', this.x, this.y);
                this.ctx.textAlign = 'start';
                this.ctx.textBaseline = 'alphabetic';
            }
        }

        // ====================================================================
        // 6. UI MANAGER (Thoughts, Timers, Interaction)
        // ====================================================================

        // UPDATED: Handles mood boosts on click, and uses accumulated game time for the timer.
        class UIManager {
            constructor(wanderDot) {
                this.wanderDot = wanderDot;
                this.thoughtBubble = document.getElementById('thought-bubble');
                this.worldTimerElement = document.getElementById('world-timer-display');

                // Stat Elements
                this.statStrength = document.getElementById('stat-strength').querySelector('span');
                this.statRadius = document.getElementById('stat-radius').querySelector('span');
                this.statSpeed = document.getElementById('stat-speed').querySelector('span');

                // Bar Graphs
                this.moodBarFill = document.getElementById('mood-bar-fill');
                this.moodBarBg = document.getElementById('mood-bar-bg'); // Need background to add/remove class
                this.hungerBarFill = document.getElementById('hunger-bar-fill');
                this.hungerBarBg = document.getElementById('hunger-bar-bg'); // Need background to add/remove class

                this.idleThoughtTimer = null;
                this.madThoughtTimer = null;
                this.thoughtTimeout = null;
                this.fadeTimeout = null;
                this.idleEmojiHistory = [];

                this.bubbleAngle = -Math.PI / 2;
                this.targetBubbleAngle = -Math.PI / 2;
                this.riseStartTime = 0;
                this.bounceEndTime = 0;

                this.isMouseOverBubble = false;
                this.thoughtTimeoutStartTime = 0;
                this.thoughtTimeoutDuration = 0;
                this.thoughtTimeoutRemaining = 0;
                this.mousePos = { x: 0, y: 0 };

                this.setupEventListeners();
            }

             setupEventListeners() {
                window.addEventListener('mousemove', (event) => {
                    this.mousePos.x = event.clientX;
                    this.mousePos.y = event.clientY;
                });

                this.thoughtBubble.addEventListener('click', (event) => {
                    event.stopPropagation();
                    this.handleThoughtClick();
                });

                this.thoughtBubble.addEventListener('mouseenter', () => this.handleBubbleEnter());
                this.thoughtBubble.addEventListener('mouseleave', () => this.handleBubbleLeave());

                // Chest button listener
                const chestButton = document.getElementById('chest-button');
                if (chestButton) {
                    chestButton.addEventListener('click', () => this.toggleItemBar());
                }
            }

            toggleItemBar() {
                const itemBar = document.getElementById('item-bar');
                if (itemBar) {
                    itemBar.classList.toggle('visible');
                }
            }

            getCurrentThought() {
                if (this.thoughtBubble.style.display === 'block') {
                    const span = this.thoughtBubble.querySelector('span');
                    // Return the base emoji if it's a timer thought
                    if (span) {
                        const text = span.textContent;
                        const match = text.match(/^(\p{Emoji})/u);
                        return match ? match[1] : text;
                    }
                }
                return null;
            }

            updateThoughtContent(content, isCompact = false) {
                if (this.thoughtBubble.style.display === 'block') {
                    const span = this.thoughtBubble.querySelector('span');
                    if (span) {
                         if (span.textContent !== content) {
                             span.textContent = content;
                        }
                        // Adjust font size if needed for compact display
                        const targetFontSize = isCompact ? '1.5rem' : '2.5rem';
                        if (this.thoughtBubble.style.fontSize !== targetFontSize) {
                             this.thoughtBubble.style.fontSize = targetFontSize;
                        }
                    }
                }
            }

            hideThought() {
                if (!this.isMouseOverBubble) {
                    this.thoughtBubble.style.opacity = 0;
                    this.fadeTimeout = setTimeout(() => {
                        this.thoughtBubble.style.display = 'none';
                    }, 300);
                }
            }
             getNextIdleEmoji() {
                const candidateEmojis = Config.Emojis.idle.filter(e => !this.idleEmojiHistory.includes(e));
                const emojiPool = candidateEmojis.length > 0 ? candidateEmojis : Config.Emojis.idle;
                const nextEmoji = Utils.randomChoice(emojiPool);

                this.idleEmojiHistory.push(nextEmoji);
                if (this.idleEmojiHistory.length > 3) {
                    this.idleEmojiHistory.shift();
                }
                return nextEmoji;
            }

            startMadTimer() {
                this.stopMadTimer();
                this.madThoughtTimer = setInterval(() => {
                    // Don't show mad thoughts if Hangry
                    if (this.wanderDot.currentMoodState === 'mad' && !this.wanderDot.isHangry) {
                        this.showThought(Utils.randomChoice(Config.Emojis.madZone));
                    } else if (this.wanderDot.currentMoodState !== 'mad') {
                        this.stopMadTimer();
                    }
                }, 3000);
            }

            stopMadTimer() {
                clearInterval(this.madThoughtTimer);
                this.madThoughtTimer = null;
            }

            // UPDATED: Apply mood boost on click for specific thoughts.
            handleThoughtClick() {
                const emoji = this.getCurrentThought();

                // NEW: Check for clickable mood boosting emojis (🎮, 🎥)
                if (emoji === '🎮' || emoji === '🎥') {
                   this.wanderDot.applyMoodBoost(Config.MOOD_BOOST_CLICKABLE_THOUGHT);
                }

                const collected = Game.instance.itemManager.addItem(emoji);

                if (!collected) {
                    if (emoji === '👽') {
                        Game.instance.ufo.activate();
                    }
                }

                clearTimeout(this.thoughtTimeout);
                clearTimeout(this.fadeTimeout);
                this.thoughtBubble.style.display = 'none';
                this.isMouseOverBubble = false;
            }

            handleBubbleEnter() {
                this.isMouseOverBubble = true;
                this.thoughtTimeoutRemaining = this.thoughtTimeoutDuration - (Date.now() - this.thoughtTimeoutStartTime);
                clearTimeout(this.thoughtTimeout);
                clearTimeout(this.fadeTimeout);
                this.thoughtBubble.style.opacity = 1;
            }

            handleBubbleLeave() {
                this.isMouseOverBubble = false;
                this.thoughtTimeout = setTimeout(() => this.hideThought(), Math.max(500, this.thoughtTimeoutRemaining));
            }

            // UPDATED: Accepts accumulatedGameTime instead of worldCreationTime
            update(accumulatedGameTime) {
                this.updateTimer(accumulatedGameTime);
                this.updateStats();
                this.updateBarGraphs();
                if (this.thoughtBubble.style.display === 'block') {
                    this.updateBubblePosition();
                }
            }

            // UPDATED: Uses the provided elapsedTime (from accumulatedGameTime)
            updateTimer(elapsedTime) {
                // const elapsedTime = Date.now() - worldCreationTime; // Old implementation
                // elapsedTime is provided in milliseconds
                const elapsedSeconds = Math.floor(elapsedTime / 1000);
                const minutes = Math.floor(elapsedSeconds / 60);
                const seconds = elapsedSeconds % 60;

                const timerText = `[${minutes}m:${seconds.toString().padStart(2, '0')}s]`;
                this.worldTimerElement.textContent = timerText;
            }

            updateStats() {
                // Strength is the multiplier
                this.statStrength.textContent = this.wanderDot.currentStrengthMultiplier.toFixed(2) + 'x';
                // Radius is the pixel radius
                this.statRadius.textContent = this.wanderDot.radius.toFixed(1) + 'px';
                // Speed is the base speed multiplied by the current speed multiplier (ignoring kangaroo boost for UI stability)
                const effectiveSpeed = this.wanderDot.speed * this.wanderDot.currentSpeedMultiplier;
                this.statSpeed.textContent = effectiveSpeed.toFixed(1);
            }

            updateBarGraphs() {
                // Mood Bar (Annoyance 0 = 100% Green, Annoyance 100 = 0% Red)
                const moodRatio = 1 - (this.wanderDot.annoyance / 100);
                this.moodBarFill.style.width = `${moodRatio * 100}%`;
                // Lerp color from Red (0) to Green (1)
                const moodColor = Utils.lerpColor({r: 220, g: 50, b: 40}, {r: 50, g: 205, b: 50}, moodRatio);
                this.moodBarFill.style.backgroundColor = moodColor;

                // Manage Mood Text Visibility
                if (this.wanderDot.currentMoodState === 'mad' || this.wanderDot.currentMoodState === 'annoyed') {
                    this.moodBarBg.classList.add('active-state');
                } else {
                    this.moodBarBg.classList.remove('active-state');
                }

                // Hunger Bar (Hunger 100 = 100% Green, Hunger 0 = 0% Red)
                const hungerRatio = this.wanderDot.hunger / Config.MAX_HUNGER;
                this.hungerBarFill.style.width = `${hungerRatio * 100}%`;
                const hungerColor = Utils.lerpColor({r: 220, g: 50, b: 40}, {r: 154, g: 205, b: 50}, hungerRatio); // Different green for hunger
                this.hungerBarFill.style.backgroundColor = hungerColor;

                // Manage Hunger Text Visibility
                if (this.wanderDot.hunger < Config.HANGRY_HUNGER_THRESHOLD) {
                    this.hungerBarBg.classList.add('active-state');
                } else {
                    this.hungerBarBg.classList.remove('active-state');
                }
            }

            // UPDATED: Removed automatic mood boost application.
            showThought(emoji, duration = 2000) {
                if (!emoji) return;

                // Mood boosts (🎮, 🎥) are now handled in handleThoughtClick()

                clearTimeout(this.thoughtTimeout);
                clearTimeout(this.fadeTimeout);

                this.prepareBubbleAnimation();

                this.thoughtBubble.innerHTML = `<span>${emoji}</span>`;
                this.thoughtBubble.style.fontSize = '2.5rem'; // Ensure font size is reset to default
                this.thoughtBubble.style.opacity = 1;
                this.thoughtBubble.style.display = 'block';

                this.thoughtTimeoutStartTime = Date.now();
                this.thoughtTimeoutDuration = duration;
                this.thoughtTimeout = setTimeout(() => this.hideThought(), duration);
            }

            prepareBubbleAnimation() {
                if (this.thoughtBubble.style.display === 'block') {
                    this.bounceEndTime = Date.now() + 300;
                } else {
                    const initialOrbitRadius = this.wanderDot.radius;
                    const initialX = this.wanderDot.x + Math.cos(this.bubbleAngle) * initialOrbitRadius;
                    const initialY = this.wanderDot.y + Math.sin(this.bubbleAngle) * initialOrbitRadius;
                    this.thoughtBubble.style.left = `${initialX}px`;
                    this.thoughtBubble.style.top = `${initialY}px`;
                }

                this.thoughtBubble.classList.remove('is-rising');
                void this.thoughtBubble.offsetWidth;
                this.thoughtBubble.classList.add('is-rising');
                this.riseStartTime = Date.now();
            }

            // --- IDLE THOUGHT SCHEDULING (Unchanged) ---
            scheduleNextIdleThought(delay = 7000) {
                const IDLE_THOUGHT_DURATION = 4000;
                const BREAK_DURATION = 7000;

                clearTimeout(this.idleThoughtTimer);
                this.idleThoughtTimer = setTimeout(() => {
                    // Only show if idle AND not annoyed AND not Hangry
                    if (this.wanderDot.targetX === null &&
                        !this.wanderDot.isEating &&
                        !this.wanderDot.isHangry &&
                        this.wanderDot.annoyance < Config.WARNING_ANNOYANCE_THRESHOLD) {

                        const nextEmoji = this.getNextIdleEmoji();
                        this.showThought(nextEmoji, IDLE_THOUGHT_DURATION);

                        this.scheduleNextIdleThought(IDLE_THOUGHT_DURATION + 300 + BREAK_DURATION);
                    } else {
                        // If busy, check again later
                        this.scheduleNextIdleThought(BREAK_DURATION);
                    }
                }, delay);
            }

            // (updateBubblePosition, findBestBubbleAngle, calculateBubbleAnimations remain unchanged)
            updateBubblePosition() {
                const bubbleWidth = this.thoughtBubble.offsetWidth;
                const bubbleHeight = this.thoughtBubble.offsetHeight;
                const finalOrbitRadius = this.wanderDot.radius + bubbleHeight / 2 + 5;

                this.targetBubbleAngle = this.findBestBubbleAngle(finalOrbitRadius, bubbleWidth, bubbleHeight);
                this.bubbleAngle = Utils.lerp(this.bubbleAngle, this.targetBubbleAngle, 0.1);

                const { radius, verticalBob } = this.calculateBubbleAnimations(finalOrbitRadius);

                let bubbleTargetX = this.wanderDot.x + Math.cos(this.bubbleAngle) * radius;
                let bubbleTargetY = this.wanderDot.y - this.wanderDot.verticalOffset + Math.sin(this.bubbleAngle) * radius + verticalBob;

                if(this.isMouseOverBubble) {
                    const currentX = parseFloat(this.thoughtBubble.style.left) || bubbleTargetX;
                    const currentY = parseFloat(this.thoughtBubble.style.top) || bubbleTargetY;
                    bubbleTargetX = Utils.lerp(currentX, this.mousePos.x, 0.2);
                    bubbleTargetY = Utils.lerp(currentY, this.mousePos.y, 0.2);
                }

                this.thoughtBubble.style.left = `${bubbleTargetX}px`;
                this.thoughtBubble.style.top = `${bubbleTargetY}px`;
            }

            findBestBubbleAngle(radius, width, height) {
                const SAFE_MARGIN = 10;
                const bounds = Game.instance.bounds;
                const startAngle = -Math.PI / 2;

                for (let offset = 0; offset < Math.PI; offset += 0.1) {
                    for (const sign of [1, -1]) {
                        const angle = startAngle + offset * sign;
                        const testX = this.wanderDot.x + Math.cos(angle) * radius;
                        const testY = this.wanderDot.y + Math.sin(angle) * radius;

                        if (testX - width / 2 > SAFE_MARGIN && testX + width / 2 < bounds.width - SAFE_MARGIN &&
                            testY - height / 2 > SAFE_MARGIN && testY + height / 2 < bounds.height - SAFE_MARGIN) {
                            return angle;
                        }
                    }
                }
                return this.targetBubbleAngle;
            }

            calculateBubbleAnimations(finalOrbitRadius) {
                let radius = finalOrbitRadius;
                let verticalBob = 0;
                const animTime = Date.now();

                if (this.riseStartTime > 0 && animTime - this.riseStartTime < 400) {
                    const riseProgress = (animTime - this.riseStartTime) / 400;
                    radius = Utils.lerp(this.wanderDot.radius, finalOrbitRadius, riseProgress);
                } else {
                    this.riseStartTime = 0;
                    if (this.bounceEndTime > 0 && animTime < this.bounceEndTime) {
                        const bounceProgress = (animTime - (this.bounceEndTime - 300)) / 300;
                        verticalBob = Math.sin(bounceProgress * Math.PI) * -15;
                    } else {
                        this.bounceEndTime = 0;
                        verticalBob = Math.sin(animTime / 400) * -3;
                    }
                }
                return { radius, verticalBob };
            }
        }

        // ====================================================================
        // 7. GAME (Main Loop, Initialization)
        // ====================================================================

        // UPDATED: Handles accumulated game time and pause/resume integration with BuffManager.
        class Game {
            static instance = null;

            constructor() {
                if (Game.instance) return Game.instance;
                Game.instance = this;

                this.assetManager = new AssetManager();
                this.isInitialized = false;

                this.initializeCanvases();
                this.bounds = { width: this.mainCanvas.width, height: this.mainCanvas.height };

                this.accumulatedGameTime = 0; // NEW: Tracks actual time the game has been active (in ms)
                this.lastFrameTime = 0;
                this.lastClickTime = 0;
                // Game state
                this.isRunning = false;
                this.isPaused = false; // Differentiate between stopped (game over) and paused
                this.animationFrameId = null;

                // Load assets first, then proceed with initialization
                this.assetManager.loadAll(() => this.initializeAfterLoading());
            }

            initializeCanvases() {
                this.worldContainer = document.getElementById('world-container');
                this.mainCanvas = document.getElementById('mainCanvas');
                this.ctx = this.mainCanvas.getContext('2d');
                this.pathCanvas = document.getElementById('pathCanvas');
                this.pathCtx = this.pathCanvas.getContext('2d');
                this.entityCanvas = document.getElementById('entityCanvas');
                this.entityCtx = this.entityCanvas.getContext('2d');

                this.resizeCanvases();
            }

            resizeCanvases() {
                const width = window.innerWidth;

                // Calculate height based on the bottom bar's actual rendered height
                const bottomBar = document.getElementById('bottom-bar');
                // Use offsetHeight to get the dynamic height (important for mobile responsiveness)
                const bottomBarHeight = bottomBar ? bottomBar.offsetHeight : 80;
                const height = window.innerHeight - bottomBarHeight;

                this.worldContainer.style.width = `${width}px`;
                this.worldContainer.style.height = `${height}px`;

                this.mainCanvas.width = this.pathCanvas.width = this.entityCanvas.width = width;
                this.mainCanvas.height = this.pathCanvas.height = this.entityCanvas.height = height;
            }

            initializeAfterLoading() {
                // Ensure sizes are correct after assets might have affected layout (e.g., chest image loading)
                this.resizeCanvases();
                this.bounds = { width: this.mainCanvas.width, height: this.mainCanvas.height };

                this.initializeGameObjects();

                // Initialize UIs
                this.buffManager.initializeUI();
                this.itemManager.initializeUI();

                this.finalizeInitialization();
                this.setupEventListeners();
                this.isInitialized = true;
                this.start();
            }

            initializeGameObjects() {
                this.entityManager = new EntityManager(this.entityCtx);
                this.worldManager = new WorldManager(this.bounds.width, this.bounds.height, this.pathCtx, this.entityManager, this.assetManager);
                this.wanderDot = new WanderDot(this.bounds.width / 2, this.bounds.height / 2);
                this.uiManager = new UIManager(this.wanderDot);
                this.buffManager = new BuffManager(this.entityManager);
                this.itemManager = new ItemManager(this.buffManager);

                this.particleManager = new ParticleSystem(this.ctx);
                this.ufo = new UFO(this.ctx, this.bounds);
            }

            finalizeInitialization() {
                // Generate the world fresh
                this.worldManager.generateGrassField();
                this.worldManager.redrawWorld();

                // Ensure WanderDot starts within the new boundaries
                this.wanderDot.x = Utils.clamp(this.wanderDot.x, Config.BASE_RADIUS, this.bounds.width - Config.BASE_RADIUS);
                this.wanderDot.y = Utils.clamp(this.wanderDot.y, Config.BASE_RADIUS, this.bounds.height - Config.BASE_RADIUS);
                this.wanderDot.previousX = this.wanderDot.x;
                this.wanderDot.previousY = this.wanderDot.y;
            }

            // --- EVENTS ---
            setupEventListeners() {
                window.addEventListener('resize', () => this.handleResize());
                this.mainCanvas.addEventListener('pointerdown', (event) => this.handleClick(event));

                // Restart button listener
                const restartButton = document.getElementById('restart-button');
                if (restartButton) {
                    restartButton.addEventListener('click', () => this.restartGame());
                }

                // Pause/Resume listeners
                document.addEventListener('visibilitychange', () => this.handleVisibilityChange());
                const resumeButton = document.getElementById('resume-button');
                if (resumeButton) {
                    resumeButton.addEventListener('click', () => this.resumeGame());
                }
            }

            // Handle Visibility Change
            handleVisibilityChange() {
                if (!this.isInitialized || !this.isRunning) return;

                if (document.hidden) {
                    this.pauseGame();
                }
                // We do not auto-resume, waiting for the button click.
            }

            // UPDATED: Pause Game (includes pausing buffs)
            pauseGame() {
                if (this.isPaused) return;
                this.isPaused = true;

                // NEW: Pause Buff timers
                this.buffManager.pauseAllBuffs();

                // Stop the animation loop
                if (this.animationFrameId) {
                    cancelAnimationFrame(this.animationFrameId);
                    this.animationFrameId = null;
                }

                // Show the pause overlay
                document.getElementById('pause-overlay').style.display = 'flex';

                // Crucial: Reset lastFrameTime so deltaTime doesn't jump when resuming
                this.lastFrameTime = 0;
            }

            // UPDATED: Resume Game (includes resuming buffs)
            resumeGame() {
                if (!this.isPaused) return;
                this.isPaused = false;

                // NEW: Resume Buff timers
                this.buffManager.resumeAllBuffs();

                // Hide the pause overlay
                document.getElementById('pause-overlay').style.display = 'none';

                // Restart the animation loop if the game is still running (not game over)
                if (this.isRunning) {
                    this.animationFrameId = requestAnimationFrame((time) => this.animate(time));
                }
            }


            handleResize() {
                 if (!this.isInitialized) return;

                // Resize canvases and the world container
                this.resizeCanvases();

                // Update bounds based on the new canvas size
                this.bounds.width = this.mainCanvas.width;
                this.bounds.height = this.mainCanvas.height;

                // Notify managers to adapt to the new size
                this.worldManager.handleResize(this.bounds.width, this.bounds.height);
                this.entityManager.needsRedraw = true;
                // Update UFO bounds reference
                this.ufo.bounds = this.bounds;
            }

            handleClick(event) {
                // UPDATED: Prevent clicks if the game is over or paused
                if (!this.isRunning || this.isPaused) return;

                // Prevent default browser behavior
                event.preventDefault();

                const clickX = event.clientX;
                const clickY = event.clientY;

                // Check if click is on the thought bubble
                if (this.uiManager.thoughtBubble.style.display === 'block') {
                    const bubbleRect = this.uiManager.thoughtBubble.getBoundingClientRect();
                    if (clickX >= bubbleRect.left && clickX <= bubbleRect.right &&
                        clickY >= bubbleRect.top && clickY <= bubbleRect.bottom) {
                        return;
                    }
                }

                const currentTime = Date.now();
                const timeDiff = currentTime - this.lastClickTime;

                const distanceToCenter = Utils.distance(clickX, clickY, this.wanderDot.x, this.wanderDot.y - this.wanderDot.verticalOffset);
                const isDirectClick = distanceToCenter <= this.wanderDot.radius;

                let commandAccepted = false;

                // Try to issue command
                if (!isDirectClick) {
                   commandAccepted = this.wanderDot.setTarget(clickX, clickY);
                } else {
                    // Direct click always registers as interaction (unless Hangry)
                    commandAccepted = !this.wanderDot.isHangry;
                    if (commandAccepted) {
                        this.wanderDot.clearTarget();
                        // Cancel eating on direct click.
                        if (this.wanderDot.isEating) {
                            if (this.wanderDot.eatingStartTime > 0) {
                                this.wanderDot.triggerHangry(true); // Interrupted
                                commandAccepted = false;
                            } else {
                                // Cancel seeking without penalty
                                this.wanderDot.isEating = false;
                                this.wanderDot.eatingTarget = null;
                                if (this.uiManager.getCurrentThought() === Config.Emojis.EATING_SEEKING) {
                                    this.uiManager.hideThought();
                                }
                            }
                        }
                    }
                }

                // Calculate and apply annoyance from the click itself
                if (commandAccepted || this.wanderDot.isHangry) {
                    // Annoyance from clicks is still applied on top of the natural decay/restoration
                    const annoyanceToAdd = Math.min(35, 10 + (2500 / timeDiff));
                    const reactionEmoji = this.wanderDot.addAnnoyance(annoyanceToAdd, isDirectClick);

                    // Show reaction thought, unless chewing
                    if (!(this.wanderDot.isEating && this.wanderDot.eatingStartTime > 0)) {
                         this.uiManager.showThought(reactionEmoji);
                    }
                }

                // Manage Mad Timer
                const currentMood = this.wanderDot.currentMoodState;
                if (currentMood === 'mad' && !this.uiManager.madThoughtTimer) {
                     this.uiManager.startMadTimer();
                }

                this.lastClickTime = currentTime;
                this.uiManager.scheduleNextIdleThought();
            }

            checkGameOver() {
                // Game over if annoyance hits 100 AND hunger hits 0
                if (this.wanderDot.annoyance >= 100 && this.wanderDot.hunger <= 0) {
                    this.gameOver();
                }
            }

            // UPDATED: Use accumulatedGameTime for the final score.
            gameOver() {
                this.isRunning = false;
                this.isPaused = false; // Ensure pause state is cleared
                if (this.animationFrameId) {
                    cancelAnimationFrame(this.animationFrameId);
                    this.animationFrameId = null;
                }

                // Calculate survival time using the accumulated active game time
                const elapsedTime = this.accumulatedGameTime;
                // const elapsedTime = Date.now() - this.worldCreationTime; // Old implementation
                const elapsedSeconds = Math.floor(elapsedTime / 1000);
                const minutes = Math.floor(elapsedSeconds / 60);
                const seconds = elapsedSeconds % 60;
                const survivalTimeText = `[${minutes}m:${seconds.toString().padStart(2, '0')}s]`;

                // Show the modal
                document.getElementById('survival-time').textContent = survivalTimeText;
                const gameOverOverlay = document.getElementById('game-over-overlay');
                gameOverOverlay.style.display = 'flex';
            }

            restartGame() {
                // Easiest way to reset the entire state
                location.reload();
            }


            // Main game loop
            animate(currentTime) {
                // UPDATED: Check if running
                if (!this.isRunning) return;
                this.animationFrameId = requestAnimationFrame((time) => this.animate(time));

                // If paused, we skip the update/draw logic but keep the RAF loop going (or rely on cancel/restart in pause/resume)
                // We rely on cancel/restart in pause/resume, so if we are here, we assume we are not paused.

                if (!this.isInitialized) return;

                if (!this.lastFrameTime) {
                    this.lastFrameTime = currentTime;
                    return;
                }
                const deltaTime = (currentTime - this.lastFrameTime) / 1000;

                // Handle large deltaTime spikes (often happens after resuming from a long pause)
                if (deltaTime > 0.1) {
                     this.lastFrameTime = currentTime;
                     this.updateTimeBasedSystems();
                     return;
                }

                this.lastFrameTime = currentTime;

                this.update(deltaTime);
                this.draw(deltaTime);
            }

            // UPDATED: Pass accumulatedGameTime to UIManager
            updateTimeBasedSystems() {
                this.entityManager.update(this.worldManager);
                this.buffManager.update();
                // Pass the accumulated game time instead of worldCreationTime
                this.uiManager.update(this.accumulatedGameTime);
            }

            update(deltaTime) {
                // NEW: Accumulate active game time
                this.accumulatedGameTime += deltaTime * 1000; // deltaTime is in seconds, store in ms

                // Update WanderDot
                // Pass entityManager to WanderDot update for flower detection
                const transitionEmoji = this.wanderDot.update(deltaTime, this.bounds, this.buffManager, this.worldManager, this.entityManager);

                // Check for game over after WanderDot updates its state
                this.checkGameOver();
                if (!this.isRunning) return;

                if (transitionEmoji) {
                    this.uiManager.showThought(transitionEmoji);
                    if (transitionEmoji === Config.Emojis.cooldownToAnnoyed[0]) {
                        this.uiManager.stopMadTimer();
                    }
                }

                this.updateTimeBasedSystems();

                // Update grass animations and health
                this.worldManager.updateGrass(deltaTime);

                // Update UFO
                this.ufo.update(deltaTime, this.particleManager, this.worldManager);
            }

            // Implements dynamic sorting (Painter's Algorithm) for grass and WanderDot.
            draw(deltaTime) {
                // Clear main canvas
                this.ctx.clearRect(0, 0, this.bounds.width, this.bounds.height);

                // Draw environment/entities (on their respective canvases)
                this.entityManager.draw(this.bounds);

                // --- Dynamic Sorting (Z-sorting) ---

                // 1. Create a list of all objects to be sorted
                const sortedDrawables = [];

                // Add grass blades
                for (const blade of this.worldManager.grassBlades) {
                    sortedDrawables.push({
                        y: blade.y, // The base Y position of the grass blade
                        type: 'grass',
                        data: blade
                    });
                }

                // Add WanderDot
                sortedDrawables.push({
                    y: this.wanderDot.getBaseY(), // The base Y position of the WanderDot
                    type: 'wanderdot',
                    data: this.wanderDot
                });

                // 2. Sort the list by Y coordinate (ascending: back to front)
                sortedDrawables.sort((a, b) => a.y - b.y);

                // 3. Draw objects in sorted order on the main canvas (this.ctx)
                for (const drawable of sortedDrawables) {
                    if (drawable.type === 'grass') {
                        this.worldManager.drawBlade(this.ctx, drawable.data);
                    } else if (drawable.type === 'wanderdot') {
                        drawable.data.draw(this.ctx);
                    }
                }

                // Draw actors always on top (UFO)
                this.ufo.draw();

                // Draw particles (always on top)
                this.particleManager.updateAndDraw(deltaTime);
            }

            start() {
                // Start is called after assets load in initializeAfterLoading
                this.isRunning = true;
                this.isPaused = false;
                this.uiManager.scheduleNextIdleThought();
                this.animationFrameId = requestAnimationFrame((time) => this.animate(time));
            }
        }

        // ====================================================================
        // 8. STARTUP
        // ====================================================================
        document.addEventListener('DOMContentLoaded', () => {
            // Check for Brown Mushroom emoji support
            if (!Utils.checkEmojiSupport(Config.Emojis.BROWN_MUSHROOM)) {
                Config.Emojis.BROWN_MUSHROOM = '🥀';
            }

            // Initialization starts here.
            const game = new Game();
        });

    </script>
</body>
</html>
