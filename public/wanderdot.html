<!DOCTYPE html>
<html lang="en">
<head>
Â  Â  <meta charset="UTF-8">
Â  Â  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
Â  Â  <title>WanderDot's World</title>
Â  Â  <style>
Â  Â  Â  Â  /* --- 1. CSS VARIABLES & SETUP --- */
Â  Â  Â  Â  :root {
Â  Â  Â  Â  Â  Â  --color-field-bg: #013220;
Â  Â  Â  Â  Â  Â  --color-ui-bg: rgba(0, 0, 0, 0.4);
Â  Â  Â  Â  Â  Â  --color-ui-border: #ccc;
Â  Â  Â  Â  Â  Â  --color-text: white;
Â  Â  Â  Â  Â  Â  --color-eureka-glow: gold;
Â  Â  Â  Â  Â  Â  --color-thought-bg: rgba(25, 25, 112, 0.5);
Â  Â  Â  Â  Â  Â  --font-main: monospace;
Â  Â  Â  Â  }

Â  Â  Â  Â  /* Strict overflow hidden to prevent mobile scrolling/OOB viewing */
Â  Â  Â  Â  html, body {
Â  Â  Â  Â  Â  Â  margin: 0;
Â  Â  Â  Â  Â  Â  padding: 0;
Â  Â  Â  Â  Â  Â  overflow: hidden;
Â  Â  Â  Â  Â  Â  width: 100%;
Â  Â  Â  Â  Â  Â  height: 100%;
Â  Â  Â  Â  }

Â  Â  Â  Â  body {
Â  Â  Â  Â  Â  Â  background-color: var(--color-field-bg);
Â  Â  Â  Â  Â  Â  font-family: var(--font-main);
Â  Â  Â  Â  Â  Â  cursor: default;
Â  Â  Â  Â  Â  Â  user-select: none;Â 
Â  Â  Â  Â  }

Â  Â  Â  Â  /* --- 2. WORLD CONTAINERS & LAYERS --- */
Â  Â  Â  Â  #world-container {
Â  Â  Â  Â  Â  Â  position: relative;
Â  Â  Â  Â  Â  Â  width: 100vw;
Â  Â  Â  Â  Â  Â  height: 100vh;
Â  Â  Â  Â  Â  Â  overflow: hidden;
Â  Â  Â  Â  }

Â  Â  Â  Â  #grass-field {
Â  Â  Â  Â  Â  Â  position: absolute;
Â  Â  Â  Â  Â  Â  top: 0; left: 0;
Â  Â  Â  Â  Â  Â  width: 100%; height: 100%;
Â  Â  Â  Â  Â  Â  overflow: hidden;
Â  Â  Â  Â  Â  Â  pointer-events: none;
Â  Â  Â  Â  Â  Â  z-index: 0;
Â  Â  Â  Â  }

Â  Â  Â  Â  .grass-tuft {
Â  Â  Â  Â  Â  Â  position: absolute;
Â  Â  Â  Â  Â  Â  font-weight: bold;
Â  Â  Â  Â  }

Â  Â  Â  Â  canvas {
Â  Â  Â  Â  Â  Â  display: block;
Â  Â  Â  Â  Â  Â  position: absolute;
Â  Â  Â  Â  Â  Â  top: 0; left: 0;
Â  Â  Â  Â  }

Â  Â  Â  Â  #pathCanvas { z-index: 1; }
Â  Â  Â  Â  #entityCanvas { z-index: 2; }Â 
Â  Â  Â  Â  #mainCanvas { z-index: 3; }

Â  Â  Â  Â  /* --- 3. UI ELEMENTS --- */

Â  Â  Â  Â  /* Thought Bubble (Unchanged) */
Â  Â  Â  Â  #thought-bubble {
Â  Â  Â  Â  Â  Â  position: absolute;
Â  Â  Â  Â  Â  Â  display: none;
Â  Â  Â  Â  Â  Â  font-size: 2.5rem;
Â  Â  Â  Â  Â  Â  padding: 0.6rem;
Â  Â  Â  Â  Â  Â  background-color: var(--color-thought-bg);
Â  Â  Â  Â  Â  Â  border: 2px solid var(--color-ui-border);
Â  Â  Â  Â  Â  Â  border-radius: 50%;
Â  Â  Â  Â  Â  Â  backdrop-filter: blur(3px);
Â  Â  Â  Â  Â  Â  transition: opacity 0.3s ease-in-out, left 0.1s linear, top 0.1s linear;Â 
Â  Â  Â  Â  Â  Â  z-index: 4;
Â  Â  Â  Â  Â  Â  cursor: pointer;
Â  Â  Â  Â  Â  Â  transform: translate(-50%, -50%);Â 
Â  Â  Â  Â  }

Â  Â  Â  Â  .is-rising {
Â  Â  Â  Â  Â  Â  animation: rise-up 0.4s cubic-bezier(0.18, 0.89, 0.32, 1.28);
Â  Â  Â  Â  }

Â  Â  Â  Â  #thought-bubble > span {
Â  Â  Â  Â  Â  Â  pointer-events: none;
Â  Â  Â  Â  }

Â  Â  Â  Â  /* Buff Container - Updated for Safe Area */
Â  Â  Â  Â  #buff-container {
Â  Â  Â  Â  Â  Â  position: absolute;
Â  Â  Â  Â  Â  Â  top: 20px; right: 20px;
            /* Add safe area support for mobile devices */
            top: max(20px, env(safe-area-inset-top));
            right: max(20px, env(safe-area-inset-right));
Â  Â  Â  Â  Â  Â  display: flex;
Â  Â  Â  Â  Â  Â  flex-direction: row-reverse;
Â  Â  Â  Â  Â  Â  gap: 15px;
Â  Â  Â  Â  Â  Â  z-index: 5;
Â  Â  Â  Â  }

Â  Â  Â  Â  .buff-indicator {
Â  Â  Â  Â  Â  Â  display: none;
Â  Â  Â  Â  Â  Â  flex-direction: column;
Â  Â  Â  Â  Â  Â  align-items: center;
Â  Â  Â  Â  Â  Â  text-shadow: 0 0 5px black;
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  .buff-icon {
Â  Â  Â  Â  Â  Â  font-size: 1.5rem;
Â  Â  Â  Â  Â  Â  transition: box-shadow 0.3s ease-in-out;
Â  Â  Â  Â  }

Â  Â  Â  Â  .eureka-state .buff-icon {
Â  Â  Â  Â  Â  Â  border-radius: 5px;
Â  Â  Â  Â  Â  Â  box-shadow: 0 0 8px 3px var(--color-eureka-glow);
Â  Â  Â  Â  }

Â  Â  Â  Â  .buff-timer {
Â  Â  Â  Â  Â  Â  font-size: 0.8rem;
Â  Â  Â  Â  Â  Â  color: var(--color-text);
Â  Â  Â  Â  Â  Â  margin-top: 2px;
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  /* Item Bar - Updated for Safe Area */
Â  Â  Â  Â  #item-bar {
Â  Â  Â  Â  Â  Â  position: absolute;
Â  Â  Â  Â  Â  Â  bottom: -100px;
Â  Â  Â  Â  Â  Â  left: 50%;
Â  Â  Â  Â  Â  Â  transform: translateX(-50%);
Â  Â  Â  Â  Â  Â  background-color: var(--color-ui-bg);
Â  Â  Â  Â  Â  Â  border: 2px solid var(--color-ui-border);
Â  Â  Â  Â  Â  Â  border-bottom: none;
Â  Â  Â  Â  Â  Â  border-radius: 10px 10px 0 0;
Â  Â  Â  Â  Â  Â  padding: 5px;
Â  Â  Â  Â  Â  Â  display: flex;
Â  Â  Â  Â  Â  Â  gap: 5px;
Â  Â  Â  Â  Â  Â  z-index: 5;
Â  Â  Â  Â  Â  Â  transition: bottom 0.4s ease-in-out;
Â  Â  Â  Â  }

Â  Â  Â  Â  #item-bar.visible {
Â  Â  Â  Â  Â  Â  bottom: 0;
            /* Add safe area support for mobile devices */
            bottom: max(0px, env(safe-area-inset-bottom));
Â  Â  Â  Â  }

Â  Â  Â  Â  .item-button {
Â  Â  Â  Â  Â  Â  background-color: #333;
Â  Â  Â  Â  Â  Â  border: 2px solid #888;
Â  Â  Â  Â  Â  Â  border-radius: 5px;
Â  Â  Â  Â  Â  Â  color: var(--color-text);
Â  Â  Â  Â  Â  Â  font-size: 1rem;
Â  Â  Â  Â  Â  Â  width: 60px; height: 60px;
Â  Â  Â  Â  Â  Â  cursor: pointer;
Â  Â  Â  Â  Â  Â  display: none;
Â  Â  Â  Â  Â  Â  align-items: center;
Â  Â  Â  Â  Â  Â  justify-content: center;
Â  Â  Â  Â  }

Â  Â  Â  Â  .item-button.visible {
Â  Â  Â  Â  Â  Â  display: flex;
Â  Â  Â  Â  }

Â  Â  Â  Â  .item-button.clicked {
Â  Â  Â  Â  Â  Â  animation: use-item-anim 0.2s ease-out;
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  /* World Timer (Top Left) - Updated for Rollout Animation, Mobile Wrap, and Safe Area */
Â  Â  Â  Â  #timer-container {
Â  Â  Â  Â  Â  Â  position: absolute;
Â  Â  Â  Â  Â  Â  top: 10px; left: 10px;
            /* Add safe area support for mobile devices */
            top: max(10px, env(safe-area-inset-top));
            left: max(10px, env(safe-area-inset-left));
Â  Â  Â  Â  Â  Â  z-index: 5;
Â  Â  Â  Â  Â  Â  display: flex;
Â  Â  Â  Â  Â  Â  align-items: flex-start; /* Changed from center so icon stays on top if text wraps */
            max-width: calc(100% - 120px); /* Constrain width to prevent overlap with buffs on mobile */
Â  Â  Â  Â  }

Â  Â  Â  Â  #timer-icon {
Â  Â  Â  Â  Â  Â  font-size: 1.2rem;
Â  Â  Â  Â  Â  Â  background-color: var(--color-ui-bg);
Â  Â  Â  Â  Â  Â  border: 2px solid rgba(204, 204, 204, 0.5);
Â  Â  Â  Â  Â  Â  padding: 5px;
Â  Â  Â  Â  Â  Â  border-radius: 4px;
Â  Â  Â  Â  Â  Â  cursor: pointer;Â 
Â  Â  Â  Â  Â  Â  display: flex;
Â  Â  Â  Â  Â  Â  align-items: center;
Â  Â  Â  Â  Â  Â  justify-content: center;
Â  Â  Â  Â  Â  Â  width: 1.8rem; height: 1.8rem;
Â  Â  Â  Â  }

Â  Â  Â  Â  #world-timer {
Â  Â  Â  Â  Â  Â  margin-left: 10px;
Â  Â  Â  Â  Â  Â  font-size: 0.9rem;
Â  Â  Â  Â  Â  Â  color: var(--color-text);
Â  Â  Â  Â  Â  Â  text-shadow: 0 0 5px black;
Â  Â  Â  Â  Â  Â  background-color: rgba(128, 128, 128, 0.3);
Â  Â  Â  Â  Â  Â  border-radius: 5px;
Â  Â  Â  Â  Â  Â  white-space: nowrap; /* Keep nowrap during transition for smooth rollout */
Â  Â  Â  Â  Â  Â  pointer-events: none;
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  /* Rollout transition setup */
Â  Â  Â  Â  Â  Â  opacity: 0;
Â  Â  Â  Â  Â  Â  max-width: 0;
Â  Â  Â  Â  Â  Â  padding: 8px 0px; /* Vertical padding only */
Â  Â  Â  Â  Â  Â  overflow: hidden;
Â  Â  Â  Â  Â  Â  transition: opacity 0.3s ease-in-out, max-width 0.5s ease-in-out, padding 0.5s ease-in-out;
Â  Â  Â  Â  }

Â  Â  Â  Â  /* Active states for rollout (Hover or Clicked) */
Â  Â  Â  Â  #timer-container:hover #world-timer,
Â  Â  Â  Â  #timer-container.active #world-timer {
Â  Â  Â  Â  Â  Â  opacity: 1;
Â  Â  Â  Â  Â  Â  max-width: 600px; /* Ample space for the text */
Â  Â  Â  Â  Â  Â  padding: 8px 12px; /* Restore horizontal padding */
            white-space: normal; /* Allow wrapping when fully expanded */
Â  Â  Â  Â  }


Â  Â  Â  Â  /* --- 4. KEYFRAME ANIMATIONS (Unchanged) --- */
Â  Â  Â  Â  @keyframes rise-up {
Â  Â  Â  Â  Â  Â  from { opacity: 0; transform: translate(-50%, -50%) scale(0.4); }
Â  Â  Â  Â  Â  Â  to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
Â  Â  Â  Â  }

Â  Â  Â  Â  @keyframes blink {
Â  Â  Â  Â  Â  Â  50% { opacity: 0.2; }
Â  Â  Â  Â  }
Â  Â  Â  Â  .blinking {
Â  Â  Â  Â  Â  Â  animation: blink 0.5s infinite;
Â  Â  Â  Â  }

Â  Â  Â  Â  @keyframes blip-out {
Â  Â  Â  Â  Â  Â  to { transform: scale(0); opacity: 0; }
Â  Â  Â  Â  }
Â  Â  Â  Â  .blip-out {
Â  Â  Â  Â  Â  Â  animation: blip-out 0.3s forwards;
Â  Â  Â  Â  }

Â  Â  Â  Â  @keyframes use-item-anim {
Â  Â  Â  Â  Â  Â  50% { transform: scale(0.85); }
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  @keyframes wiggle {
Â  Â  Â  Â  Â  Â  0%, 100% { transform: rotate(0deg); }
Â  Â  Â  Â  Â  Â  25% { transform: rotate(15deg); }
Â  Â  Â  Â  Â  Â  75% { transform: rotate(-15deg); }
Â  Â  Â  Â  }
Â  Â  </style>
</head>
<body>
Â  Â  <div id="world-container">
Â  Â  Â  Â  <div id="grass-field"></div>
Â  Â  Â  Â  <canvas id="pathCanvas"></canvas>
Â  Â  Â  Â  <canvas id="entityCanvas"></canvas>
Â  Â  Â  Â  <canvas id="mainCanvas"></canvas>
Â  Â  Â  Â Â 
Â  Â  Â  Â  <div id="thought-bubble"></div>
Â  Â  Â  Â  <div id="timer-container">
Â  Â  Â  Â  Â  Â  <div id="timer-icon">ğŸ•°ï¸</div>
Â  Â  Â  Â  Â  Â  <div id="world-timer"></div>
Â  Â  Â  Â  </div>
Â  Â  Â  Â  <div id="buff-container"></div>
Â  Â  Â  Â  <div id="item-bar"></div>
Â  Â  </div>

Â  Â  <script>
Â  Â  Â  Â  // ====================================================================
Â  Â  Â  Â  // 0. CONFIGURATION & UTILITIES
Â  Â  Â  Â  // ====================================================================

Â  Â  Â  Â  const Config = {
Â  Â  Â  Â  Â  Â  SAVE_KEY: 'WanderDot_Refactored_V6_Save',
Â  Â  Â  Â  Â  Â  SAVE_INTERVAL: 10000, // ms

Â  Â  Â  Â  Â  Â  // Mood Thresholds
Â  Â  Â  Â  Â  Â  WARNING_ANNOYANCE_THRESHOLD: 25,
Â  Â  Â  Â  Â  Â  ANNOYANCE_THRESHOLD: 40,
Â  Â  Â  Â  Â  Â  MAD_THRESHOLD: 75,
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // Colors
Â  Â  Â  Â  Â  Â  COLOR_NORMAL: { r: 255, g: 255, b: 224 },
Â  Â  Â  Â  Â  Â  COLOR_ANNOYED: { r: 255, g: 165, b: 0 },
Â  Â  Â  Â  Â  Â  COLOR_MAD: { r: 152, g: 14, b: 11 },
Â  Â  Â  Â  Â  Â  COLOR_HANGRY_GLOW: 'rgba(255, 100, 100, 0.7)',
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // Terrain Colors
Â  Â  Â  Â  Â  Â  COLOR_FIELD: { r: 1, g: 50, b: 32 },
Â  Â  Â  Â  Â  Â  COLOR_DIRT: { r: 101, g: 67, b: 33 },
Â  Â  Â  Â  Â  Â  COLOR_ALIEN_BLUE: { r: 100, g: 149, b: 237 },Â 
Â  Â  Â  Â  Â  Â  COLOR_ALIEN_CLAY: { r: 205, g: 133, b: 63 },

Â  Â  Â  Â  Â  Â  // World Grid
Â  Â  Â  Â  Â  Â  GRID_CELL_SIZE: 10,
Â  Â  Â  Â  Â  Â  MAX_WEAR: 100,
Â  Â  Â  Â  Â  Â  WEAR_PER_PIXEL: 0.05,
Â  Â  Â  Â  Â  Â  GRASS_REMOVAL_THRESHOLD: 50,
Â  Â  Â  Â  Â  Â  PEBBLE_SPAWN_THRESHOLD: 70,
Â  Â  Â  Â  Â  Â  GRASS_TUFT_COUNT: 300,
Â  Â  Â  Â  Â  Â  UFO_MUSHROOM_CHANCE: 0.015,

Â  Â  Â  Â  Â  Â  // WanderDot Base Stats
Â  Â  Â  Â  Â  Â  BASE_SPEED: 120,
Â  Â  Â  Â  Â  Â  BASE_RADIUS: 20,
Â  Â  Â  Â  Â  Â  EAT_MUSHROOM_CHANCE: 0.02,
Â  Â  Â  Â  Â  Â  EAT_DETECTION_RADIUS: 100,
Â  Â  Â  Â  Â  Â  EAT_DURATION: 3500,

Â  Â  Â  Â  Â  Â  // Kangaroo Mechanics
Â  Â  Â  Â  Â  Â  BOUNCE_DISTANCE: 120,
Â  Â  Â  Â  Â  Â  BOUNCE_HEIGHT: 60,
Â  Â  Â  Â  Â  Â  BASE_IMPACT_WEAR: 15,

Â  Â  Â  Â  Â  Â  // Buffs & Items Configuration
Â  Â  Â  Â  Â  Â  WATCH_TIME_EXTENSION: 20000,
Â  Â  Â  Â  Â  Â  MUSHROOM_BUFF_DURATION: 20000,
Â  Â  Â  Â  Â  Â  SEED_MATURATION_TIME: 60000,

Â  Â  Â  Â  Â  Â  Items: {
Â  Â  Â  Â  Â  Â  Â  Â  watch: { emoji: 'âŒš', type: 'utility' },
Â  Â  Â  Â  Â  Â  Â  Â  coffee: { emoji: 'â˜•', type: 'buff', duration: 20000 },
Â  Â  Â  Â  Â  Â  Â  Â  pizza: { emoji: 'ğŸ•', type: 'buff', duration: 30000 },
Â  Â  Â  Â  Â  Â  Â  Â  kangaroo: { emoji: 'ğŸ¦˜', type: 'buff', duration: 30000 },
Â  Â  Â  Â  Â  Â  Â  Â  lightbulb: { emoji: 'ğŸ’¡', type: 'utility' },
                // hideTimer: true correctly hides the digestion/buff timer.
Â  Â  Â  Â  Â  Â  Â  Â  mushroom: { emoji: 'ğŸ„', type: 'buff', hideTimer: true }Â 
Â  Â  Â  Â  Â  Â  },

Â  Â  Â  Â  Â  Â  // Emojis
Â  Â  Â  Â  Â  Â  Emojis: {
Â  Â  Â  Â  Â  Â  Â  Â  idle: ['ğŸ’¡', 'ğŸ˜´', 'ğŸ®', 'ğŸ¶', 'â˜•', 'âŒš', 'ğŸ•', 'ğŸ‘½', 'ğŸ¦˜','ğŸ¥'],
Â  Â  Â  Â  Â  Â  Â  Â  commandReceived: ['ğŸ¤”','ğŸ‘€'],
Â  Â  Â  Â  Â  Â  Â  Â  annoyed: ['ğŸ˜’', 'ğŸ™„', 'ğŸ˜‘', 'ğŸ¤¨'],
Â  Â  Â  Â  Â  Â  Â  Â  mad: ['ğŸ˜«', 'ğŸ¤¡', 'ğŸ‘º', 'ğŸ˜¡', 'ğŸ¤¬'],
Â  Â  Â  Â  Â  Â  Â  Â  madZone: ['ğŸ‘¿', 'â˜ ï¸', 'ğŸ‘', 'ğŸ¤¬'],
Â  Â  Â  Â  Â  Â  Â  Â  cooldownToAnnoyed: ['ğŸ˜¤'],
Â  Â  Â  Â  Â  Â  Â  Â  cooldownToNormal: ['ğŸ¥°'],
Â  Â  Â  Â  Â  Â  Â  Â  directClick: ['ğŸ˜˜', 'ğŸ¤­', 'ğŸ˜›', 'ğŸ˜³', 'ğŸ¥µ', 'ğŸ†', 'ğŸ’¦'],
Â  Â  Â  Â  Â  Â  Â  Â  EATING_SEEKING: 'ğŸ‘…',
Â  Â  Â  Â  Â  Â  Â  Â  EATING_CONSUMING: 'ğŸ¤¤',
Â  Â  Â  Â  Â  Â  Â  Â  EATING_SATISFIED: 'ğŸ˜‹',
Â  Â  Â  Â  Â  Â  Â  Â  // Entities
Â  Â  Â  Â  Â  Â  Â  Â  SEED: 'ğŸ¥”',
Â  Â  Â  Â  Â  Â  Â  Â  FLOWER: 'ğŸŒ¼',
                // Changed from 'ğŸ„â€ğŸŸ«' to 'ğŸ¥€' due to potential display issues on some OS.
Â  Â  Â  Â  Â  Â  Â  Â  BROWN_MUSHROOM: 'ğŸ¥€',
Â  Â  Â  Â  Â  Â  Â  Â  DIAMOND: 'ğŸ”¸',
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  };

Â  Â  Â  Â  // Terrain Types Enum
Â  Â  Â  Â  const TerrainType = {
Â  Â  Â  Â  Â  Â  NORMAL: 'normal',
Â  Â  Â  Â  Â  Â  ALIEN_BLUE: 'alienBlue',
Â  Â  Â  Â  Â  Â  ALIEN_CLAY: 'alienClay'
Â  Â  Â  Â  };

Â  Â  Â  Â  const Utils = {
Â  Â  Â  Â  Â  Â  lerp(start, end, amount) {
Â  Â  Â  Â  Â  Â  Â  Â  return start * (1 - amount) + end * amount;
Â  Â  Â  Â  Â  Â  },
Â  Â  Â  Â  Â  Â  lerpColor(colorA, colorB, amount) {
Â  Â  Â  Â  Â  Â  Â  Â  const r = Math.round(Utils.lerp(colorA.r, colorB.r, amount));
Â  Â  Â  Â  Â  Â  Â  Â  const g = Math.round(Utils.lerp(colorA.g, colorB.g, amount));
Â  Â  Â  Â  Â  Â  Â  Â  const b = Math.round(Utils.lerp(colorA.b, colorB.b, amount));
Â  Â  Â  Â  Â  Â  Â  Â  return `rgb(${r}, ${g}, ${b})`;
Â  Â  Â  Â  Â  Â  },
Â  Â  Â  Â  Â  Â  randomChoice(arr) {
Â  Â  Â  Â  Â  Â  Â  Â  return arr[Math.floor(Math.random() * arr.length)];
Â  Â  Â  Â  Â  Â  },
Â  Â  Â  Â  Â  Â  distance(x1, y1, x2, y2) {
Â  Â  Â  Â  Â  Â  Â  Â  return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
Â  Â  Â  Â  Â  Â  },
Â  Â  Â  Â  Â  Â  clamp(num, min, max) {
Â  Â  Â  Â  Â  Â  Â  Â  return Math.max(min, Math.min(max, num));
Â  Â  Â  Â  Â  Â  },
Â  Â  Â  Â  Â  Â  randomRange(min, max) {
Â  Â  Â  Â  Â  Â  Â  Â  return Math.random() * (max - min) + min;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  };

Â  Â  Â  Â  // ====================================================================
Â  Â  Â  Â  // 1. ENTITY MANAGER (Seeds, Diamonds, Pebbles, Mushrooms)
Â  Â  Â  Â  // ====================================================================
Â  Â  Â  Â Â 
Â  Â  Â  Â  class EntityManager {
Â  Â  Â  Â  Â  Â  constructor(ctx) {
Â  Â  Â  Â  Â  Â  Â  Â  this.ctx = ctx;
Â  Â  Â  Â  Â  Â  Â  Â  this.pebbles = [];
Â  Â  Â  Â  Â  Â  Â  Â  this.mushrooms = [];
Â  Â  Â  Â  Â  Â  Â  Â  this.dynamicEntities = [];
Â  Â  Â  Â  Â  Â  Â  Â  this.needsRedraw = true;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  loadState(saveData) {
Â  Â  Â  Â  Â  Â  Â  Â  this.pebbles = saveData.pebbles ?? [];
Â  Â  Â  Â  Â  Â  Â  Â  this.mushrooms = saveData.mushrooms ?? [];
Â  Â  Â  Â  Â  Â  Â  Â  this.dynamicEntities = saveData.dynamicEntities ?? [];
Â  Â  Â  Â  Â  Â  Â  Â  this.needsRedraw = true;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  saveState() {
Â  Â  Â  Â  Â  Â  Â  Â  return {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  pebbles: this.pebbles,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  mushrooms: this.mushrooms,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  dynamicEntities: this.dynamicEntities,
Â  Â  Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // --- Dynamic Entities ---
Â  Â  Â  Â  Â  Â  addEntity(type, x, y, data = {}) {
Â  Â  Â  Â  Â  Â  Â  Â  const entity = {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  type: type,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  x: x, y: y,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  createdAt: Date.now(),
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ...data
Â  Â  Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  Â  Â  this.dynamicEntities.push(entity);
Â  Â  Â  Â  Â  Â  Â  Â  this.needsRedraw = true;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // NEW: Remove specific dynamic entities in an area
Â  Â  Â  Â  Â  Â  removeDynamicEntitiesInArea(x, y, radius) {
Â  Â  Â  Â  Â  Â  Â  Â  let removed = false;
Â  Â  Â  Â  Â  Â  Â  Â  const radiusSq = radius * radius;
Â  Â  Â  Â  Â  Â  Â  Â  const destructibleTypes = ['flower', 'brownMushroom'];

Â  Â  Â  Â  Â  Â  Â  Â  for (let i = this.dynamicEntities.length - 1; i >= 0; i--) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const entity = this.dynamicEntities[i];

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (destructibleTypes.includes(entity.type)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const distSq = (entity.x - x)**2 + (entity.y - y)**2;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Check if the entity center is within the radius
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (distSq < radiusSq) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.dynamicEntities.splice(i, 1);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  removed = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  if (removed) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.needsRedraw = true;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  return removed;
Â  Â  Â  Â  Â  Â  }


Â  Â  Â  Â  Â  Â  update(worldManager) {
Â  Â  Â  Â  Â  Â  Â  Â  const now = Date.now();
Â  Â  Â  Â  Â  Â  Â  Â  for (let i = this.dynamicEntities.length - 1; i >= 0; i--) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const entity = this.dynamicEntities[i];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (entity.type === 'seed') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (now - entity.createdAt > Config.SEED_MATURATION_TIME) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.matureSeed(entity, i, worldManager);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  matureSeed(seed, index, worldManager) {
Â  Â  Â  Â  Â  Â  Â  Â  const terrainInfo = worldManager.getTerrainInfoAtPoint(seed.x, seed.y);
Â  Â  Â  Â  Â  Â  Â  Â  let newType = null;

Â  Â  Â  Â  Â  Â  Â  Â  if (terrainInfo.wear < Config.GRASS_REMOVAL_THRESHOLD) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (terrainInfo.type === TerrainType.NORMAL) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  newType = 'flower';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else if (terrainInfo.type === TerrainType.ALIEN_BLUE) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  newType = 'brownMushroom';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  if (newType) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  seed.type = newType;
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.dynamicEntities.splice(index, 1);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  this.needsRedraw = true;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // --- Static Entities (Pebbles, Mushrooms) (Unchanged) ---
Â  Â  Â  Â  Â  Â  addPebble(pebble) {
Â  Â  Â  Â  Â  Â  Â  Â  this.pebbles.push(pebble);
Â  Â  Â  Â  Â  Â  Â  Â  this.needsRedraw = true;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  addMushroom(mushroom) {
Â  Â  Â  Â  Â  Â  Â  Â  if(!this.mushrooms.some(m => m.gridX === mushroom.gridX && m.gridY === mushroom.gridY)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.mushrooms.push(mushroom);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.needsRedraw = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return true;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  return false;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  removeMushroomByObject(mushroomObject) {
Â  Â  Â  Â  Â  Â  Â  Â  const index = this.mushrooms.indexOf(mushroomObject);
Â  Â  Â  Â  Â  Â  Â  Â  if (index > -1) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.mushrooms.splice(index, 1);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.needsRedraw = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return true;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  return false;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  removeMushroomInArea(x, y, radius) {
Â  Â  Â  Â  Â  Â  Â  Â  let removed = false;
Â  Â  Â  Â  Â  Â  Â  Â  for(let i = this.mushrooms.length - 1; i >= 0; i--) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const m = this.mushrooms[i];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (Utils.distance(m.x, m.y, x, y) < radius) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.mushrooms.splice(i, 1);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  removed = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  if (removed) this.needsRedraw = true;
Â  Â  Â  Â  Â  Â  Â  Â  return removed;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  getNearbyMushroom(x, y, radius) {
Â  Â  Â  Â  Â  Â  Â  Â  let closest = null;
Â  Â  Â  Â  Â  Â  Â  Â  let minDistSq = radius * radius;

Â  Â  Â  Â  Â  Â  Â  Â  for (const m of this.mushrooms) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const distSq = (m.x - x)**2 + (m.y - y)**2;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (distSq < minDistSq) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  minDistSq = distSq;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  closest = m;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  return closest;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // --- Rendering (Unchanged) ---
Â  Â  Â  Â  Â  Â  draw(bounds) {
Â  Â  Â  Â  Â  Â  Â  Â  if (!this.needsRedraw) return;

Â  Â  Â  Â  Â  Â  Â  Â  this.ctx.clearRect(0, 0, bounds.width, bounds.height);
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  this.drawPebbles();
Â  Â  Â  Â  Â  Â  Â  Â  this.drawDynamicEntities();
Â  Â  Â  Â  Â  Â  Â  Â  this.drawMushrooms();
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  this.needsRedraw = false;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  drawPebbles() {
Â  Â  Â  Â  Â  Â  Â  Â  this.ctx.font = 'bold 0.7rem monospace';
Â  Â  Â  Â  Â  Â  Â  Â  this.pebbles.forEach(p => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.ctx.fillStyle = p.color;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.ctx.globalAlpha = p.type === 'spaceRock' ? 1.0 : 0.8;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.ctx.fillText(p.char, p.x, p.y);
Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  drawMushrooms() {
Â  Â  Â  Â  Â  Â  Â  Â  this.ctx.font = '1rem monospace';
Â  Â  Â  Â  Â  Â  Â  Â  this.ctx.globalAlpha = 1.0;
Â  Â  Â  Â  Â  Â  Â  Â  this.mushrooms.forEach(m => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.ctx.fillText('ğŸ„', m.x, m.y);
Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  drawDynamicEntities() {
Â  Â  Â  Â  Â  Â  Â  Â  this.ctx.globalAlpha = 1.0;
Â  Â  Â  Â  Â  Â  Â  Â  this.dynamicEntities.forEach(e => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let emoji = '';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let fontSize = '1rem';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let textShadow = 'none';

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (e.type === 'seed') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  emoji = Config.Emojis.SEED;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  fontSize = '0.5rem'; // Tiny
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Use text shadow to make the emoji appear dark/black
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  textShadow = '0 0 2px black, 0 0 2px black, 0 0 2px black';Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  else if (e.type === 'flower') emoji = Config.Emojis.FLOWER;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  else if (e.type === 'brownMushroom') emoji = Config.Emojis.BROWN_MUSHROOM;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  else if (e.type === 'diamond') emoji = Config.Emojis.DIAMOND;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (emoji) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.ctx.font = `${fontSize} monospace`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.ctx.shadowColor = textShadow === 'none' ? 'transparent' : 'black';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.ctx.shadowBlur = textShadow === 'none' ? 0 : 2;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.ctx.fillText(emoji, e.x, e.y);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.ctx.shadowBlur = 0; // Reset shadow
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  // ====================================================================
Â  Â  Â  Â  // 2. WORLD MANAGER (Environment, Paths, Grass)
Â  Â  Â  Â  // ====================================================================

Â  Â  Â  Â  class WorldManager {
Â  Â  Â  Â  Â  Â  // (Constructor and Initialization methods remain robust for resizing)
Â  Â  Â  Â  Â  Â  constructor(width, height, pathCtx, entityManager) {
Â  Â  Â  Â  Â  Â  Â  Â  this.width = width;
Â  Â  Â  Â  Â  Â  Â  Â  this.height = height;
Â  Â  Â  Â  Â  Â  Â  Â  this.pathCtx = pathCtx;
Â  Â  Â  Â  Â  Â  Â  Â  this.entityManager = entityManager;

Â  Â  Â  Â  Â  Â  Â  Â  this.pathGrid = [];
Â  Â  Â  Â  Â  Â  Â  Â  this.grassGrid = [];
Â  Â  Â  Â  Â  Â  Â  Â  this.grassTufts = [];
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  this.initializeGrid();
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  initializeGrid() {
Â  Â  Â  Â  Â  Â  Â  Â  const gridWidth = Math.ceil(this.width / Config.GRID_CELL_SIZE);
Â  Â  Â  Â  Â  Â  Â  Â  const gridHeight = Math.ceil(this.height / Config.GRID_CELL_SIZE);

Â  Â  Â  Â  Â  Â  Â  Â  const newPathGrid = [];
Â  Â  Â  Â  Â  Â  Â  Â  const newGrassGrid = [];

Â  Â  Â  Â  Â  Â  Â  Â  // This logic correctly preserves data during resize
Â  Â  Â  Â  Â  Â  Â  Â  for (let i = 0; i < gridWidth; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  newPathGrid[i] = [];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  newGrassGrid[i] = [];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  for (let j = 0; j < gridHeight; j++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.pathGrid[i] && this.pathGrid[i][j]) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  newPathGrid[i][j] = this.pathGrid[i][j];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  newPathGrid[i][j] = { wear: 0, hasPebble: false, terrainType: TerrainType.NORMAL, mistOpacity: 0 };
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  newGrassGrid[i][j] = [];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  this.pathGrid = newPathGrid;
Â  Â  Â  Â  Â  Â  Â  Â  this.grassGrid = newGrassGrid;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // --- Persistence & Setup (Unchanged) ---
Â  Â  Â  Â  Â  Â  loadState(saveData) {
Â  Â  Â  Â  Â  Â  Â  Â  const loadedGrid = saveData.pathGrid;
Â  Â  Â  Â  Â  Â  Â  Â  if (!loadedGrid || loadedGrid.length === 0) return;

Â  Â  Â  Â  Â  Â  Â  Â  const gridWidth = this.pathGrid.length;
Â  Â  Â  Â  Â  Â  Â  Â  const gridHeight = this.pathGrid[0].length;
Â  Â  Â  Â  Â  Â  Â  Â  const loadedWidth = loadedGrid.length;
Â  Â  Â  Â  Â  Â  Â  Â  const loadedHeight = loadedGrid[0]?.length || 0;

Â  Â  Â  Â  Â  Â  Â  Â  for (let i = 0; i < Math.min(gridWidth, loadedWidth); i++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  for (let j = 0; j < Math.min(gridHeight, loadedHeight); j++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (loadedGrid[i] && loadedGrid[i][j]) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (loadedGrid[i][j].terrainType === 'alien') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  loadedGrid[i][j].terrainType = TerrainType.ALIEN_BLUE;Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.pathGrid[i][j] = loadedGrid[i][j];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  saveState() {
Â  Â  Â  Â  Â  Â  Â  Â  const clonedPathGrid = this.pathGrid.map(row => row.map(cell => ({...cell})));
Â  Â  Â  Â  Â  Â  Â  Â  return {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  pathGrid: clonedPathGrid,
Â  Â  Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  handleResize(width, height) {
Â  Â  Â  Â  Â  Â  Â  Â  this.width = width;
Â  Â  Â  Â  Â  Â  Â  Â  this.height = height;
Â  Â  Â  Â  Â  Â  Â  Â  this.initializeGrid();
Â  Â  Â  Â  Â  Â  Â  Â  this.generateGrassField();
Â  Â  Â  Â  Â  Â  Â  Â  this.redrawWorld();
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  redrawWorld() {
Â  Â  Â  Â  Â  Â  Â  Â  this.pathCtx.clearRect(0, 0, this.width, this.height);
Â  Â  Â  Â  Â  Â  Â  Â  for (let i = 0; i < this.pathGrid.length; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  for (let j = 0; j < this.pathGrid[i].length; j++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const cell = this.pathGrid[i][j];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (cell.wear > 0 || cell.terrainType !== TerrainType.NORMAL) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.drawPathCell(i, j);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // --- Utility Functions (Unchanged) ---
Â  Â  Â  Â  Â  Â  isValidCell(gridX, gridY) {
Â  Â  Â  Â  Â  Â  Â  Â  return gridX >= 0 && gridX < this.pathGrid.length && gridY >= 0 && gridY < this.pathGrid[0].length;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  getTerrainInfoAtPoint(x, y) {
Â  Â  Â  Â  Â  Â  Â  Â  const gridX = Math.floor(x / Config.GRID_CELL_SIZE);
Â  Â  Â  Â  Â  Â  Â  Â  const gridY = Math.floor(y / Config.GRID_CELL_SIZE);
Â  Â  Â  Â  Â  Â  Â  Â  if (this.isValidCell(gridX, gridY)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const cell = this.pathGrid[gridX][gridY];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return { type: cell.terrainType, wear: cell.wear };
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  return { type: TerrainType.NORMAL, wear: 0 };
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // --- GRASS MANAGEMENT (Unchanged) ---
Â  Â  Â  Â  Â  Â  generateGrassField() {
Â  Â  Â  Â  Â  Â  Â  Â  const field = document.getElementById('grass-field');
Â  Â  Â  Â  Â  Â  Â  Â  field.innerHTML = '';
Â  Â  Â  Â  Â  Â  Â  Â  this.grassTufts = [];
Â  Â  Â  Â  Â  Â  Â  Â  const grassTypes = ['^^', '^^^', '/\\/\\', '-^-', 'vV'];
Â  Â  Â  Â  Â  Â  Â  Â  const grassColors = ['#228B22', '#3CB371', '#6B8E23', '#556B2F'];

Â  Â  Â  Â  Â  Â  Â  Â  for (let i = 0; i < Config.GRASS_TUFT_COUNT; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const tuftEl = document.createElement('span');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const xVw = Math.random() * 100;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const yVh = Math.random() * 100;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const xPx = xVw / 100 * this.width;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const yPx = yVh / 100 * this.height;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  tuftEl.classList.add('grass-tuft');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  tuftEl.textContent = Utils.randomChoice(grassTypes);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  tuftEl.style.color = Utils.randomChoice(grassColors);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  tuftEl.style.left = `${xVw}vw`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  tuftEl.style.top = `${yVh}vh`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  tuftEl.style.fontSize = `${Math.random() * 0.8 + 0.5}rem`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  tuftEl.style.opacity = Math.random() * 0.5 + 0.4;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  field.appendChild(tuftEl);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const tuftData = { element: tuftEl, x: xPx, y: yPx, visible: true };
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.grassTufts.push(tuftData);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const gridX = Math.floor(xPx / Config.GRID_CELL_SIZE);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const gridY = Math.floor(yPx / Config.GRID_CELL_SIZE);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.isValidCell(gridX, gridY)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.grassGrid[gridX][gridY].push(tuftData);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.pathGrid[gridX][gridY].wear > Config.GRASS_REMOVAL_THRESHOLD) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.hideTuft(tuftData);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  updateGrassInCell(gridX, gridY) {
Â  Â  Â  Â  Â  Â  Â  Â  const tufts = this.grassGrid[gridX]?.[gridY];
Â  Â  Â  Â  Â  Â  Â  Â  if (!tufts) return;

Â  Â  Â  Â  Â  Â  Â  Â  tufts.forEach(tuft => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (tuft.visible) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.hideTuft(tuft);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  hideTuft(tuftData) {
Â  Â  Â  Â  Â  Â  Â  Â  tuftData.element.style.display = 'none';
Â  Â  Â  Â  Â  Â  Â  Â  tuftData.visible = false;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  wiggleNearbyGrass(x, y) {
Â  Â  Â  Â  Â  Â  Â  Â  const WIGGLE_RADIUS = 70;
Â  Â  Â  Â  Â  Â  Â  Â  this.grassTufts.forEach(tuft => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (tuft.visible && Utils.distance(tuft.x, tuft.y, x, y) < WIGGLE_RADIUS) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  tuft.element.style.animation = 'wiggle 0.5s ease-out';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  tuft.element.addEventListener('animationend', () => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  tuft.element.style.animation = '';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }, { once: true });
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // --- WEAR AND TEAR ---

Â  Â  Â  Â  Â  Â  applyMovementWear(startX, startY, endX, endY, buffManager) {
Â  Â  Â  Â  Â  Â  Â  Â  const distance = Utils.distance(startX, startY, endX, endY);
Â  Â  Â  Â  Â  Â  Â  Â  const steps = Math.ceil(distance / (Config.GRID_CELL_SIZE / 2));
Â  Â  Â  Â  Â  Â  Â  Â  if (steps === 0) return;

Â  Â  Â  Â  Â  Â  Â  Â  const buffs = buffManager.getActiveBuffs();
Â  Â  Â  Â  Â  Â  Â  Â  let wearMultiplier = Config.WEAR_PER_PIXEL;
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  // Coffee increases wear rate
Â  Â  Â  Â  Â  Â  Â  Â  if (buffs.coffee) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  wearMultiplier *= (1 + 1.0 * buffs.coffee.potency);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  // NEW: Mushroom increases wear rate (100% increase)
Â  Â  Â  Â  Â  Â  Â  Â  if (buffs.mushroom) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  wearMultiplier *= (1 + 1.0 * buffs.mushroom.potency);
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // Determine wear radius based on size buffs
Â  Â  Â  Â  Â  Â  Â  Â  let wearRadius = 1;
Â  Â  Â  Â  Â  Â  Â  Â  if (buffs.pizza || buffs.mushroom) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  wearRadius = 2;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  // Stacking check
Â  Â  Â  Â  Â  Â  Â  Â  if (buffs.pizza && buffs.mushroom) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  wearRadius = 3;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // NEW: Destruction check
Â  Â  Â  Â  Â  Â  Â  Â  const isHeavy = buffs.pizza || buffs.mushroom;
Â  Â  Â  Â  Â  Â  Â  Â  const currentDotRadius = Game.instance.wanderDot.radius;


Â  Â  Â  Â  Â  Â  Â  Â  for (let i = 0; i <= steps; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const t = i / steps;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const currentX = Utils.lerp(startX, endX, t);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const currentY = Utils.lerp(startY, endY, t);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.applyWearToArea(currentX, currentY, wearRadius, (distance/steps) * wearMultiplier);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // NEW: Entity Destruction while rolling
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (isHeavy) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.entityManager.removeDynamicEntitiesInArea(currentX, currentY, currentDotRadius);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  applyLandingImpact(x, y, moodState, buffManager) {
Â  Â  Â  Â  Â  Â  Â  Â  let impactWear = Config.BASE_IMPACT_WEAR;
Â  Â  Â  Â  Â  Â  Â  Â  const buffs = buffManager.getActiveBuffs();
Â  Â  Â  Â  Â  Â  Â  Â  const isHeavy = buffs.pizza || buffs.mushroom;

Â  Â  Â  Â  Â  Â  Â  Â  if (buffs.coffee) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  impactWear *= (1 + 1.0 * buffs.coffee.potency);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  if (buffs.kangaroo) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  impactWear *= (1 + 0.3 * buffs.kangaroo.potency);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  // NEW: Mushroom increases impact wear (100% increase)
Â  Â  Â  Â  Â  Â  Â  Â  if (buffs.mushroom) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  impactWear *= (1 + 1.0 * buffs.mushroom.potency);
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  if (moodState === 'mad') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  impactWear *= 1.7;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.wiggleNearbyGrass(x, y);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Game.instance.particleManager.spawnLandingParticles(x, y);
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  const impactRadius = 2.5;
Â  Â  Â  Â  Â  Â  Â  Â  this.applyWearToArea(x, y, impactRadius, impactWear, true);
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  // Entity Destruction on impact
Â  Â  Â  Â  Â  Â  Â  Â  this.entityManager.removeMushroomInArea(x, y, Config.BASE_RADIUS * 2);

Â  Â  Â  Â  Â  Â  Â  Â  // NEW: Destroy flowers/brown mushrooms if heavy
Â  Â  Â  Â  Â  Â  Â  Â  if (isHeavy) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const currentDotRadius = Game.instance.wanderDot.radius;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.entityManager.removeDynamicEntitiesInArea(x, y, currentDotRadius);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  applyWearToArea(x, y, radius, wearAmount, useFalloff = false) {
Â  Â  Â  Â  Â  Â  Â  Â  const centerX = Math.floor(x / Config.GRID_CELL_SIZE);
Â  Â  Â  Â  Â  Â  Â  Â  const centerY = Math.floor(y / Config.GRID_CELL_SIZE);
Â  Â  Â  Â  Â  Â  Â  Â  const radiusSq = radius * radius;

Â  Â  Â  Â  Â  Â  Â  Â  for (let i = -Math.ceil(radius); i <= Math.ceil(radius); i++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  for (let j = -Math.ceil(radius); j <= Math.ceil(radius); j++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const distSq = i * i + j * j;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (!useFalloff && distSq > radiusSq) continue;Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const distance = Math.sqrt(distSq);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (useFalloff && distance > radius) continue;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const gridX = centerX + i;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const gridY = centerY + j;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.isValidCell(gridX, gridY)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const cell = this.pathGrid[gridX][gridY];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const oldWear = cell.wear;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let effectiveWear = wearAmount;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (useFalloff) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const falloff = 1 - (distance / radius);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  effectiveWear *= falloff;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  cell.wear = Math.min(Config.MAX_WEAR, cell.wear + effectiveWear);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (Math.floor(cell.wear) > Math.floor(oldWear)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.drawPathCell(gridX, gridY);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.trySpawnEntity(gridX, gridY, cell);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (cell.wear > Config.GRASS_REMOVAL_THRESHOLD && oldWear <= Config.GRASS_REMOVAL_THRESHOLD) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.updateGrassInCell(gridX, gridY);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // --- RENDERING & SPAWNING (Unchanged) ---
Â  Â  Â  Â  Â  Â  drawPathCell(gridX, gridY) {
Â  Â  Â  Â  Â  Â  Â  Â  const cell = this.pathGrid[gridX][gridY];
Â  Â  Â  Â  Â  Â  Â  Â  const wearRatio = cell.wear / Config.MAX_WEAR;
Â  Â  Â  Â  Â  Â  Â  Â  let baseColor, targetColor;
Â  Â  Â  Â  Â  Â  Â  Â  let baseOpacity = 0;

Â  Â  Â  Â  Â  Â  Â  Â  switch (cell.terrainType) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  case TerrainType.ALIEN_BLUE:
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  baseColor = Config.COLOR_ALIEN_BLUE;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  targetColor = Config.COLOR_DIRT;Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  baseOpacity = cell.mistOpacity ?? 0;Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  case TerrainType.ALIEN_CLAY:
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  baseColor = Config.COLOR_DIRT;Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  targetColor = Config.COLOR_ALIEN_CLAY;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  baseOpacity = 0.2;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  case TerrainType.NORMAL:
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  default:
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  baseColor = Config.COLOR_FIELD;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  targetColor = Config.COLOR_DIRT;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  const pathColor = Utils.lerpColor(baseColor, targetColor, wearRatio);
Â  Â  Â  Â  Â  Â  Â  Â  const pathOpacity = Math.max(wearRatio * 0.8, baseOpacity);

Â  Â  Â  Â  Â  Â  Â  Â  this.pathCtx.fillStyle = pathColor;
Â  Â  Â  Â  Â  Â  Â  Â  this.pathCtx.globalAlpha = pathOpacity;
Â  Â  Â  Â  Â  Â  Â  Â  this.pathCtx.clearRect(gridX * Config.GRID_CELL_SIZE, gridY * Config.GRID_CELL_SIZE, Config.GRID_CELL_SIZE, Config.GRID_CELL_SIZE);
Â  Â  Â  Â  Â  Â  Â  Â  this.pathCtx.fillRect(gridX * Config.GRID_CELL_SIZE, gridY * Config.GRID_CELL_SIZE, Config.GRID_CELL_SIZE, Config.GRID_CELL_SIZE);
Â  Â  Â  Â  Â  Â  Â  Â  this.pathCtx.globalAlpha = 1.0;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  trySpawnEntity(gridX, gridY, cell) {
Â  Â  Â  Â  Â  Â  Â  Â  if (cell.hasPebble) return;

Â  Â  Â  Â  Â  Â  Â  Â  if (cell.terrainType === TerrainType.ALIEN_CLAY && Math.random() < 0.005) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const x = gridX * Config.GRID_CELL_SIZE + Utils.randomRange(2, Config.GRID_CELL_SIZE - 2);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const y = gridY * Config.GRID_CELL_SIZE + Utils.randomRange(2, Config.GRID_CELL_SIZE - 2);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.entityManager.addEntity('diamond', x, y);
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  if (cell.wear > Config.PEBBLE_SPAWN_THRESHOLD) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let spawnChance = 0.01;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let pebbleType = 'normal';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (cell.terrainType === TerrainType.ALIEN_BLUE) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  spawnChance = 0.03;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  pebbleType = 'spaceRock';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else if (cell.terrainType === TerrainType.ALIEN_CLAY) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  spawnChance = 0.008;Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (Math.random() < spawnChance) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.spawnPebble(gridX, gridY, pebbleType);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  cell.hasPebble = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  spawnPebble(gridX, gridY, type) {
Â  Â  Â  Â  Â  Â  Â  Â  let colors, chars;

Â  Â  Â  Â  Â  Â  Â  Â  if (type === 'spaceRock') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  colors = ['#4B0082', '#6A0DAD', '#551A8B'];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  chars = ['*', 'o', 'O', '.:', '.:.'];
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  colors = ['#000000', '#1C1C1C', '#2A1A10', '#3D2B1F'];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  chars = ['..', '.-.', ".;'", '-_,`', ':'];
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  const pebble = {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  x: gridX * Config.GRID_CELL_SIZE + Math.random() * Config.GRID_CELL_SIZE,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  y: gridY * Config.GRID_CELL_SIZE + Math.random() * Config.GRID_CELL_SIZE,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  char: Utils.randomChoice(chars),
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  color: Utils.randomChoice(colors),
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  type: type
Â  Â  Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  Â  Â  this.entityManager.addPebble(pebble);
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  spawnMushroom(gridX, gridY) {
Â  Â  Â  Â  Â  Â  Â  Â  const mushroom = {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  x: gridX * Config.GRID_CELL_SIZE + (Config.GRID_CELL_SIZE / 2),
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  y: gridY * Config.GRID_CELL_SIZE + (Config.GRID_CELL_SIZE / 2),
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  gridX, gridY
Â  Â  Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  Â  Â  return this.entityManager.addMushroom(mushroom);
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // --- UFO/ALIEN TERRAFORMING (Unchanged) ---
Â  Â  Â  Â  Â  Â  alterGround(x, y) {
Â  Â  Â  Â  Â  Â  Â  Â  const centerX = Math.floor(x / Config.GRID_CELL_SIZE);
Â  Â  Â  Â  Â  Â  Â  Â  const centerY = Math.floor(y / Config.GRID_CELL_SIZE);
Â  Â  Â  Â  Â  Â  Â  Â  const alterRadius = 3;

Â  Â  Â  Â  Â  Â  Â  Â  for(let i = -alterRadius; i <= alterRadius; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  for (let j = -alterRadius; j <= alterRadius; j++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const distSq = i*i + j*j;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (distSq > alterRadius * alterRadius) continue;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const gridX = centerX + i;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const gridY = centerY + j;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.isValidCell(gridX, gridY)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const cell = this.pathGrid[gridX][gridY];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const isGrass = cell.wear < Config.GRASS_REMOVAL_THRESHOLD;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const targetType = isGrass ? TerrainType.ALIEN_BLUE : TerrainType.ALIEN_CLAY;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (targetType === TerrainType.ALIEN_BLUE) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const distance = Math.sqrt(distSq);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const falloff = 1 - (distance / alterRadius);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const newOpacity = Utils.clamp(falloff * Utils.randomRange(0.2, 0.5), 0.1, 0.5);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  cell.mistOpacity = Math.max(cell.mistOpacity, newOpacity);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (cell.terrainType !== targetType) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  cell.terrainType = targetType;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.drawPathCell(gridX, gridY);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Spawn Mushrooms (using configured reduced chance)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if(targetType === TerrainType.ALIEN_BLUE && Math.random() < Config.UFO_MUSHROOM_CHANCE) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.spawnMushroom(gridX, gridY);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  // ====================================================================
Â  Â  Â  Â  // 3. WANDERDOT (The Circle, Mood, and Behavior)
Â  Â  Â  Â  // ====================================================================

Â  Â  Â  Â  class WanderDot {
Â  Â  Â  Â  Â  Â  constructor(x, y) {
Â  Â  Â  Â  Â  Â  Â  Â  this.x = x;
Â  Â  Â  Â  Â  Â  Â  Â  this.y = y;
Â  Â  Â  Â  Â  Â  Â  Â  this.previousX = x;
Â  Â  Â  Â  Â  Â  Â  Â  this.previousY = y;
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  this.radius = Config.BASE_RADIUS;
Â  Â  Â  Â  Â  Â  Â  Â  this.color = Utils.lerpColor(Config.COLOR_NORMAL, Config.COLOR_NORMAL, 0);

Â  Â  Â  Â  Â  Â  Â  Â  this.speed = Config.BASE_SPEED;
Â  Â  Â  Â  Â  Â  Â  Â  this.currentSpeedMultiplier = 1.0;

Â  Â  Â  Â  Â  Â  Â  Â  this.dx = (Math.random() - 0.5) * 2;
Â  Â  Â  Â  Â  Â  Â  Â  this.dy = (Math.random() - 0.5) * 2;
Â  Â  Â  Â  Â  Â  Â  Â  this.targetX = null;
Â  Â  Â  Â  Â  Â  Â  Â  this.targetY = null;

Â  Â  Â  Â  Â  Â  Â  Â  // Mood state
Â  Â  Â  Â  Â  Â  Â  Â  this.annoyance = 0;
Â  Â  Â  Â  Â  Â  Â  Â  this.currentMoodState = 'normal';
Â  Â  Â  Â  Â  Â  Â  Â  this.isCalm = false;
Â  Â  Â  Â  Â  Â  Â  Â  this.isHangry = false;
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  // Behavior state
Â  Â  Â  Â  Â  Â  Â  Â  this.isEating = false;
Â  Â  Â  Â  Â  Â  Â  Â  this.eatingStartTime = 0;
Â  Â  Â  Â  Â  Â  Â  Â  this.eatingTarget = null;

Â  Â  Â  Â  Â  Â  Â  Â  // Bounce state
Â  Â  Â  Â  Â  Â  Â  Â  this.distanceTraveledOnCurrentBounce = 0;
Â  Â  Â  Â  Â  Â  Â  Â  this.jiggleEndTime = 0;
Â  Â  Â  Â  Â  Â  Â  Â  this.verticalOffset = 0;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  loadState(saveData) {
Â  Â  Â  Â  Â  Â  Â  Â  this.annoyance = saveData.annoyance ?? 0;
Â  Â  Â  Â  Â  Â  Â  Â  this.isHangry = saveData.isHangry ?? false;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  saveState() {
Â  Â  Â  Â  Â  Â  Â  Â  return {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  annoyance: this.annoyance,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  x: this.x,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  y: this.y,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  isHangry: this.isHangry
Â  Â  Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  setTarget(x, y) {
Â  Â  Â  Â  Â  Â  Â  Â  if (this.isHangry) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return false;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  if (this.isEating) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.triggerHangry();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return false;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  this.targetX = x;
Â  Â  Â  Â  Â  Â  Â  Â  this.targetY = y;
Â  Â  Â  Â  Â  Â  Â  Â  return true;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  triggerHangry() {
Â  Â  Â  Â  Â  Â  Â  Â  this.isHangry = true;
Â  Â  Â  Â  Â  Â  Â  Â  this.annoyance = Math.max(this.annoyance, Config.MAD_THRESHOLD + 1);
Â  Â  Â  Â  Â  Â  Â  Â  // Reset eating state
Â  Â  Â  Â  Â  Â  Â  Â  this.isEating = false;

                // If eating was interrupted during consumption (eatingStartTime > 0), hide the temporary timer
                if (this.eatingStartTime > 0) {
                    Game.instance.buffManager.hideTemporaryTimer('eating');
                }

Â  Â  Â  Â  Â  Â  Â  Â  this.eatingTarget = null;
Â  Â  Â  Â  Â  Â  Â  Â  this.eatingStartTime = 0;
Â  Â  Â  Â  Â  Â  Â  Â  this.clearTarget();
Â  Â  Â  Â  Â  Â  Â  Â  // Show angry thought bubble immediately
Â  Â  Â  Â  Â  Â  Â  Â  Game.instance.uiManager.showThought(Utils.randomChoice(Config.Emojis.mad));
Â  Â  Â  Â  Â  Â  }


Â  Â  Â  Â  Â  Â  clearTarget() {
Â  Â  Â  Â  Â  Â  Â  Â  this.targetX = null;
Â  Â  Â  Â  Â  Â  Â  Â  this.targetY = null;
Â  Â  Â  Â  Â  Â  Â  Â  this.distanceTraveledOnCurrentBounce = 0;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  update(deltaTime, bounds, buffManager, worldManager, entityManager) {
Â  Â  Â  Â  Â  Â  Â  Â  this.updateMood(deltaTime, buffManager);
Â  Â  Â  Â  Â  Â  Â  Â  this.updatePosition(deltaTime, bounds, buffManager, worldManager, entityManager);
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // --- MOOD LOGIC (Unchanged) ---
Â  Â  Â  Â  Â  Â  getMoodState(annoyanceValue) {
Â  Â  Â  Â  Â  Â  Â  Â  if (annoyanceValue > Config.MAD_THRESHOLD) return 'mad';
Â  Â  Â  Â  Â  Â  Â  Â  if (annoyanceValue > Config.ANNOYANCE_THRESHOLD) return 'annoyed';
Â  Â  Â  Â  Â  Â  Â  Â  return 'normal';
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  addAnnoyance(amount, isDirectClick) {
Â  Â  Â  Â  Â  Â  Â  Â  let annoyanceToAdd = amount;

Â  Â  Â  Â  Â  Â  Â  Â  if (this.isCalm) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  annoyanceToAdd = 5;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.isCalm = false;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  if (isDirectClick) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  annoyanceToAdd *= 1.5;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  this.annoyance = Math.min(100, this.annoyance + annoyanceToAdd);
Â  Â  Â  Â  Â  Â  Â  Â  return this.getReactionEmoji(isDirectClick);
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  getReactionEmoji(isDirectClick) {
Â  Â  Â  Â  Â  Â  Â  Â  Â if (isDirectClick) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const levels = [20, 30, 45, 60, 75, 90];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let level = Config.Emojis.directClick.length - 1;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  for (let i = 0; i < levels.length; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.annoyance < levels[i]) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  level = i;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return Config.Emojis.directClick[level];
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.annoyance > Config.MAD_THRESHOLD) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return Utils.randomChoice(Config.Emojis.mad);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else if (this.annoyance > Config.ANNOYANCE_THRESHOLD) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return Utils.randomChoice(Config.Emojis.annoyed);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return Utils.randomChoice(Config.Emojis.commandReceived);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  updateMood(deltaTime, buffManager) {
Â  Â  Â  Â  Â  Â  Â  Â  // 1. Cooldown
Â  Â  Â  Â  Â  Â  Â  Â  if (this.annoyance > 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const cooldownPerSecond = (this.annoyance > Config.MAD_THRESHOLD) ? 1.8 : 3.0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.annoyance = Math.max(0, this.annoyance - (cooldownPerSecond * deltaTime));
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // 2. State Change Detection
Â  Â  Â  Â  Â  Â  Â  Â  const previousState = this.currentMoodState;
Â  Â  Â  Â  Â  Â  Â  Â  this.currentMoodState = this.getMoodState(this.annoyance);

Â  Â  Â  Â  Â  Â  Â  Â  let transitionEmoji = null;
Â  Â  Â  Â  Â  Â  Â  Â  if (this.currentMoodState !== previousState) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (previousState === 'mad' && this.currentMoodState === 'annoyed') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  transitionEmoji = Config.Emojis.cooldownToAnnoyed[0];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Exit Hangry state when cooling down to annoyed
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.isHangry) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.isHangry = false;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else if (previousState === 'annoyed' && this.currentMoodState === 'normal') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â this.isCalm = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â transitionEmoji = Config.Emojis.cooldownToNormal[0];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // 3. Appearance and Speed Update
Â  Â  Â  Â  Â  Â  Â  Â  this.updateAppearance(buffManager);

Â  Â  Â  Â  Â  Â  Â  Â  return transitionEmoji;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  updateAppearance(buffManager) {
Â  Â  Â  Â  Â  Â  Â  Â  const buffs = buffManager.getActiveBuffs();
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  let speed = Config.BASE_SPEED;
Â  Â  Â  Â  Â  Â  Â  Â  let radius = Config.BASE_RADIUS;

Â  Â  Â  Â  Â  Â  Â  Â  if (buffs.coffee) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  speed *= (1 + 0.3 * buffs.coffee.potency);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  // Pizza and Mushroom both increase size (0.3 factor each)
Â  Â  Â  Â  Â  Â  Â  Â  if (buffs.pizza) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  radius *= (1 + 0.3 * buffs.pizza.potency);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  if (buffs.mushroom) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  radius *= (1 + 0.3 * buffs.mushroom.potency);
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  this.speed = speed;
Â  Â  Â  Â  Â  Â  Â  Â  this.radius = radius;

Â  Â  Â  Â  Â  Â  Â  Â  Â if (this.annoyance > Config.MAD_THRESHOLD) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.color = Utils.lerpColor(Config.COLOR_MAD, Config.COLOR_MAD, 0);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.currentSpeedMultiplier = 0.3;
Â  Â  Â  Â  Â  Â  Â  Â  } else if (this.annoyance > Config.ANNOYANCE_THRESHOLD) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const t = (this.annoyance - Config.ANNOYANCE_THRESHOLD) / (Config.MAD_THRESHOLD - Config.ANNOYANCE_THRESHOLD);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.color = Utils.lerpColor(Config.COLOR_ANNOYED, Config.COLOR_MAD, t);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.currentSpeedMultiplier = Utils.lerp(0.5, 0.3, t);
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const t = this.annoyance / Config.ANNOYANCE_THRESHOLD;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.color = Utils.lerpColor(Config.COLOR_NORMAL, Config.COLOR_ANNOYED, t);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.currentSpeedMultiplier = Utils.lerp(1.0, 0.5, t);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // --- MOVEMENT & BEHAVIOR LOGIC (Unchanged) ---
Â  Â  Â  Â  Â  Â  updatePosition(deltaTime, bounds, buffManager, worldManager, entityManager) {
Â  Â  Â  Â  Â  Â  Â  Â  this.previousX = this.x;
Â  Â  Â  Â  Â  Â  Â  Â  this.previousY = this.y;

Â  Â  Â  Â  Â  Â  Â  Â  // 1. Determine behavior and direction
Â  Â  Â  Â  Â  Â  Â  Â  let movementAllowed = true;
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  // Check if eating target still exists
Â  Â  Â  Â  Â  Â  Â  Â  if (this.eatingTarget && !entityManager.mushrooms.includes(this.eatingTarget)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.eatingTarget = null;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.isEating = false;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.clearTarget();
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  if (this.isEating) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  movementAllowed = this.handleEatingBehavior(entityManager, buffManager);
Â  Â  Â  Â  Â  Â  Â  Â  }Â 
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  if (movementAllowed) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.targetX !== null) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.moveToTarget();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.wander(entityManager, buffManager);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.dx = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.dy = 0;
Â  Â  Â  Â  Â  Â  Â  Â  }


Â  Â  Â  Â  Â  Â  Â  Â  // 2. Calculate movement distance
Â  Â  Â  Â  Â  Â  Â  Â  const buffs = buffManager.getActiveBuffs();
Â  Â  Â  Â  Â  Â  Â  Â  let effectiveSpeed = this.speed * this.currentSpeedMultiplier;
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  if (buffs.kangaroo) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  effectiveSpeed = Config.BASE_SPEED * (buffs.kangaroo.isEureka ? 1.3 : 1.0);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  const distanceMoved = effectiveSpeed * deltaTime;

Â  Â  Â  Â  Â  Â  Â  Â  // 3. Apply movement
Â  Â  Â  Â  Â  Â  Â  Â  this.x += this.dx * distanceMoved;
Â  Â  Â  Â  Â  Â  Â  Â  this.y += this.dy * distanceMoved;

Â  Â  Â  Â  Â  Â  Â  Â  // 4. Handle World Interaction
Â  Â  Â  Â  Â  Â  Â  Â  if (buffs.kangaroo) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.handleBounce(distanceMoved, buffManager, worldManager);
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.verticalOffset = 0;Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (movementAllowed) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â worldManager.applyMovementWear(this.previousX, this.previousY, this.x, this.y, buffManager);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // 5. Boundary Collision
Â  Â  Â  Â  Â  Â  Â  Â  if (movementAllowed) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.handleBoundaries(bounds);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  handleEatingBehavior(entityManager, buffManager) {
Â  Â  Â  Â  Â  Â  Â  Â  const uiManager = Game.instance.uiManager;

Â  Â  Â  Â  Â  Â  Â  Â  // Stage 1: Moving towards the mushroom
Â  Â  Â  Â  Â  Â  Â  Â  if (this.targetX !== null) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (uiManager.getCurrentThought() !== Config.Emojis.EATING_SEEKING) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Show for a long duration, ensuring it stays up until consumption or interruption
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  uiManager.showThought(Config.Emojis.EATING_SEEKING, Config.EAT_DURATION + 60000);Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return true;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // Stage 2: Reached the mushroom, start chewing animation
Â  Â  Â  Â  Â  Â  Â  Â  if (this.eatingStartTime === 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.eatingStartTime = Date.now();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.eatingTarget) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  entityManager.removeMushroomByObject(this.eatingTarget);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  uiManager.showThought(Config.Emojis.EATING_CONSUMING, Config.EAT_DURATION);
                    // Show the eating timer UI
                    Game.instance.buffManager.showTemporaryTimer('eating', 'ğŸ„', Config.EAT_DURATION);
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // Stage 3: Check if chewing is done
Â  Â  Â  Â  Â  Â  Â  Â  if (Date.now() - this.eatingStartTime > Config.EAT_DURATION) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.isEating = false;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.eatingStartTime = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.eatingTarget = null;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Apply the buff (using the flat duration)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  buffManager.addBuffTime('mushroom', Config.MUSHROOM_BUFF_DURATION);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Show satisfied thought bubble
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  uiManager.showThought(Config.Emojis.EATING_SATISFIED, 2000);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return true;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  return false;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  moveToTarget() {
Â  Â  Â  Â  Â  Â  Â  Â  const targetX = this.targetX;
Â  Â  Â  Â  Â  Â  Â  Â  const targetY = this.targetY;
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  const vecX = targetX - this.x;
Â  Â  Â  Â  Â  Â  Â  Â  const vecY = targetY - this.y;
Â  Â  Â  Â  Â  Â  Â  Â  const distanceToTarget = Math.sqrt(vecX * vecX + vecY * vecY);

Â  Â  Â  Â  Â  Â  Â  Â  const stopDistance = this.isEating ? 5 : this.radius;

Â  Â  Â  Â  Â  Â  Â  Â  if (distanceToTarget < stopDistance) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.clearTarget();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (!this.isEating) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.dx = (Math.random() - 0.5) * 2;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.dy = (Math.random() - 0.5) * 2;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.dx = vecX / distanceToTarget;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.dy = vecY / distanceToTarget;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  wander(entityManager, buffManager) {
Â  Â  Â  Â  Â  Â  Â  Â  if (this.isEating || this.isHangry) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  if (!buffManager.getActiveBuffs().mushroom) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const nearbyMushroom = entityManager.getNearbyMushroom(this.x, this.y, Config.EAT_DETECTION_RADIUS);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (nearbyMushroom && Math.random() < Config.EAT_MUSHROOM_CHANCE) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.isEating = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.eatingTarget = nearbyMushroom;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.targetX = nearbyMushroom.x;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.targetY = nearbyMushroom.y;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return;Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  if (Math.random() < 0.015) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.dx = (Math.random() - 0.5) * 2;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.dy = (Math.random() - 0.5) * 2;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  handleBounce(distanceMoved, buffManager, worldManager) {
Â  Â  Â  Â  Â  Â  Â  Â  this.distanceTraveledOnCurrentBounce += distanceMoved;

Â  Â  Â  Â  Â  Â  Â  Â  let currentBounceHeight = Config.BOUNCE_HEIGHT;
Â  Â  Â  Â  Â  Â  Â  Â  if (this.currentMoodState === 'mad') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  currentBounceHeight /= 2;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  const bounceProgress = Math.min(Math.PI, (this.distanceTraveledOnCurrentBounce / Config.BOUNCE_DISTANCE) * Math.PI);
Â  Â  Â  Â  Â  Â  Â  Â  this.verticalOffset = Math.sin(bounceProgress) * currentBounceHeight;

Â  Â  Â  Â  Â  Â  Â  Â  if (this.distanceTraveledOnCurrentBounce >= Config.BOUNCE_DISTANCE) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.land(buffManager, worldManager);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  land(buffManager, worldManager) {
Â  Â  Â  Â  Â  Â  Â  Â  worldManager.applyLandingImpact(this.x, this.y, this.currentMoodState, buffManager);
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  this.jiggleEndTime = Date.now();
Â  Â  Â  Â  Â  Â  Â  Â  this.verticalOffset = 0;
Â  Â  Â  Â  Â  Â  Â  Â  this.distanceTraveledOnCurrentBounce = 0;

Â  Â  Â  Â  Â  Â  Â  Â  if (buffManager.isKangarooEnding()) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  buffManager.deactivateBuff('kangaroo', true);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  handleBoundaries(bounds) {
Â  Â  Â  Â  Â  Â  Â  Â  let hitBoundary = false;
Â  Â  Â  Â  Â  Â  Â  Â  if (this.x + this.radius > bounds.width || this.x - this.radius < 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.dx *= -1;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.x = Utils.clamp(this.x, this.radius, bounds.width - this.radius);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  hitBoundary = true;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  if (this.y + this.radius > bounds.height || this.y - this.radius < 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.dy *= -1;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.y = Utils.clamp(this.y, this.radius, bounds.height - this.radius);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  hitBoundary = true;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  if (hitBoundary && this.targetX !== null) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.clearTarget();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â // If boundary collision interrupted eating, cancel it without penalty
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.isEating) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.isEating = false;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.eatingTarget = null;
                        // Hide temporary timer if active
                        if (this.eatingStartTime > 0) {
                             Game.instance.buffManager.hideTemporaryTimer('eating');
                             this.eatingStartTime = 0;
                        }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const uiManager = Game.instance.uiManager;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (uiManager.getCurrentThought() === Config.Emojis.EATING_SEEKING || uiManager.getCurrentThought() === Config.Emojis.EATING_CONSUMING) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  uiManager.hideThought();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // --- RENDERING (Unchanged) ---
Â  Â  Â  Â  Â  Â  draw(ctx) {
Â  Â  Â  Â  Â  Â  Â  Â  let scaleFactor = 1;
Â  Â  Â  Â  Â  Â  Â  Â  const buffs = Game.instance.buffManager.getActiveBuffs();

Â  Â  Â  Â  Â  Â  Â  Â  if (buffs.kangaroo) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const bounceProgress = Math.min(Math.PI, (this.distanceTraveledOnCurrentBounce / Config.BOUNCE_DISTANCE) * Math.PI);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  scaleFactor = 1 - Math.sin(bounceProgress) * 0.2;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  const currentRadius = this.radius * scaleFactor;

Â  Â  Â  Â  Â  Â  Â  Â  // Draw Shadow
Â  Â  Â  Â  Â  Â  Â  Â  // Show shadow if moving or bouncing, hide only if stationary chewing (eatingStartTime > 0)
Â  Â  Â  Â  Â  Â  Â  Â  if (!(this.isEating && this.eatingStartTime > 0)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.beginPath();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.fillStyle = 'rgba(0, 0, 0, 0.35)';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const shadowY = this.y + this.radius;Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const shadowScale = 1 - (this.verticalOffset / (Config.BOUNCE_HEIGHT * 3));
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const shadowRadiusX = currentRadius * shadowScale;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const shadowRadiusY = (currentRadius / 3) * shadowScale;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.ellipse(this.x, shadowY, shadowRadiusX, shadowRadiusY, 0, 0, Math.PI * 2);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.fill();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.closePath();
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // Draw Circle
Â  Â  Â  Â  Â  Â  Â  Â  ctx.save();
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  let drawY = this.y - this.verticalOffset;
Â  Â  Â  Â  Â  Â  Â  Â  let eatingWiggle = 0;

Â  Â  Â  Â  Â  Â  Â  Â  // Eating Animation (Wiggle up and down)
Â  Â  Â  Â  Â  Â  Â  Â  if (this.isEating && this.eatingStartTime > 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const elapsed = Date.now() - this.eatingStartTime;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  eatingWiggle = Math.sin(elapsed / 100) * 5;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  drawY += eatingWiggle;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  ctx.translate(this.x, drawY);

Â  Â  Â  Â  Â  Â  Â  Â  // Landing Jiggle Effect
Â  Â  Â  Â  Â  Â  Â  Â  const jiggleDuration = 300;
Â  Â  Â  Â  Â  Â  Â  Â  const timeSinceJiggle = Date.now() - this.jiggleEndTime;
Â  Â  Â  Â  Â  Â  Â  Â  if (timeSinceJiggle < jiggleDuration) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const jiggleProgress = timeSinceJiggle / jiggleDuration;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let jiggleAmountMultiplier = (this.currentMoodState === 'mad') ? 0.4 : 0.2;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const jiggleAmount = Math.sin(jiggleProgress * Math.PI * 2) * (1 - jiggleProgress) * jiggleAmountMultiplier;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.scale(1 + jiggleAmount, 1 - jiggleAmount);
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // Draw Hangry Glow
Â  Â  Â  Â  Â  Â  Â  Â  if (this.isHangry) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.shadowBlur = 25;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.shadowColor = Config.COLOR_HANGRY_GLOW;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  ctx.beginPath();
Â  Â  Â  Â  Â  Â  Â  Â  ctx.arc(0, 0, currentRadius, 0, Math.PI * 2);
Â  Â  Â  Â  Â  Â  Â  Â  ctx.fillStyle = this.color;
Â  Â  Â  Â  Â  Â  Â  Â  ctx.fill();
Â  Â  Â  Â  Â  Â  Â  Â  ctx.closePath();
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  // Draw held item (Mushroom) during chewing phase
Â  Â  Â  Â  Â  Â  Â  Â  if (this.isEating && this.eatingStartTime > 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.shadowBlur = 0; // Don't glow the mushroom itself
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.font = `${this.radius * 0.8}px monospace`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.textAlign = 'center';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.textBaseline = 'middle';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Draw slightly offset downwards so the wiggle makes it visible
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.fillText('ğŸ„', 0, this.radius * 0.4);Â 
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  ctx.restore();
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  // ====================================================================
Â  Â  Â  Â  // 4. BUFF AND ITEM MANAGERS
Â  Â  Â  Â  // ====================================================================

Â  Â  Â  Â  class BuffManager {
Â  Â  Â  Â  Â  Â  constructor(entityManager) {
Â  Â  Â  Â  Â  Â  Â  Â  this.entityManager = entityManager;
Â  Â  Â  Â  Â  Â  Â  Â  this.buffs = {};
                this.temporaryTimers = {}; // Added for things like eating duration
Â  Â  Â  Â  Â  Â  Â  Â  this.initializeDefinitions();
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  initializeDefinitions() {
Â  Â  Â  Â  Â  Â  Â  Â  Object.entries(Config.Items).forEach(([name, data]) => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (data.type === 'buff') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.buffs[name] = {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  endTime: 0,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  blinkTimer: null,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  duration: data.duration || 0,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  isEureka: false,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  isEnding: false,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  emoji: data.emoji,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  indicator: null,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  hideTimer: data.hideTimer || false
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  }

            // Helper to create the DOM element for an indicator
Â  Â  Â  Â  Â  Â  createIndicatorElement(idSuffix, emoji, hideTimer) {
Â  Â  Â  Â  Â  Â  Â  Â  const container = document.getElementById('buff-container');
Â  Â  Â  Â  Â  Â  Â  Â  const indicator = document.createElement('div');
Â  Â  Â  Â  Â  Â  Â  Â  indicator.className = 'buff-indicator';
Â  Â  Â  Â  Â  Â  Â  Â  indicator.id = `buff-indicator-${idSuffix}`;
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  const timerHTML = hideTimer ? '' : '<div class="buff-timer"></div>';

Â  Â  Â  Â  Â  Â  Â  Â  indicator.innerHTML = `
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <span class="buff-icon">${emoji}</span>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ${timerHTML}
Â  Â  Â  Â  Â  Â  Â  Â  `;
                // Appending keeps the order consistent (new items appear on the left due to row-reverse)
Â  Â  Â  Â  Â  Â  Â  Â  container.appendChild(indicator);
Â  Â  Â  Â  Â  Â  Â  Â  return indicator;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  initializeUI() {
Â  Â  Â  Â  Â  Â  Â  Â  const sortedKeys = Object.keys(this.buffs).sort((a, b) => a.localeCompare(b));

Â  Â  Â  Â  Â  Â  Â  Â  sortedKeys.forEach(name => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const buff = this.buffs[name];
                    // Use the helper to create the persistent indicator
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const indicator = this.createIndicatorElement(name, buff.emoji, buff.hideTimer);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  buff.indicator = indicator;
Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  }

            // Methods for Temporary Timers (e.g., Eating)
Â  Â  Â  Â  Â  Â  showTemporaryTimer(name, emoji, duration) {
Â  Â  Â  Â  Â  Â  Â  Â  if (this.temporaryTimers[name]) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.hideTemporaryTimer(name);
Â  Â  Â  Â  Â  Â  Â  Â  }

                // Create a new indicator element specifically for this temporary instance
Â  Â  Â  Â  Â  Â  Â  Â  const indicator = this.createIndicatorElement(`temp-${name}`, emoji, false);
Â  Â  Â  Â  Â  Â  Â  Â  const endTime = Date.now() + duration;

Â  Â  Â  Â  Â  Â  Â  Â  this.temporaryTimers[name] = {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  indicator: indicator,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  endTime: endTime,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  hideTimer: false,
                    blinkTimer: null
Â  Â  Â  Â  Â  Â  Â  Â  };

Â  Â  Â  Â  Â  Â  Â  Â  indicator.style.display = 'flex';
Â  Â  Â  Â  Â  Â  Â  Â  this.setupBlinkTimer(this.temporaryTimers[name]);
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  hideTemporaryTimer(name) {
Â  Â  Â  Â  Â  Â  Â  Â  const timer = this.temporaryTimers[name];
Â  Â  Â  Â  Â  Â  Â  Â  if (!timer) return;

Â  Â  Â  Â  Â  Â  Â  Â  this.deactivateBuffLogic(timer, true); // Pass true for isTemporary
Â  Â  Â  Â  Â  Â  Â  Â  delete this.temporaryTimers[name];
Â  Â  Â  Â  Â  Â  }


Â  Â  Â  Â  Â  Â  loadState(saveData) {
Â  Â  Â  Â  Â  Â  Â  Â  const now = Date.now();
Â  Â  Â  Â  Â  Â  Â  Â  const loadedBuffs = saveData.buffs;
Â  Â  Â  Â  Â  Â  Â  Â  if (!loadedBuffs) return;

Â  Â  Â  Â  Â  Â  Â  Â  Object.entries(loadedBuffs).forEach(([name, data]) => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.buffs[name] && data.remainingTime > 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.buffs[name].endTime = now + data.remainingTime;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.buffs[name].isEureka = data.isEureka;
                        // Indicators are set up in initializeUI, but we call setupBuffIndicator/setupBlinkTimer here
                        // in case loadState happens after initializeUI (which it does in the current Game constructor).
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.setupBuffIndicator(this.buffs[name]);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.setupBlinkTimer(this.buffs[name]);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  saveState() {
Â  Â  Â  Â  Â  Â  Â  Â  const savedBuffs = {};
Â  Â  Â  Â  Â  Â  Â  Â  const now = Date.now();
Â  Â  Â  Â  Â  Â  Â  Â  Object.entries(this.buffs).forEach(([name, buff]) => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (buff.endTime > now) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  savedBuffs[name] = {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  remainingTime: buff.endTime - now,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  isEureka: buff.isEureka
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  Â  Â  return savedBuffs;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  update() {
Â  Â  Â  Â  Â  Â  Â  Â  const currentTime = Date.now();

                // Update temporary timers
Â  Â  Â  Â  Â  Â  Â  Â  Object.entries(this.temporaryTimers).forEach(([name, timer]) => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (timer.endTime > currentTime) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.updateTimerDisplay(timer, currentTime);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.hideTemporaryTimer(name);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  });

                // Update permanent buffs
Â  Â  Â  Â  Â  Â  Â  Â  Object.entries(this.buffs).forEach(([name, buff]) => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (buff.endTime > currentTime) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.updateTimerDisplay(buff, currentTime);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else if (buff.indicator && buff.indicator.style.display === 'flex' && !buff.isEnding) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.deactivateBuff(name);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  updateTimerDisplay(buffOrTimer, currentTime) {
Â  Â  Â  Â  Â  Â  Â  Â  if (buffOrTimer.hideTimer || !buffOrTimer.indicator) return;

Â  Â  Â  Â  Â  Â  Â  Â  const remainingSeconds = Math.ceil((buffOrTimer.endTime - currentTime) / 1000);
Â  Â  Â  Â  Â  Â  Â  Â  const minutes = Math.floor(remainingSeconds / 60);
Â  Â  Â  Â  Â  Â  Â  Â  const seconds = remainingSeconds % 60;
Â  Â  Â  Â  Â  Â  Â  Â  const timerText = `${minutes}:${seconds.toString().padStart(2, '0')}`;
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  const timerEl = buffOrTimer.indicator.querySelector('.buff-timer');
Â  Â  Â  Â  Â  Â  Â  Â  if (timerEl) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  timerEl.textContent = timerText;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  addBuffTime(name, duration) {
Â  Â  Â  Â  Â  Â  Â  Â  const buff = this.buffs[name];
Â  Â  Â  Â  Â  Â  Â  Â  if (!buff) return;

Â  Â  Â  Â  Â  Â  Â  Â  const baseTime = Math.max(Date.now(), buff.endTime);
Â  Â  Â  Â  Â  Â  Â  Â  buff.endTime = baseTime + duration;
Â  Â  Â  Â  Â  Â  Â  Â  buff.isEnding = false;

Â  Â  Â  Â  Â  Â  Â  Â  this.setupBuffIndicator(buff);
Â  Â  Â  Â  Â  Â  Â  Â  this.setupBlinkTimer(buff);
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  setupBuffIndicator(buff) {
                if (!buff.indicator) return;
Â  Â  Â  Â  Â  Â  Â  Â  buff.indicator.style.display = 'flex';
Â  Â  Â  Â  Â  Â  Â  Â  buff.indicator.classList.remove('blinking', 'blip-out');
Â  Â  Â  Â  Â  Â  Â  Â  if (buff.isEureka) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  buff.indicator.classList.add('eureka-state');
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

            // Generalized to work with Buffs or Temporary Timers
Â  Â  Â  Â  Â  Â  setupBlinkTimer(buffOrTimer) {
Â  Â  Â  Â  Â  Â  Â  Â  clearTimeout(buffOrTimer.blinkTimer);
Â  Â  Â  Â  Â  Â  Â  Â  const remainingTime = buffOrTimer.endTime - Date.now();
Â  Â  Â  Â  Â  Â  Â  Â  const BLINK_THRESHOLD = 3000;

Â  Â  Â  Â  Â  Â  Â  Â  if (remainingTime > BLINK_THRESHOLD) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  buffOrTimer.blinkTimer = setTimeout(() => {
                        // Check if indicator exists (might have been removed if temporary)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (buffOrTimer.endTime > Date.now() && buffOrTimer.indicator) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  buffOrTimer.indicator.classList.add('blinking');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }, remainingTime - BLINK_THRESHOLD);
Â  Â  Â  Â  Â  Â  Â  Â  } else if (remainingTime > 0 && buffOrTimer.indicator) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  buffOrTimer.indicator.classList.add('blinking');
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

            // Generalized deactivation logic
Â  Â  Â  Â  Â  Â  deactivateBuffLogic(buffOrTimer, isTemporary = false) {
Â  Â  Â  Â  Â  Â  Â  Â  buffOrTimer.endTime = 0;
Â  Â  Â  Â  Â  Â  Â  Â  clearTimeout(buffOrTimer.blinkTimer);

Â  Â  Â  Â  Â  Â  Â  Â  if (buffOrTimer.indicator) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  buffOrTimer.indicator.classList.add('blip-out');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  buffOrTimer.indicator.addEventListener('animationend', () => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (isTemporary) {
                            // Temporary timers are removed from the DOM
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  buffOrTimer.indicator.remove();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
                            // Permanent buffs are hidden and reset
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  buffOrTimer.indicator.style.display = 'none';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  buffOrTimer.indicator.className = 'buff-indicator';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }, { once: true });
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  deactivateBuff(name, force = false) {
Â  Â  Â  Â  Â  Â  Â  Â  const buff = this.buffs[name];
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  if ((buff.endTime === 0 && !buff.isEnding)) return;

Â  Â  Â  Â  Â  Â  Â  Â  if (name === 'kangaroo' && !force) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (Game.instance.wanderDot.verticalOffset > 0.1) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  buff.isEnding = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  buff.endTime = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  if (name === 'mushroom') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const dot = Game.instance.wanderDot;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.entityManager.addEntity('seed', dot.x, dot.y);
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  buff.isEureka = false;
Â  Â  Â  Â  Â  Â  Â  Â  buff.isEnding = false;
                this.deactivateBuffLogic(buff, false);
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  getActiveBuffs() {
Â  Â  Â  Â  Â  Â  Â  Â  const currentTime = Date.now();
Â  Â  Â  Â  Â  Â  Â  Â  const active = {};
Â  Â  Â  Â  Â  Â  Â  Â  Object.entries(this.buffs).forEach(([name, buff]) => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (buff.endTime > currentTime || buff.isEnding) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  active[name] = {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  isEureka: buff.isEureka,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  potency: buff.isEureka ? 2.0 : 1.0
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  Â  Â  return active;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  isKangarooEnding() {
Â  Â  Â  Â  Â  Â  Â  Â  return this.buffs.kangaroo?.isEnding;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  applyWatchExtension() {
Â  Â  Â  Â  Â  Â  Â  Â  Object.keys(this.buffs).forEach(name => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (name !== 'mushroom' && this.buffs[name].endTime > Date.now()) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.addBuffTime(name, Config.WATCH_TIME_EXTENSION);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  applyEureka() {
Â  Â  Â  Â  Â  Â  Â  Â  Object.entries(this.buffs).forEach(([name, buff]) => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (name !== 'mushroom' && buff.endTime > Date.now() && buff.indicator) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  buff.isEureka = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  buff.indicator.classList.add('eureka-state');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  class ItemManager {
Â  Â  Â  Â  Â  Â  // (Implementation remains unchanged)
Â  Â  Â  Â  Â  Â  constructor(buffManager) {
Â  Â  Â  Â  Â  Â  Â  Â  this.buffManager = buffManager;
Â  Â  Â  Â  Â  Â  Â  Â  this.items = {};
Â  Â  Â  Â  Â  Â  Â  Â  this.initializeDefinitions();
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  initializeDefinitions() {
Â  Â  Â  Â  Â  Â  Â  Â  Object.entries(Config.Items).forEach(([name, data]) => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (name !== 'mushroom') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.items[name] = {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  count: 0,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  button: null,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  emoji: data.emoji,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  type: data.type
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  initializeUI() {
Â  Â  Â  Â  Â  Â  Â  Â  const itemBar = document.getElementById('item-bar');
Â  Â  Â  Â  Â  Â  Â  Â  itemBar.addEventListener('click', (event) => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const button = event.target.closest('.item-button');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (button && button.dataset.itemName) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.useItem(button.dataset.itemName);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  });

Â  Â  Â  Â  Â  Â  Â  Â  Object.entries(this.items).forEach(([name, item]) => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const button = document.createElement('button');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  button.className = 'item-button';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  button.dataset.itemName = name;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  itemBar.appendChild(button);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  item.button = button;
Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  Â  Â  this.updateItemBar();
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  loadState(saveData) {
Â  Â  Â  Â  Â  Â  Â  Â  const loadedItems = saveData.items;
Â  Â  Â  Â  Â  Â  Â  Â  if (!loadedItems) return;

Â  Â  Â  Â  Â  Â  Â  Â  Object.entries(loadedItems).forEach(([name, count]) => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.items[name]) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.items[name].count = count;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  Â  Â  this.updateItemBar();
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  saveState() {
Â  Â  Â  Â  Â  Â  Â  Â  const savedItems = {};
Â  Â  Â  Â  Â  Â  Â  Â  Object.entries(this.items).forEach(([name, item]) => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  savedItems[name] = item.count;
Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  Â  Â  return savedItems;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  addItem(emoji) {
Â  Â  Â  Â  Â  Â  Â  Â  const itemName = Object.keys(this.items).find(name => this.items[name].emoji === emoji);
Â  Â  Â  Â  Â  Â  Â  Â  if (itemName) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.items[itemName].count++;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.updateItemBar();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return true;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  return false;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  useItem(name) {
Â  Â  Â  Â  Â  Â  Â  Â  const item = this.items[name];
Â  Â  Â  Â  Â  Â  Â  Â  if (item.count > 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  item.count--;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.updateItemBar();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.animateButton(item.button);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (item.type === 'buff') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.buffManager.addBuffTime(name, this.buffManager.buffs[name].duration);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else if (name === 'watch') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.buffManager.applyWatchExtension();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else if (name === 'lightbulb') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.buffManager.applyEureka();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  animateButton(button) {
Â  Â  Â  Â  Â  Â  Â  Â  button.classList.add('clicked');
Â  Â  Â  Â  Â  Â  Â  Â  button.addEventListener('animationend', () => button.classList.remove('clicked'), { once: true });
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  updateItemBar() {
Â  Â  Â  Â  Â  Â  Â  Â  const itemBar = document.getElementById('item-bar');
Â  Â  Â  Â  Â  Â  Â  Â  let totalItems = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Object.values(this.items).forEach(item => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (item.count > 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  item.button.classList.add('visible');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  item.button.textContent = `${item.emoji}x${item.count}`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  totalItems++;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  item.button.classList.remove('visible');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  });

Â  Â  Â  Â  Â  Â  Â  Â  itemBar.classList.toggle('visible', totalItems > 0);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  // ====================================================================
Â  Â  Â  Â  // 5. PARTICLE SYSTEM & UFO
Â  Â  Â  Â  // ====================================================================

Â  Â  Â  Â  // (Implementation remains unchanged)
Â  Â  Â  Â  class ParticleSystem {
Â  Â  Â  Â  Â  Â  constructor(ctx) {
Â  Â  Â  Â  Â  Â  Â  Â  this.ctx = ctx;
Â  Â  Â  Â  Â  Â  Â  Â  this.particles = [];
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  spawnLandingParticles(x, y) {
Â  Â  Â  Â  Â  Â  Â  Â  const count = 10;
Â  Â  Â  Â  Â  Â  Â  Â  for(let i=0; i < count; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const angle = Math.random() * Math.PI * 2;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const speed = Math.random() * 50 + 20;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.particles.push({
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  type: 'pebble', x: x, y: y,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  dx: Math.cos(angle) * speed, dy: Math.sin(angle) * speed,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  life: 1, maxLife: 1
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  spawnUFOMist(x, y) {
Â  Â  Â  Â  Â  Â  Â  Â  if (Math.random() < 0.5) return;Â 

Â  Â  Â  Â  Â  Â  Â  Â  this.particles.push({
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  type: 'mist',
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  x: x + (Math.random() - 0.5) * 80,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  y: y + (Math.random() - 0.5) * 40,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  dx: (Math.random() - 0.5) * 20,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  dy: (Math.random() - 0.5) * 10,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  life: 2, maxLife: 2
Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  updateAndDraw(deltaTime) {
Â  Â  Â  Â  Â  Â  Â  Â  for (let i = this.particles.length - 1; i >= 0; i--) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const p = this.particles[i];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  p.x += p.dx * deltaTime;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  p.y += p.dy * deltaTime;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  p.life -= deltaTime;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if(p.life <= 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.particles.splice(i, 1);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.drawParticle(p);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  drawParticle(p) {
Â  Â  Â  Â  Â  Â  Â  Â  const opacity = p.life / p.maxLife;
Â  Â  Â  Â  Â  Â  Â  Â  this.ctx.beginPath();
Â  Â  Â  Â  Â  Â  Â  Â  if(p.type === 'pebble') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.ctx.fillStyle = `rgba(30, 30, 30, ${0.5 * opacity})`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.ctx.arc(p.x, p.y, 2, 0, Math.PI * 2);
Â  Â  Â  Â  Â  Â  Â  Â  } else if (p.type === 'mist') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.ctx.fillStyle = `rgba(200, 220, 255, ${0.2 * opacity})`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.ctx.arc(p.x, p.y, 10, 0, Math.PI * 2);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  this.ctx.fill();
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  class UFO {
Â  Â  Â  Â  Â  Â  constructor(ctx, bounds) {
Â  Â  Â  Â  Â  Â  Â  Â  this.ctx = ctx;
Â  Â  Â  Â  Â  Â  Â  Â  this.bounds = bounds;
Â  Â  Â  Â  Â  Â  Â  Â  this.active = false;
Â  Â  Â  Â  Â  Â  Â  Â  this.x = 0;
Â  Â  Â  Â  Â  Â  Â  Â  this.y = 0;
Â  Â  Â  Â  Â  Â  Â  Â  this.speed = 300;
Â  Â  Â  Â  Â  Â  Â  Â  this.direction = 1;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  activate() {
Â  Â  Â  Â  Â  Â  Â  Â  if (this.active) return;
Â  Â  Â  Â  Â  Â  Â  Â  this.active = true;
Â  Â  Â  Â  Â  Â  Â  Â  this.y = Math.random() * (this.bounds.height * 0.6) + (this.bounds.height * 0.1);
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  if(Math.random() < 0.5) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.direction = 1;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.x = -50;
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.direction = -1;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.x = this.bounds.width + 50;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  update(deltaTime, particleManager, worldManager) {
Â  Â  Â  Â  Â  Â  Â  Â  if (!this.active) return;

Â  Â  Â  Â  Â  Â  Â  Â  this.x += this.speed * this.direction * deltaTime;
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  particleManager.spawnUFOMist(this.x, this.y);
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  if(Math.random() < 0.1) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  worldManager.alterGround(this.x + (Math.random() - 0.5) * 50, this.y + (Math.random() - 0.5) * 50);
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  if(this.x < -100 || this.x > this.bounds.width + 100) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.active = false;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  draw() {
Â  Â  Â  Â  Â  Â  Â  Â  if (!this.active) return;
Â  Â  Â  Â  Â  Â  Â  Â  this.ctx.font = '4rem monospace';
Â  Â  Â  Â  Â  Â  Â  Â  this.ctx.textAlign = 'center';
Â  Â  Â  Â  Â  Â  Â  Â  this.ctx.textBaseline = 'middle';
Â  Â  Â  Â  Â  Â  Â  Â  this.ctx.fillText('ğŸ›¸', this.x, this.y);
Â  Â  Â  Â  Â  Â  Â  Â  this.ctx.textAlign = 'start';
Â  Â  Â  Â  Â  Â  Â  Â  this.ctx.textBaseline = 'alphabetic';
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  // ====================================================================
Â  Â  Â  Â  // 6. UI MANAGER (Thoughts, Timers, Interaction)
Â  Â  Â  Â  // ====================================================================

Â  Â  Â  Â  class UIManager {
Â  Â  Â  Â  Â  Â  constructor(wanderDot) {
Â  Â  Â  Â  Â  Â  Â  Â  this.wanderDot = wanderDot;
Â  Â  Â  Â  Â  Â  Â  Â  this.thoughtBubble = document.getElementById('thought-bubble');
Â  Â  Â  Â  Â  Â  Â  Â  this.worldTimerElement = document.getElementById('world-timer');
Â  Â  Â  Â  Â  Â  Â  Â  this.timerContainer = document.getElementById('timer-container');
Â  Â  Â  Â  Â  Â  Â  Â  this.timerIcon = document.getElementById('timer-icon');
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  this.idleThoughtTimer = null;
Â  Â  Â  Â  Â  Â  Â  Â  this.madThoughtTimer = null;
Â  Â  Â  Â  Â  Â  Â  Â  this.thoughtTimeout = null;
Â  Â  Â  Â  Â  Â  Â  Â  this.fadeTimeout = null;
Â  Â  Â  Â  Â  Â  Â  Â  this.idleEmojiHistory = [];

Â  Â  Â  Â  Â  Â  Â  Â  this.bubbleAngle = -Math.PI / 2;
Â  Â  Â  Â  Â  Â  Â  Â  this.targetBubbleAngle = -Math.PI / 2;
Â  Â  Â  Â  Â  Â  Â  Â  this.riseStartTime = 0;
Â  Â  Â  Â  Â  Â  Â  Â  this.bounceEndTime = 0;
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  this.isMouseOverBubble = false;
Â  Â  Â  Â  Â  Â  Â  Â  this.thoughtTimeoutStartTime = 0;
Â  Â  Â  Â  Â  Â  Â  Â  this.thoughtTimeoutDuration = 0;
Â  Â  Â  Â  Â  Â  Â  Â  this.thoughtTimeoutRemaining = 0;
Â  Â  Â  Â  Â  Â  Â  Â  this.mousePos = { x: 0, y: 0 };

Â  Â  Â  Â  Â  Â  Â  Â  this.setupEventListeners();
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â setupEventListeners() {
Â  Â  Â  Â  Â  Â  Â  Â  window.addEventListener('mousemove', (event) => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.mousePos.x = event.clientX;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.mousePos.y = event.clientY;
Â  Â  Â  Â  Â  Â  Â  Â  });

Â  Â  Â  Â  Â  Â  Â  Â  this.thoughtBubble.addEventListener('click', (event) => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  event.stopPropagation();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.handleThoughtClick();
Â  Â  Â  Â  Â  Â  Â  Â  });

Â  Â  Â  Â  Â  Â  Â  Â  this.thoughtBubble.addEventListener('mouseenter', () => this.handleBubbleEnter());
Â  Â  Â  Â  Â  Â  Â  Â  this.thoughtBubble.addEventListener('mouseleave', () => this.handleBubbleLeave());

Â  Â  Â  Â  Â  Â  Â  Â  // Click listener for Timer toggle
Â  Â  Â  Â  Â  Â  Â  Â  // Using 'pointerdown' for responsiveness on both desktop and mobile
Â  Â  Â  Â  Â  Â  Â  Â  this.timerIcon.addEventListener('pointerdown', (event) => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  event.stopPropagation();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.toggleTimerPin();
Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  toggleTimerPin() {
Â  Â  Â  Â  Â  Â  Â  Â  this.timerContainer.classList.toggle('active');
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  getCurrentThought() {
Â  Â  Â  Â  Â  Â  Â  Â  if (this.thoughtBubble.style.display === 'block') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const span = this.thoughtBubble.querySelector('span');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return span ? span.textContent : null;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  return null;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  hideThought() {
Â  Â  Â  Â  Â  Â  Â  Â  if (!this.isMouseOverBubble) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.thoughtBubble.style.opacity = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.fadeTimeout = setTimeout(() => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.thoughtBubble.style.display = 'none';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }, 300);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â getNextIdleEmoji() {
Â  Â  Â  Â  Â  Â  Â  Â  const candidateEmojis = Config.Emojis.idle.filter(e => !this.idleEmojiHistory.includes(e));
Â  Â  Â  Â  Â  Â  Â  Â  const emojiPool = candidateEmojis.length > 0 ? candidateEmojis : Config.Emojis.idle;
Â  Â  Â  Â  Â  Â  Â  Â  const nextEmoji = Utils.randomChoice(emojiPool);

Â  Â  Â  Â  Â  Â  Â  Â  this.idleEmojiHistory.push(nextEmoji);
Â  Â  Â  Â  Â  Â  Â  Â  if (this.idleEmojiHistory.length > 3) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.idleEmojiHistory.shift();
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  return nextEmoji;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  startMadTimer() {
Â  Â  Â  Â  Â  Â  Â  Â  this.stopMadTimer();
Â  Â  Â  Â  Â  Â  Â  Â  this.madThoughtTimer = setInterval(() => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Don't show mad thoughts if Hangry (Hangry overrides standard mad behavior)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.wanderDot.currentMoodState === 'mad' && !this.wanderDot.isHangry) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.showThought(Utils.randomChoice(Config.Emojis.madZone));
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else if (this.wanderDot.currentMoodState !== 'mad') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.stopMadTimer();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }, 3000);
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  stopMadTimer() {
Â  Â  Â  Â  Â  Â  Â  Â  clearInterval(this.madThoughtTimer);
Â  Â  Â  Â  Â  Â  Â  Â  this.madThoughtTimer = null;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  handleThoughtClick() {
Â  Â  Â  Â  Â  Â  Â  Â  const emoji = this.getCurrentThought();
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  const collected = Game.instance.itemManager.addItem(emoji);
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  if (!collected) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (emoji === 'ğŸ‘½') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Game.instance.ufo.activate();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  clearTimeout(this.thoughtTimeout);
Â  Â  Â  Â  Â  Â  Â  Â  clearTimeout(this.fadeTimeout);
Â  Â  Â  Â  Â  Â  Â  Â  this.thoughtBubble.style.display = 'none';
Â  Â  Â  Â  Â  Â  Â  Â  this.isMouseOverBubble = false;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  handleBubbleEnter() {
Â  Â  Â  Â  Â  Â  Â  Â  this.isMouseOverBubble = true;
Â  Â  Â  Â  Â  Â  Â  Â  this.thoughtTimeoutRemaining = this.thoughtTimeoutDuration - (Date.now() - this.thoughtTimeoutStartTime);
Â  Â  Â  Â  Â  Â  Â  Â  clearTimeout(this.thoughtTimeout);
Â  Â  Â  Â  Â  Â  Â  Â  clearTimeout(this.fadeTimeout);
Â  Â  Â  Â  Â  Â  Â  Â  this.thoughtBubble.style.opacity = 1;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  handleBubbleLeave() {
Â  Â  Â  Â  Â  Â  Â  Â  this.isMouseOverBubble = false;
Â  Â  Â  Â  Â  Â  Â  Â  this.thoughtTimeout = setTimeout(() => this.hideThought(), Math.max(500, this.thoughtTimeoutRemaining));
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  update(worldCreationTime) {
Â  Â  Â  Â  Â  Â  Â  Â  this.updateTimer(worldCreationTime);
Â  Â  Â  Â  Â  Â  Â  Â  if (this.thoughtBubble.style.display === 'block') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.updateBubblePosition();
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  updateTimer(worldCreationTime) {
Â  Â  Â  Â  Â  Â  Â  Â  const elapsedTime = Date.now() - worldCreationTime;
Â  Â  Â  Â  Â  Â  Â  Â  const elapsedSeconds = Math.floor(elapsedTime / 1000);
Â  Â  Â  Â  Â  Â  Â  Â  const minutes = Math.floor(elapsedSeconds / 60);
Â  Â  Â  Â  Â  Â  Â  Â  const seconds = elapsedSeconds % 60;
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  let timerText = `Your WanderDot's world has existed for `;
Â  Â  Â  Â  Â  Â  Â  Â  if (minutes > 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  timerText += `${minutes} minute${minutes !== 1 ? 's' : ''} and `;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  timerText += `${seconds} second${seconds !== 1 ? 's' : ''}.`;
Â  Â  Â  Â  Â  Â  Â  Â  this.worldTimerElement.textContent = timerText;
Â  Â  Â  Â  Â  Â  }


Â  Â  Â  Â  Â  Â  showThought(emoji, duration = 2000) {
Â  Â  Â  Â  Â  Â  Â  Â  if (!emoji) return;

Â  Â  Â  Â  Â  Â  Â  Â  clearTimeout(this.thoughtTimeout);
Â  Â  Â  Â  Â  Â  Â  Â  clearTimeout(this.fadeTimeout);

Â  Â  Â  Â  Â  Â  Â  Â  this.prepareBubbleAnimation();

Â  Â  Â  Â  Â  Â  Â  Â  this.thoughtBubble.innerHTML = `<span>${emoji}</span>`;
Â  Â  Â  Â  Â  Â  Â  Â  this.thoughtBubble.style.opacity = 1;
Â  Â  Â  Â  Â  Â  Â  Â  this.thoughtBubble.style.display = 'block';

Â  Â  Â  Â  Â  Â  Â  Â  this.thoughtTimeoutStartTime = Date.now();
Â  Â  Â  Â  Â  Â  Â  Â  this.thoughtTimeoutDuration = duration;
Â  Â  Â  Â  Â  Â  Â  Â  this.thoughtTimeout = setTimeout(() => this.hideThought(), duration);
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  prepareBubbleAnimation() {
Â  Â  Â  Â  Â  Â  Â  Â  if (this.thoughtBubble.style.display === 'block') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.bounceEndTime = Date.now() + 300;
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const initialOrbitRadius = this.wanderDot.radius;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const initialX = this.wanderDot.x + Math.cos(this.bubbleAngle) * initialOrbitRadius;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const initialY = this.wanderDot.y + Math.sin(this.bubbleAngle) * initialOrbitRadius;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.thoughtBubble.style.left = `${initialX}px`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.thoughtBubble.style.top = `${initialY}px`;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  this.thoughtBubble.classList.remove('is-rising');
Â  Â  Â  Â  Â  Â  Â  Â  void this.thoughtBubble.offsetWidth;Â 
Â  Â  Â  Â  Â  Â  Â  Â  this.thoughtBubble.classList.add('is-rising');
Â  Â  Â  Â  Â  Â  Â  Â  this.riseStartTime = Date.now();
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // --- IDLE THOUGHT SCHEDULING (Unchanged) ---
Â  Â  Â  Â  Â  Â  scheduleNextIdleThought(delay = 7000) {
Â  Â  Â  Â  Â  Â  Â  Â  const IDLE_THOUGHT_DURATION = 4000;
Â  Â  Â  Â  Â  Â  Â  Â  const BREAK_DURATION = 7000;
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  clearTimeout(this.idleThoughtTimer);
Â  Â  Â  Â  Â  Â  Â  Â  this.idleThoughtTimer = setTimeout(() => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Only show if idle (no target AND not eating) AND not annoyed AND not Hangry
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.wanderDot.targetX === null &&Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  !this.wanderDot.isEating &&Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  !this.wanderDot.isHangry &&
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.wanderDot.annoyance < Config.WARNING_ANNOYANCE_THRESHOLD) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const nextEmoji = this.getNextIdleEmoji();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.showThought(nextEmoji, IDLE_THOUGHT_DURATION);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.scheduleNextIdleThought(IDLE_THOUGHT_DURATION + 300 + BREAK_DURATION);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // If busy, eating, or annoyed/hangry, check again later
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.scheduleNextIdleThought(BREAK_DURATION);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }, delay);
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // (updateBubblePosition, findBestBubbleAngle, calculateBubbleAnimations remain unchanged)
Â  Â  Â  Â  Â  Â  updateBubblePosition() {
Â  Â  Â  Â  Â  Â  Â  Â  const bubbleWidth = this.thoughtBubble.offsetWidth;
Â  Â  Â  Â  Â  Â  Â  Â  const bubbleHeight = this.thoughtBubble.offsetHeight;
Â  Â  Â  Â  Â  Â  Â  Â  const finalOrbitRadius = this.wanderDot.radius + bubbleHeight / 2 + 5;

Â  Â  Â  Â  Â  Â  Â  Â  this.targetBubbleAngle = this.findBestBubbleAngle(finalOrbitRadius, bubbleWidth, bubbleHeight);
Â  Â  Â  Â  Â  Â  Â  Â  this.bubbleAngle = Utils.lerp(this.bubbleAngle, this.targetBubbleAngle, 0.1);

Â  Â  Â  Â  Â  Â  Â  Â  const { radius, verticalBob } = this.calculateBubbleAnimations(finalOrbitRadius);

Â  Â  Â  Â  Â  Â  Â  Â  let bubbleTargetX = this.wanderDot.x + Math.cos(this.bubbleAngle) * radius;
Â  Â  Â  Â  Â  Â  Â  Â  let bubbleTargetY = this.wanderDot.y - this.wanderDot.verticalOffset + Math.sin(this.bubbleAngle) * radius + verticalBob;

Â  Â  Â  Â  Â  Â  Â  Â  if(this.isMouseOverBubble) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const currentX = parseFloat(this.thoughtBubble.style.left) || bubbleTargetX;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const currentY = parseFloat(this.thoughtBubble.style.top) || bubbleTargetY;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  bubbleTargetX = Utils.lerp(currentX, this.mousePos.x, 0.2);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  bubbleTargetY = Utils.lerp(currentY, this.mousePos.y, 0.2);
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  this.thoughtBubble.style.left = `${bubbleTargetX}px`;
Â  Â  Â  Â  Â  Â  Â  Â  this.thoughtBubble.style.top = `${bubbleTargetY}px`;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  findBestBubbleAngle(radius, width, height) {
Â  Â  Â  Â  Â  Â  Â  Â  const SAFE_MARGIN = 10;
Â  Â  Â  Â  Â  Â  Â  Â  const bounds = { width: window.innerWidth, height: window.innerHeight };
Â  Â  Â  Â  Â  Â  Â  Â  const startAngle = -Math.PI / 2;

Â  Â  Â  Â  Â  Â  Â  Â  for (let offset = 0; offset < Math.PI; offset += 0.1) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  for (const sign of [1, -1]) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const angle = startAngle + offset * sign;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const testX = this.wanderDot.x + Math.cos(angle) * radius;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const testY = this.wanderDot.y + Math.sin(angle) * radius;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (testX - width / 2 > SAFE_MARGIN && testX + width / 2 < bounds.width - SAFE_MARGIN &&
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  testY - height / 2 > SAFE_MARGIN && testY + height / 2 < bounds.height - SAFE_MARGIN) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return angle;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  return this.targetBubbleAngle;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  calculateBubbleAnimations(finalOrbitRadius) {
Â  Â  Â  Â  Â  Â  Â  Â  let radius = finalOrbitRadius;
Â  Â  Â  Â  Â  Â  Â  Â  let verticalBob = 0;
Â  Â  Â  Â  Â  Â  Â  Â  const animTime = Date.now();

Â  Â  Â  Â  Â  Â  Â  Â  if (this.riseStartTime > 0 && animTime - this.riseStartTime < 400) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const riseProgress = (animTime - this.riseStartTime) / 400;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  radius = Utils.lerp(this.wanderDot.radius, finalOrbitRadius, riseProgress);
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.riseStartTime = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.bounceEndTime > 0 && animTime < this.bounceEndTime) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const bounceProgress = (animTime - (this.bounceEndTime - 300)) / 300;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  verticalBob = Math.sin(bounceProgress * Math.PI) * -15;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.bounceEndTime = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  verticalBob = Math.sin(animTime / 400) * -3;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  return { radius, verticalBob };
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  // ====================================================================
Â  Â  Â  Â  // 7. GAME (Main Loop, Initialization, Persistence)
Â  Â  Â  Â  // ====================================================================

Â  Â  Â  Â  class Game {
Â  Â  Â  Â  Â  Â  static instance = null;

Â  Â  Â  Â  Â  Â  constructor() {
Â  Â  Â  Â  Â  Â  Â  Â  if (Game.instance) return Game.instance;
Â  Â  Â  Â  Â  Â  Â  Â  Game.instance = this;

Â  Â  Â  Â  Â  Â  Â  Â  this.initializeCanvases();
Â  Â  Â  Â  Â  Â  Â  Â  this.bounds = { width: window.innerWidth, height: window.innerHeight };

Â  Â  Â  Â  Â  Â  Â  Â  this.worldCreationTime = Date.now();
Â  Â  Â  Â  Â  Â  Â  Â  this.lastFrameTime = 0;
Â  Â  Â  Â  Â  Â  Â  Â  this.lastClickTime = 0;
Â  Â  Â  Â  Â  Â  Â  Â  this.lastSaveTime = 0;

Â  Â  Â  Â  Â  Â  Â  Â  this.initializeGameObjects();
Â  Â  Â  Â  Â  Â  Â  Â  this.loadGame();
Â  Â  Â  Â  Â  Â  Â  Â  this.finalizeInitialization();
Â  Â  Â  Â  Â  Â  Â  Â  this.setupEventListeners();
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  initializeCanvases() {
Â  Â  Â  Â  Â  Â  Â  Â  this.mainCanvas = document.getElementById('mainCanvas');
Â  Â  Â  Â  Â  Â  Â  Â  this.ctx = this.mainCanvas.getContext('2d');
Â  Â  Â  Â  Â  Â  Â  Â  this.pathCanvas = document.getElementById('pathCanvas');
Â  Â  Â  Â  Â  Â  Â  Â  this.pathCtx = this.pathCanvas.getContext('2d');
Â  Â  Â  Â  Â  Â  Â  Â  this.entityCanvas = document.getElementById('entityCanvas');
Â  Â  Â  Â  Â  Â  Â  Â  this.entityCtx = this.entityCanvas.getContext('2d');
Â  Â  Â  Â  Â  Â  Â  Â  this.resizeCanvases();
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  resizeCanvases() {
Â  Â  Â  Â  Â  Â  Â  Â  this.mainCanvas.width = this.pathCanvas.width = this.entityCanvas.width = window.innerWidth;
Â  Â  Â  Â  Â  Â  Â  Â  this.mainCanvas.height = this.pathCanvas.height = this.entityCanvas.height = window.innerHeight;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  initializeGameObjects() {
Â  Â  Â  Â  Â  Â  Â  Â  this.entityManager = new EntityManager(this.entityCtx);
Â  Â  Â  Â  Â  Â  Â  Â  this.worldManager = new WorldManager(this.bounds.width, this.bounds.height, this.pathCtx, this.entityManager);
Â  Â  Â  Â  Â  Â  Â  Â  this.wanderDot = new WanderDot(this.bounds.width / 2, this.bounds.height / 2);
Â  Â  Â  Â  Â  Â  Â  Â  this.uiManager = new UIManager(this.wanderDot);
Â  Â  Â  Â  Â  Â  Â  Â  this.buffManager = new BuffManager(this.entityManager);
Â  Â  Â  Â  Â  Â  Â  Â  this.itemManager = new ItemManager(this.buffManager);
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  this.particleManager = new ParticleSystem(this.ctx);
Â  Â  Â  Â  Â  Â  Â  Â  this.ufo = new UFO(this.ctx, this.bounds);
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  finalizeInitialization() {
Â  Â  Â  Â  Â  Â  Â  Â  this.buffManager.initializeUI();
Â  Â  Â  Â  Â  Â  Â  Â  this.itemManager.initializeUI();
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  this.worldManager.generateGrassField();
Â  Â  Â  Â  Â  Â  Â  Â  this.worldManager.redrawWorld();

Â  Â  Â  Â  Â  Â  Â  Â  this.wanderDot.x = Utils.clamp(this.wanderDot.x, Config.BASE_RADIUS, this.bounds.width - Config.BASE_RADIUS);
Â  Â  Â  Â  Â  Â  Â  Â  this.wanderDot.y = Utils.clamp(this.wanderDot.y, Config.BASE_RADIUS, this.bounds.height - Config.BASE_RADIUS);
Â  Â  Â  Â  Â  Â  Â  Â  this.wanderDot.previousX = this.wanderDot.x;
Â  Â  Â  Â  Â  Â  Â  Â  this.wanderDot.previousY = this.wanderDot.y;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // --- PERSISTENCE (Unchanged) ---
Â  Â  Â  Â  Â  Â  saveGame() {
Â  Â  Â  Â  Â  Â  Â  Â  // Prevent saving during the transient eating state (chewing phase)
Â  Â  Â  Â  Â  Â  Â  Â  if (this.wanderDot.isEating && this.wanderDot.eatingStartTime > 0) return;

Â  Â  Â  Â  Â  Â  Â  Â  const saveData = {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  version: 6,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  worldCreationTime: this.worldCreationTime,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  world: this.worldManager.saveState(),
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  entities: this.entityManager.saveState(),
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  wanderDot: this.wanderDot.saveState(),
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  items: this.itemManager.saveState(),
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  buffs: this.buffManager.saveState(),
Â  Â  Â  Â  Â  Â  Â  Â  };

Â  Â  Â  Â  Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  localStorage.setItem(Config.SAVE_KEY, JSON.stringify(saveData));
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.lastSaveTime = Date.now();
Â  Â  Â  Â  Â  Â  Â  Â  } catch (e) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  console.error("Error saving game (localStorage might be full):", e);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  loadGame() {
Â  Â  Â  Â  Â  Â  Â  Â  const saveDataRaw = localStorage.getItem(Config.SAVE_KEY);
Â  Â  Â  Â  Â  Â  Â  Â  if (!saveDataRaw) return;

Â  Â  Â  Â  Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const saveData = JSON.parse(saveDataRaw);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.worldCreationTime = saveData.worldCreationTime ?? Date.now();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (saveData.world) this.worldManager.loadState(saveData.world);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Handle legacy loading structures if necessary
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (saveData.entities) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.entityManager.loadState(saveData.entities);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else if (saveData.world && saveData.version < 3) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â this.entityManager.loadState({
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  pebbles: saveData.world.pebbles,Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  mushrooms: saveData.world.mushrooms,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  dynamicEntities: saveData.world.dynamicObjects
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.wanderDot.loadState(saveData.wanderDot);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (saveData.wanderDot.x && saveData.wanderDot.y) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.wanderDot.x = saveData.wanderDot.x;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.wanderDot.y = saveData.wanderDot.y;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.itemManager.loadState(saveData);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.buffManager.loadState(saveData);

Â  Â  Â  Â  Â  Â  Â  Â  } catch (e) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  console.error("Error loading game (data might be corrupted):", e);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // --- EVENTS ---
Â  Â  Â  Â  Â  Â  setupEventListeners() {
Â  Â  Â  Â  Â  Â  Â  Â  window.addEventListener('resize', () => this.handleResize());
Â  Â  Â  Â  Â  Â  Â  Â  // Use pointerdown for better responsiveness on all devices
Â  Â  Â  Â  Â  Â  Â  Â  this.mainCanvas.addEventListener('pointerdown', (event) => this.handleClick(event));
Â  Â  Â  Â  Â  Â  Â  Â  window.addEventListener('beforeunload', () => this.saveGame());
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  handleResize() {
Â  Â  Â  Â  Â  Â  Â  Â  // Update bounds and canvases immediately based on new window size
Â  Â  Â  Â  Â  Â  Â  Â  this.bounds.width = window.innerWidth;
Â  Â  Â  Â  Â  Â  Â  Â  this.bounds.height = window.innerHeight;
Â  Â  Â  Â  Â  Â  Â  Â  this.resizeCanvases();
Â  Â  Â  Â  Â  Â  Â  Â  // Notify managers to adapt to the new size
Â  Â  Â  Â  Â  Â  Â  Â  this.worldManager.handleResize(this.bounds.width, this.bounds.height);
Â  Â  Â  Â  Â  Â  Â  Â  this.entityManager.needsRedraw = true;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  handleClick(event) {
Â  Â  Â  Â  Â  Â  Â  Â  // Prevent default browser behavior (like drag/select)
Â  Â  Â  Â  Â  Â  Â  Â  event.preventDefault();Â 

Â  Â  Â  Â  Â  Â  Â  Â  const clickX = event.clientX;
Â  Â  Â  Â  Â  Â  Â  Â  const clickY = event.clientY;

Â  Â  Â  Â  Â  Â  Â  Â  if (this.uiManager.thoughtBubble.style.display === 'block') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const bubbleRect = this.uiManager.thoughtBubble.getBoundingClientRect();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (clickX >= bubbleRect.left && clickX <= bubbleRect.right &&
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  clickY >= bubbleRect.top && clickY <= bubbleRect.bottom) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return;Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  const currentTime = Date.now();
Â  Â  Â  Â  Â  Â  Â  Â  const timeDiff = currentTime - this.lastClickTime;
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  const distanceToCenter = Utils.distance(clickX, clickY, this.wanderDot.x, this.wanderDot.y - this.wanderDot.verticalOffset);
Â  Â  Â  Â  Â  Â  Â  Â  const isDirectClick = distanceToCenter <= this.wanderDot.radius;

Â  Â  Â  Â  Â  Â  Â  Â  let commandAccepted = false;

Â  Â  Â  Â  Â  Â  Â  Â  // Try to issue command
Â  Â  Â  Â  Â  Â  Â  Â  if (!isDirectClick) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â // Attempt to set target. If it returns false, the command was ignored (Hangry or interrupted eating)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â commandAccepted = this.wanderDot.setTarget(clickX, clickY);
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Direct click always registers as interaction (unless Hangry)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  commandAccepted = !this.wanderDot.isHangry;Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (commandAccepted) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.wanderDot.clearTarget();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Cancel eating without penalty on direct click
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.wanderDot.isEating) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â this.wanderDot.isEating = false;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â this.wanderDot.eatingTarget = null;
                            // Hide temporary timer if active
                            if (this.wanderDot.eatingStartTime > 0) {
                                Game.instance.buffManager.hideTemporaryTimer('eating');
                                this.wanderDot.eatingStartTime = 0;
                            }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // Calculate and apply annoyance if an interaction occurred OR if the dot is Hangry (to reinforce the anger)
Â  Â  Â  Â  Â  Â  Â  Â  if (commandAccepted || this.wanderDot.isHangry) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const annoyanceToAdd = Math.min(35, 10 + (2500 / timeDiff));
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const reactionEmoji = this.wanderDot.addAnnoyance(annoyanceToAdd, isDirectClick);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Show reaction thought, unless the dot is currently chewing (to avoid overriding ğŸ¤¤)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (!(this.wanderDot.isEating && this.wanderDot.eatingStartTime > 0)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â this.uiManager.showThought(reactionEmoji);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  // Manage Mad Timer
Â  Â  Â  Â  Â  Â  Â  Â  const currentMood = this.wanderDot.currentMoodState;
Â  Â  Â  Â  Â  Â  Â  Â  if (currentMood === 'mad' && !this.uiManager.madThoughtTimer) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â this.uiManager.startMadTimer();
Â  Â  Â  Â  Â  Â  Â  Â  }Â 

Â  Â  Â  Â  Â  Â  Â  Â  this.lastClickTime = currentTime;
Â  Â  Â  Â  Â  Â  Â  Â  // Always reschedule idle thoughts after a click attempt
Â  Â  Â  Â  Â  Â  Â  Â  this.uiManager.scheduleNextIdleThought();
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // Main game loop (Unchanged)
Â  Â  Â  Â  Â  Â  animate(currentTime) {
Â  Â  Â  Â  Â  Â  Â  Â  requestAnimationFrame((time) => this.animate(time));

Â  Â  Â  Â  Â  Â  Â  Â  if (!this.lastFrameTime) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.lastFrameTime = currentTime;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  const deltaTime = (currentTime - this.lastFrameTime) / 1000;
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  // Handle large deltaTime spikes (e.g., tab inactive)
Â  Â  Â  Â  Â  Â  Â  Â  if (deltaTime > 0.1) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â this.lastFrameTime = currentTime;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â this.updateTimeBasedSystems();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â return;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  this.lastFrameTime = currentTime;

Â  Â  Â  Â  Â  Â  Â  Â  this.update(deltaTime);
Â  Â  Â  Â  Â  Â  Â  Â  this.draw(deltaTime);

Â  Â  Â  Â  Â  Â  Â  Â  if (Date.now() - this.lastSaveTime > Config.SAVE_INTERVAL) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.saveGame();
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  updateTimeBasedSystems() {
Â  Â  Â  Â  Â  Â  Â  Â  this.entityManager.update(this.worldManager);
Â  Â  Â  Â  Â  Â  Â  Â  this.buffManager.update();
Â  Â  Â  Â  Â  Â  Â  Â  this.uiManager.update(this.worldCreationTime);
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  update(deltaTime) {
Â  Â  Â  Â  Â  Â  Â  Â  // Update WanderDot
Â  Â  Â  Â  Â  Â  Â  Â  const transitionEmoji = this.wanderDot.update(deltaTime, this.bounds, this.buffManager, this.worldManager, this.entityManager);
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  if (transitionEmoji) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.uiManager.showThought(transitionEmoji);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (transitionEmoji === Config.Emojis.cooldownToAnnoyed[0]) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.uiManager.stopMadTimer();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  this.updateTimeBasedSystems();

Â  Â  Â  Â  Â  Â  Â  Â  // Update UFO
Â  Â  Â  Â  Â  Â  Â  Â  this.ufo.update(deltaTime, this.particleManager, this.worldManager);
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  draw(deltaTime) {
Â  Â  Â  Â  Â  Â  Â  Â  // Clear main canvas
Â  Â  Â  Â  Â  Â  Â  Â  this.ctx.clearRect(0, 0, this.bounds.width, this.bounds.height);

Â  Â  Â  Â  Â  Â  Â  Â  // Draw environment/entities
Â  Â  Â  Â  Â  Â  Â  Â  this.entityManager.draw(this.bounds);
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  // Draw main actors
Â  Â  Â  Â  Â  Â  Â  Â  this.wanderDot.draw(this.ctx);
Â  Â  Â  Â  Â  Â  Â  Â  this.ufo.draw();

Â  Â  Â  Â  Â  Â  Â  Â  // Draw particles
Â  Â  Â  Â  Â  Â  Â  Â  this.particleManager.updateAndDraw(deltaTime);
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  start() {
Â  Â  Â  Â  Â  Â  Â  Â  this.uiManager.scheduleNextIdleThought();
Â  Â  Â  Â  Â  Â  Â  Â  requestAnimationFrame((time) => this.animate(time));
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  // ====================================================================
Â  Â  Â  Â  // 8. STARTUP
Â  Â  Â  Â  // ====================================================================
Â  Â  Â  Â  document.addEventListener('DOMContentLoaded', () => {
Â  Â  Â  Â  Â  Â  const game = new Game();
Â  Â  Â  Â  Â  Â  game.start();
Â  Â  Â  Â  });

Â  Â  </script>
</body>
</html>
